<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../../assets/css/copy-button.css" /></p>
<h1>:warning: structure/verify/atcoder-tkppc-2015-j.cpp</h1>
<ul>
<li>category: structure/verify</li>
</ul>
<p><a href="../../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">template&lt; typename T, typename Compare = less&lt; T &gt; &gt;
struct PQ {
  priority_queue&lt; T, vector&lt; T &gt;, Compare &gt; que1, que2;

  PQ() = default;

  void push(T k) {
    que1.emplace(k);
  }

  void pop(T k) {
    que2.emplace(k);
  }

  inline void modify() {
    while(que2.size() &amp;&amp; que2.top() == que1.top()) {
      que2.pop();
      que1.pop();
    }
  }

  bool empty() {
    modify();
    return que1.empty();
  }

  T top() {
    modify();
    return que1.top();
  }
};

int main() {

  struct Farthest {
    PQ&lt; int64 &gt; pq;
    int64 c_max, p_max, length;

    Farthest() : c_max(-infll), p_max(-infll), length(0) {}

    void merge(int64 key, const Farthest &amp;parent, const Farthest &amp;child) {
      p_max = max(child.p_max, child.length + key + max(pq.empty() ? 0 : pq.top(), parent.p_max));
      c_max = max(parent.c_max, parent.length + key + max(pq.empty() ? 0 : pq.top(), child.c_max));
      length = parent.length + key + child.length;
    }

    void toggle() {
      swap(c_max, p_max);
    }

    void add(const Farthest &amp;child) {
      pq.push(child.c_max);
    }

    void erase(const Farthest &amp;child) {
      pq.pop(child.c_max);
    }
  } e;

  int Q;
  cin &gt;&gt; Q;

  using LCT = LinkCutTreeSubtree&lt; Farthest, int64 &gt;;
  LCT lct(e);
  vector&lt; LCT::Node * &gt; ev(500001), ee(500001);
  ev[0] = lct.make_node(0);

  int num = 1;
  for(int i = 0; i &lt; Q; i++) {
    int t, a, b;
    cin &gt;&gt; t &gt;&gt; a &gt;&gt; b;
    if(t == 1) {
      ev[num] = lct.make_node(0);
      ee[num] = lct.make_node(b);
      lct.link(ee[num], ev[a]);
      lct.link(ev[num], ee[num]);
      ++num;
    } else if(t == 2) {
      lct.set_key(ee[a], b);
    } else {
      lct.evert(ev[a]);
      cout &lt;&lt; ev[a]-&gt;sum.c_max &lt;&lt; &quot;\n&quot;;
    }
  }
}

</code></pre>

<p><a href="../../../index.html">Back to top page</a></p>