<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: structure/red-black-tree.cpp</h1>
<ul>
<li>category: structure</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">template&lt; class T &gt;
struct ArrayPool {
  vector&lt; T &gt; pool;
  vector&lt; T * &gt; stock;
  int ptr;

  ArrayPool(int sz) : pool(sz), stock(sz) {}

  inline T *alloc() { return stock[--ptr]; }

  inline void free(T *t) { stock[ptr++] = t; }

  void clear() {
    ptr = (int) pool.size();
    for(int i = 0; i &lt; pool.size(); i++) stock[i] = &amp;pool[i];
  }
};

template&lt; class D, class L, D (*f)(D, D), D (*g)(D, L), L (*h)(L, L), L (*p)(L, int) &gt;
struct RedBlackTree {
  enum COLOR {
    BLACK, RED
  };

  struct Node {
    Node *l, *r;
    COLOR color;
    int level, cnt;
    D key, sum;
    L lazy;

    Node() {}

    Node(const D &amp;k, const L &amp;laz) :
        key(k), sum(k), l(nullptr), r(nullptr), color(BLACK), level(0), cnt(1), lazy(laz) {}

    Node(Node *l, Node *r, const D &amp;k, const L &amp;laz) :
        key(k), color(RED), l(l), r(r), lazy(laz) {}
  };

  ArrayPool&lt; Node &gt; pool;


  const D M1;
  const L OM0;

  RedBlackTree(int sz, const D &amp;M1, const L &amp;OM0) :
      pool(sz), M1(M1), OM0(OM0) { pool.clear(); }


  inline Node *alloc(const D &amp;key) {
    return &amp;(*pool.alloc() = Node(key, OM0));
  }

  inline Node *alloc(Node *l, Node *r) {
    auto t = &amp;(*pool.alloc() = Node(l, r, M1, OM0));
    return update(t);
  }

  virtual Node *clone(Node *t) { return t; }

  inline int count(const Node *t) { return t ? t-&gt;cnt : 0; }

  inline D sum(const Node *t) { return t ? t-&gt;sum : M1; }

  Node *update(Node *t) {
    t-&gt;cnt = count(t-&gt;l) + count(t-&gt;r) + (!t-&gt;l || !t-&gt;r);
    t-&gt;level = t-&gt;l ? t-&gt;l-&gt;level + (t-&gt;l-&gt;color == BLACK) : 0;
    t-&gt;sum = f(f(sum(t-&gt;l), t-&gt;key), sum(t-&gt;r));
    return t;
  }

  Node *propagate(Node *t) {
    t = clone(t);
    if(t-&gt;lazy != OM0) {
      if(!t-&gt;l) {
        t-&gt;key = g(t-&gt;key, p(t-&gt;lazy, 1));
      } else {
        if(t-&gt;l) {
          t-&gt;l = clone(t-&gt;l);
          t-&gt;l-&gt;lazy = h(t-&gt;l-&gt;lazy, t-&gt;lazy);
          t-&gt;l-&gt;sum = g(t-&gt;l-&gt;sum, p(t-&gt;lazy, count(t-&gt;l)));
        }
        if(t-&gt;r) {
          t-&gt;r = clone(t-&gt;r);
          t-&gt;r-&gt;lazy = h(t-&gt;r-&gt;lazy, t-&gt;lazy);
          t-&gt;r-&gt;sum = g(t-&gt;r-&gt;sum, p(t-&gt;lazy, count(t-&gt;r)));
        }
      }
      t-&gt;lazy = OM0;
    }
    return update(t);
  }

  Node *rotate(Node *t, bool b) {
    t = propagate(t);
    Node *s;
    if(b) {
      s = propagate(t-&gt;l);
      t-&gt;l = s-&gt;r;
      s-&gt;r = t;
    } else {
      s = propagate(t-&gt;r);
      t-&gt;r = s-&gt;l;
      s-&gt;l = t;
    }
    update(t);
    return update(s);
  }

  Node *submerge(Node *l, Node *r) {
    if(l-&gt;level &lt; r-&gt;level) {
      r = propagate(r);
      Node *c = (r-&gt;l = submerge(l, r-&gt;l));
      if(r-&gt;color == BLACK &amp;&amp; c-&gt;color == RED &amp;&amp; c-&gt;l &amp;&amp; c-&gt;l-&gt;color == RED) {
        r-&gt;color = RED;
        c-&gt;color = BLACK;
        if(r-&gt;r-&gt;color == BLACK) return rotate(r, true);
        r-&gt;r-&gt;color = BLACK;
      }
      return update(r);
    }
    if(l-&gt;level &gt; r-&gt;level) {
      l = propagate(l);
      Node *c = (l-&gt;r = submerge(l-&gt;r, r));
      if(l-&gt;color == BLACK &amp;&amp; c-&gt;color == RED &amp;&amp; c-&gt;r &amp;&amp; c-&gt;r-&gt;color == RED) {
        l-&gt;color = RED;
        c-&gt;color = BLACK;
        if(l-&gt;l-&gt;color == BLACK) return rotate(l, false);
        l-&gt;l-&gt;color = BLACK;
      }
      return update(l);
    }
    return alloc(l, r);
  }

  Node *merge(Node *l, Node *r) {
    if(!l || !r) return l ? l : r;
    Node *c = submerge(l, r);
    c-&gt;color = BLACK;
    return c;
  }

  pair&lt; Node *, Node * &gt; split(Node *t, int k) {
    if(!t) return {nullptr, nullptr};
    t = propagate(t);
    if(k == 0) return {nullptr, t};
    if(k &gt;= count(t)) return {t, nullptr};
    Node *l = t-&gt;l, *r = t-&gt;r;
    pool.free(t);
    if(k &lt; count(l)) {
      auto pp = split(l, k);
      return {pp.first, merge(pp.second, r)};
    }
    if(k &gt; count(l)) {
      auto pp = split(r, k - count(l));
      return {merge(l, pp.first), pp.second};
    }
    return {l, r};
  }

  Node *build(int l, int r, const vector&lt; D &gt; &amp;v) {
    if(l + 1 &gt;= r) return alloc(v[l]);
    return merge(build(l, (l + r) &gt;&gt; 1, v), build((l + r) &gt;&gt; 1, r, v));
  }

  Node *build(const vector&lt; D &gt; &amp;v) {
    //pool.clear();
    return build(0, (int) v.size(), v);
  }

  void dump(Node *r, typename vector&lt; D &gt;::iterator &amp;it, L lazy) {
    if(r-&gt;lazy != OM0) lazy = h(lazy, r-&gt;lazy);
    if(!r-&gt;l || !r-&gt;r) {
      *it++ = g(r-&gt;key, lazy);
      return;
    }
    dump(r-&gt;l, it, lazy);
    dump(r-&gt;r, it, lazy);
  }

  vector&lt; D &gt; dump(Node *r) {
    vector&lt; D &gt; v((size_t) count(r));
    auto it = begin(v);
    dump(r, it, OM0);
    return v;
  }

  string to_string(Node *r) {
    auto s = dump(r);
    string ret;
    for(int i = 0; i &lt; s.size(); i++) {
      ret += std::to_string(s[i]);
      ret += &quot;, &quot;;
    }
    return (ret);
  }

  void insert(Node *&amp;t, int k, const D &amp;v) {
    auto x = split(t, k);
    t = merge(merge(x.first, alloc(v)), x.second);
  }

  D erase(Node *&amp;t, int k) {
    auto x = split(t, k);
    auto y = split(x.second, 1);
    auto v = y.first-&gt;key;
    pool.free(y.first);
    t = merge(x.first, y.second);
    return v;
  }

  D query(Node *&amp;t, int a, int b) {
    auto x = split(t, a);
    auto y = split(x.second, b - a);
    auto ret = sum(y.first);
    t = merge(x.first, merge(y.first, y.second));
    return ret;
  }

  void set_propagate(Node *&amp;t, int a, int b, const L &amp;pp) {
    auto x = split(t, a);
    auto y = split(x.second, b - a);
    y.first-&gt;lazy = h(y.first-&gt;lazy, pp);
    t = merge(x.first, merge(propagate(y.first), y.second));
  }

  void set_element(Node *&amp;t, int k, const D &amp;x) {
    if(!t-&gt;l) {
      t-&gt;key = t-&gt;sum = x;
      return;
    }
    t = propagate(t);
    if(k &lt; count(t-&gt;l)) set_element(t-&gt;l, k, x);
    else set_element(t-&gt;r, k - count(t-&gt;l), x);
    t = update(t);
  }

  int size(Node *t) {
    return count(t);
  }

  bool empty(Node *t) {
    return !t;
  }

  Node *makeset() {
    return (nullptr);
  }
};

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>