<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: structure/wavelet-matrix.cpp</h1>
<ul>
<li>category: structure</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">struct SuccinctIndexableDictionary {
  size_t length;
  size_t blocks;
  vector&lt; unsigned &gt; bit, sum;

  SuccinctIndexableDictionary() {
  }

  SuccinctIndexableDictionary(size_t _length) {
    length = _length;
    blocks = (length + 31) &gt;&gt; 5;
    bit.assign(blocks, 0U);
    sum.assign(blocks, 0U);
  }

  void set(int k) {
    bit[k &gt;&gt; 5] |= 1U &lt;&lt; (k &amp; 31);
  }

  void build() {
    sum[0] = 0U;
    for(int i = 1; i &lt; blocks; i++) {
      sum[i] = sum[i - 1] + __builtin_popcount(bit[i - 1]);
    }
  }

  bool operator[](int k) const {
    return (bool((bit[k &gt;&gt; 5] &gt;&gt; (k &amp; 31)) &amp; 1));
  }

  int rank(int k) {
    return (sum[k &gt;&gt; 5] + __builtin_popcount(bit[k &gt;&gt; 5] &amp; ((1U &lt;&lt; (k &amp; 31)) - 1)));
  }

  int rank(bool val, int k) {
    return (val ? rank(k) : k - rank(k));
  }

  int select(bool val, int k) {
    if(k &lt; 0 || rank(val, length) &lt;= k) return (-1);
    int low = 0, high = length;
    while(high - low &gt; 1) {
      int mid = (low + high) &gt;&gt; 1;
      if(rank(val, mid) &gt;= k + 1) high = mid;
      else low = mid;
    }
    return (high - 1);
  }

  int select(bool val, int i, int l) {
    return select(val, i + rank(val, l));
  }
};

template&lt; class T, int MAXLOG &gt;
struct WaveletMatrix {
  size_t length;
  SuccinctIndexableDictionary matrix[MAXLOG];
  int zs[MAXLOG];
  int buff1[MAXLOG], buff2[MAXLOG];

  int freq_dfs(int d, int l, int r, T val, T a, T b) {
    if(l == r) return 0;
    if(d == MAXLOG) return (a &lt;= val &amp;&amp; val &lt; b) ? r - l : 0;
    T nv = 1ULL &lt;&lt; (MAXLOG - d - 1) | val, nnv = ((1ULL &lt;&lt; (MAXLOG - d - 1)) - 1) | nv;
    if(nnv &lt; a || b &lt;= val) return 0;
    if(a &lt;= val &amp;&amp; nnv &lt; b) return r - l;
    int lc = matrix[d].rank(1, l), rc = matrix[d].rank(1, r);
    return freq_dfs(d + 1, l - lc, r - rc, val, a, b) +
           freq_dfs(d + 1, lc + zs[d], rc + zs[d], nv, a, b);
  }

  WaveletMatrix(vector&lt; T &gt; data) {
    length = data.size();
    vector&lt; T &gt; l(length), r(length);
    for(int depth = 0; depth &lt; MAXLOG; depth++) {
      matrix[depth] = SuccinctIndexableDictionary(length + 1);
      int left = 0, right = 0;
      for(int i = 0; i &lt; length; i++) {
        bool k = (data[i] &gt;&gt; (MAXLOG - depth - 1)) &amp; 1;
        if(k) r[right++] = data[i], matrix[depth].set(i);
        else l[left++] = data[i];
      }
      zs[depth] = left;
      matrix[depth].build();
      swap(l, data);
      for(int i = 0; i &lt; right; i++) data[left + i] = r[i];
    }
  }

  T access(int k) {
    int ret = 0;
    bool bit;
    for(int depth = 0; depth &lt; MAXLOG; depth++) {
      bit = matrix[depth][k];
      ret = (ret &lt;&lt; 1) | bit;
      k = matrix[depth].rank(bit, k) + zs[depth] * bit;
    }
    return (ret);
  }

  int rank(T val, int k) {
    int l = 0, r = k;
    for(int depth = 0; depth &lt; MAXLOG; depth++) {
      buff1[depth] = l, buff2[depth] = r;
      bool bit = (val &gt;&gt; (MAXLOG - depth - 1)) &amp; 1;
      l = matrix[depth].rank(bit, l) + zs[depth] * bit;
      r = matrix[depth].rank(bit, r) + zs[depth] * bit;
    }
    return (r - l);
  }

  int select(T val, int kth) {
    rank(val, length);
    for(int depth = MAXLOG - 1; depth &gt;= 0; depth--) {
      bool bit = (val &gt;&gt; (MAXLOG - depth - 1)) &amp; 1;
      kth = matrix[depth].select(bit, kth, buff1[depth]);
      if(kth &gt;= buff2[depth] || kth &lt; 0) return (-1);
      kth -= buff1[depth];
    }
    return (kth);
  }

  int select(T val, int k, int l) {
    return select(val, k + rank(val, l));
  }

  int quantile(int left, int right, int kth) {
    if(right - left &lt;= kth || kth &lt; 0) return (-1);
    T ret = 0;
    for(int depth = 0; depth &lt; MAXLOG; depth++) {
      int l = matrix[depth].rank(1, left);
      int r = matrix[depth].rank(1, right);
      if(r - l &gt; kth) {
        left = l + zs[depth];
        right = r + zs[depth];
        ret |= 1ULL &lt;&lt; (MAXLOG - depth - 1);
      } else {
        kth -= r - l;
        left -= l;
        right -= r;
      }
    }
    return ret;
  }

  int rangefreq(int left, int right, T lower, T upper) {
    return freq_dfs(0, left, right, 0, lower, upper);
  }
};


</code></pre>

<p><a href="../../index.html">Back to top page</a></p>