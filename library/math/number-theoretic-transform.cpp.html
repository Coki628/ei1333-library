<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: math/number-theoretic-transform.cpp</h1>
<ul>
<li>category: math</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">template&lt; int mod &gt;
struct NumberTheoreticTransform {

  vector&lt; int &gt; rev, rts;
  int base, max_base, root;

  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {
    assert(mod &gt;= 3 &amp;&amp; mod % 2 == 1);
    auto tmp = mod - 1;
    max_base = 0;
    while(tmp % 2 == 0) tmp &gt;&gt;= 1, max_base++;
    root = 2;
    while(mod_pow(root, (mod - 1) &gt;&gt; 1) == 1) ++root;
    assert(mod_pow(root, mod - 1) == 1);
    root = mod_pow(root, (mod - 1) &gt;&gt; max_base);
  }

  inline int mod_pow(int x, int n) {
    int ret = 1;
    while(n &gt; 0) {
      if(n &amp; 1) ret = mul(ret, x);
      x = mul(x, x);
      n &gt;&gt;= 1;
    }
    return ret;
  }

  inline int inverse(int x) {
    return mod_pow(x, mod - 2);
  }

  inline unsigned add(unsigned x, unsigned y) {
    x += y;
    if(x &gt;= mod) x -= mod;
    return x;
  }

  inline unsigned mul(unsigned a, unsigned b) {
    return 1ull * a * b % (unsigned long long) mod;
  }

  void ensure_base(int nbase) {
    if(nbase &lt;= base) return;
    rev.resize(1 &lt;&lt; nbase);
    rts.resize(1 &lt;&lt; nbase);
    for(int i = 0; i &lt; (1 &lt;&lt; nbase); i++) {
      rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1));
    }
    assert(nbase &lt;= max_base);
    while(base &lt; nbase) {
      int z = mod_pow(root, 1 &lt;&lt; (max_base - 1 - base));
      for(int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) {
        rts[i &lt;&lt; 1] = rts[i];
        rts[(i &lt;&lt; 1) + 1] = mul(rts[i], z);
      }
      ++base;
    }
  }


  void ntt(vector&lt; int &gt; &amp;a) {
    const int n = (int) a.size();
    assert((n &amp; (n - 1)) == 0);
    int zeros = __builtin_ctz(n);
    ensure_base(zeros);
    int shift = base - zeros;
    for(int i = 0; i &lt; n; i++) {
      if(i &lt; (rev[i] &gt;&gt; shift)) {
        swap(a[i], a[rev[i] &gt;&gt; shift]);
      }
    }
    for(int k = 1; k &lt; n; k &lt;&lt;= 1) {
      for(int i = 0; i &lt; n; i += 2 * k) {
        for(int j = 0; j &lt; k; j++) {
          int z = mul(a[i + j + k], rts[j + k]);
          a[i + j + k] = add(a[i + j], mod - z);
          a[i + j] = add(a[i + j], z);
        }
      }
    }
  }


  vector&lt; int &gt; multiply(vector&lt; int &gt; a, vector&lt; int &gt; b) {
    int need = a.size() + b.size() - 1;
    int nbase = 1;
    while((1 &lt;&lt; nbase) &lt; need) nbase++;
    ensure_base(nbase);
    int sz = 1 &lt;&lt; nbase;
    a.resize(sz, 0);
    b.resize(sz, 0);
    ntt(a);
    ntt(b);
    int inv_sz = inverse(sz);
    for(int i = 0; i &lt; sz; i++) {
      a[i] = mul(a[i], mul(b[i], inv_sz));
    }
    reverse(a.begin() + 1, a.end());
    ntt(a);
    a.resize(need);
    return a;
  }
};

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>