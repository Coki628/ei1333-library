<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: math/formal-power-series.cpp</h1>
<ul>
<li>category: math</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">template&lt; typename T &gt;
struct FormalPowerSeries : vector&lt; T &gt; {
  using vector&lt; T &gt;::vector;
  using P = FormalPowerSeries;

  using MULT = function&lt; P(P, P) &gt;;
  using FFT = function&lt; void(P &amp;) &gt;;

  static MULT &amp;get_mult() {
    static MULT mult = nullptr;
    return mult;
  }

  static void set_mult(MULT f) { get_mult() = f; }

  static FFT &amp;get_fft() {
    static FFT fft = nullptr;
    return fft;
  }

  static FFT &amp;get_ifft() {
    static FFT ifft = nullptr;
    return ifft;
  }

  static void set_fft(FFT f, FFT g) {
    get_fft() = f;
    get_ifft() = g;
  }

  void shrink() {
    while(this-&gt;size() &amp;&amp; this-&gt;back() == T(0)) this-&gt;pop_back();
  }

  P operator+(const P &amp;r) const { return P(*this) += r; }

  P operator+(const T &amp;v) const { return P(*this) += v; }

  P operator-(const P &amp;r) const { return P(*this) -= r; }

  P operator-(const T &amp;v) const { return P(*this) -= v; }

  P operator*(const P &amp;r) const { return P(*this) *= r; }

  P operator*(const T &amp;v) const { return P(*this) *= v; }

  P operator/(const P &amp;r) const { return P(*this) /= r; }

  P operator%(const P &amp;r) const { return P(*this) %= r; }

  P &amp;operator+=(const P &amp;r) {
    if(r.size() &gt; this-&gt;size()) this-&gt;resize(r.size());
    for(int i = 0; i &lt; r.size(); i++) (*this)[i] += r[i];
    return *this;
  }

  P &amp;operator+=(const T &amp;r) {
    if(this-&gt;empty()) this-&gt;resize(1);
    (*this)[0] += r;
    return *this;
  }

  P &amp;operator-=(const P &amp;r) {
    if(r.size() &gt; this-&gt;size()) this-&gt;resize(r.size());
    for(int i = 0; i &lt; r.size(); i++) (*this)[i] -= r[i];
    shrink();
    return *this;
  }

  P &amp;operator-=(const T &amp;r) {
    if(this-&gt;empty()) this-&gt;resize(1);
    (*this)[0] -= r;
    shrink();
    return *this;
  }

  P &amp;operator*=(const T &amp;v) {
    const int n = (int) this-&gt;size();
    for(int k = 0; k &lt; n; k++) (*this)[k] *= v;
    return *this;
  }

  P &amp;operator*=(const P &amp;r) {
    if(this-&gt;empty() || r.empty()) {
      this-&gt;clear();
      return *this;
    }
    assert(get_mult() != nullptr);
    return *this = get_mult()(*this, r);
  }

  P &amp;operator%=(const P &amp;r) { return *this -= *this / r * r; }

  P operator-() const {
    P ret(this-&gt;size());
    for(int i = 0; i &lt; this-&gt;size(); i++) ret[i] = -(*this)[i];
    return ret;
  }

  P &amp;operator/=(const P &amp;r) {
    if(this-&gt;size() &lt; r.size()) {
      this-&gt;clear();
      return *this;
    }
    int n = this-&gt;size() - r.size() + 1;
    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);
  }

  P dot(P r) const {
    P ret(min(this-&gt;size(), r.size()));
    for(int i = 0; i &lt; ret.size(); i++) ret[i] = (*this)[i] * r[i];
    return ret;
  }

  P pre(int sz) const { return P(begin(*this), begin(*this) + min((int) this-&gt;size(), sz)); }

  P operator&gt;&gt;(int sz) const {
    if(this-&gt;size() &lt;= sz) return {};
    P ret(*this);
    ret.erase(ret.begin(), ret.begin() + sz);
    return ret;
  }

  P operator&lt;&lt;(int sz) const {
    P ret(*this);
    ret.insert(ret.begin(), sz, T(0));
    return ret;
  }

  P rev(int deg = -1) const {
    P ret(*this);
    if(deg != -1) ret.resize(deg, T(0));
    reverse(begin(ret), end(ret));
    return ret;
  }

  P diff() const {
    const int n = (int) this-&gt;size();
    P ret(max(0, n - 1));
    for(int i = 1; i &lt; n; i++) ret[i - 1] = (*this)[i] * T(i);
    return ret;
  }

  P integral() const {
    const int n = (int) this-&gt;size();
    P ret(n + 1);
    ret[0] = T(0);
    for(int i = 0; i &lt; n; i++) ret[i + 1] = (*this)[i] / T(i + 1);
    return ret;
  }

  // F(0) must not be 0
  P inv(int deg = -1) const {
    assert(((*this)[0]) != T(0));
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    if(get_fft() != nullptr) {
      P ret(*this);
      ret.resize(deg, T(0));
      return ret.inv_fast();
    }
    P ret({T(1) / (*this)[0]});
    for(int i = 1; i &lt; deg; i &lt;&lt;= 1) {
      ret = (ret + ret - ret * ret * pre(i &lt;&lt; 1)).pre(i &lt;&lt; 1);
    }
    return ret.pre(deg);
  }

  // F(0) must be 1
  P log(int deg = -1) const {
    assert((*this)[0] == 1);
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    return (this-&gt;diff() * this-&gt;inv(deg)).pre(deg - 1).integral();
  }

  P sqrt(int deg = -1) const {
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    if((*this)[0] == T(0)) {
      for(int i = 1; i &lt; n; i++) {
        if((*this)[i] != T(0)) {
          if(i &amp; 1) return {};
          if(deg - i / 2 &lt;= 0) break;
          auto ret = (*this &gt;&gt; i).sqrt(deg - i / 2) &lt;&lt; (i / 2);
          if(ret.size() &lt; deg) ret.resize(deg, T(0));
          return ret;
        }
      }
      return P(deg, 0);
    }

    P ret({T(1)});
    T inv2 = T(1) / T(2);
    for(int i = 1; i &lt; deg; i &lt;&lt;= 1) {
      ret = (ret + pre(i &lt;&lt; 1) * ret.inv(i &lt;&lt; 1)) * inv2;
    }
    return ret.pre(deg);
  }

  // F(0) must be 0
  P exp(int deg = -1) const {
    assert((*this)[0] == T(0));
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    if(get_fft() != nullptr) {
      P ret(*this);
      ret.resize(deg, T(0));
      return ret.exp_rec();
    }
    P ret({T(1)});
    for(int i = 1; i &lt; deg; i &lt;&lt;= 1) {
      ret = (ret * (pre(i &lt;&lt; 1) + T(1) - ret.log(i &lt;&lt; 1))).pre(i &lt;&lt; 1);
    }
    return ret.pre(deg);
  }


  P online_convolution_exp(const P &amp;conv_coeff) const {
    const int n = (int) conv_coeff.size();
    assert((n &amp; (n - 1)) == 0);
    vector&lt; P &gt; conv_ntt_coeff;
    for(int i = n; i &gt;= 1; i &gt;&gt;= 1) {
      P g(conv_coeff.pre(i));
      get_fft()(g);
      conv_ntt_coeff.emplace_back(g);
    }
    P conv_arg(n), conv_ret(n);
    auto rec = [&amp;](auto rec, int l, int r, int d) -&gt; void {
      if(r - l &lt;= 16) {
        for(int i = l; i &lt; r; i++) {
          T sum = 0;
          for(int j = l; j &lt; i; j++) sum += conv_arg[j] * conv_coeff[i - j];
          conv_ret[i] += sum;
          conv_arg[i] = i == 0 ? T(1) : conv_ret[i] / i;
        }
      } else {
        int m = (l + r) / 2;
        rec(rec, l, m, d + 1);
        P pre(r - l);
        for(int i = 0; i &lt; m - l; i++) pre[i] = conv_arg[l + i];
        get_fft()(pre);
        for(int i = 0; i &lt; r - l; i++) pre[i] *= conv_ntt_coeff[d][i];
        get_ifft()(pre);
        for(int i = 0; i &lt; r - m; i++) conv_ret[m + i] += pre[m + i - l];
        rec(rec, m, r, d + 1);
      }
    };
    rec(rec, 0, n, 0);
    return conv_arg;
  }

  P exp_rec() const {
    assert((*this)[0] == T(0));
    const int n = (int) this-&gt;size();
    int m = 1;
    while(m &lt; n) m *= 2;
    P conv_coeff(m);
    for(int i = 1; i &lt; n; i++) conv_coeff[i] = (*this)[i] * i;
    return online_convolution_exp(conv_coeff).pre(n);
  }


  P inv_fast() const {
    assert(((*this)[0]) != T(0));

    const int n = (int) this-&gt;size();
    P res{T(1) / (*this)[0]};

    for(int d = 1; d &lt; n; d &lt;&lt;= 1) {
      P f(2 * d), g(2 * d);
      for(int j = 0; j &lt; min(n, 2 * d); j++) f[j] = (*this)[j];
      for(int j = 0; j &lt; d; j++) g[j] = res[j];
      get_fft()(f);
      get_fft()(g);
      for(int j = 0; j &lt; 2 * d; j++) f[j] *= g[j];
      get_ifft()(f);
      for(int j = 0; j &lt; d; j++) {
        f[j] = 0;
        f[j + d] = -f[j + d];
      }
      get_fft()(f);
      for(int j = 0; j &lt; 2 * d; j++) f[j] *= g[j];
      get_ifft()(f);
      for(int j = 0; j &lt; d; j++) f[j] = res[j];
      res = f;
    }
    return res.pre(n);
  }

  P pow(int64_t k, int deg = -1) const {
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    for(int i = 0; i &lt; n; i++) {
      if((*this)[i] != T(0)) {
        T rev = T(1) / (*this)[i];
        P ret = (((*this * rev) &gt;&gt; i).log() * k).exp() * ((*this)[i].pow(k));
        if(i * k &gt; deg) return P(deg, T(0));
        ret = (ret &lt;&lt; (i * k)).pre(deg);
        if(ret.size() &lt; deg) ret.resize(deg, T(0));
        return ret;
      }
    }
    return *this;
  }

  T eval(T x) const {
    T r = 0, w = 1;
    for(auto &amp;v : *this) {
      r += w * v;
      w *= x;
    }
    return r;
  }

  P pow_mod(int64_t n, P mod) const {
    P modinv = mod.rev().inv();
    auto get_div = [&amp;](P base) {
      if(base.size() &lt; mod.size()) {
        base.clear();
        return base;
      }
      int n = base.size() - mod.size() + 1;
      return (base.rev().pre(n) * modinv.pre(n)).pre(n).rev(n);
    };
    P x(*this), ret{1};
    while(n &gt; 0) {
      if(n &amp; 1) {
        ret *= x;
        ret -= get_div(ret) * mod;
      }
      x *= x;
      x -= get_div(x) * mod;
      n &gt;&gt;= 1;
    }
    return ret;
  }
};

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>