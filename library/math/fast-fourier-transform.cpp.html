<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: math/fast-fourier-transform.cpp</h1>
<ul>
<li>category: math</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">namespace FastFourierTransform {
  using real = double;

  struct C {
    real x, y;

    C() : x(0), y(0) {}

    C(real x, real y) : x(x), y(y) {}

    inline C operator+(const C &amp;c) const { return C(x + c.x, y + c.y); }

    inline C operator-(const C &amp;c) const { return C(x - c.x, y - c.y); }

    inline C operator*(const C &amp;c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }

    inline C conj() const { return C(x, -y); }
  };

  const real PI = acosl(-1);
  int base = 1;
  vector&lt; C &gt; rts = { {0, 0},
                     {1, 0} };
  vector&lt; int &gt; rev = {0, 1};


  void ensure_base(int nbase) {
    if(nbase &lt;= base) return;
    rev.resize(1 &lt;&lt; nbase);
    rts.resize(1 &lt;&lt; nbase);
    for(int i = 0; i &lt; (1 &lt;&lt; nbase); i++) {
      rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1));
    }
    while(base &lt; nbase) {
      real angle = PI * 2.0 / (1 &lt;&lt; (base + 1));
      for(int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) {
        rts[i &lt;&lt; 1] = rts[i];
        real angle_i = angle * (2 * i + 1 - (1 &lt;&lt; base));
        rts[(i &lt;&lt; 1) + 1] = C(cos(angle_i), sin(angle_i));
      }
      ++base;
    }
  }

  void fft(vector&lt; C &gt; &amp;a, int n) {
    assert((n &amp; (n - 1)) == 0);
    int zeros = __builtin_ctz(n);
    ensure_base(zeros);
    int shift = base - zeros;
    for(int i = 0; i &lt; n; i++) {
      if(i &lt; (rev[i] &gt;&gt; shift)) {
        swap(a[i], a[rev[i] &gt;&gt; shift]);
      }
    }
    for(int k = 1; k &lt; n; k &lt;&lt;= 1) {
      for(int i = 0; i &lt; n; i += 2 * k) {
        for(int j = 0; j &lt; k; j++) {
          C z = a[i + j + k] * rts[j + k];
          a[i + j + k] = a[i + j] - z;
          a[i + j] = a[i + j] + z;
        }
      }
    }
  }

  vector&lt; int64_t &gt; multiply(const vector&lt; int &gt; &amp;a, const vector&lt; int &gt; &amp;b) {
    int need = (int) a.size() + (int) b.size() - 1;
    int nbase = 1;
    while((1 &lt;&lt; nbase) &lt; need) nbase++;
    ensure_base(nbase);
    int sz = 1 &lt;&lt; nbase;
    vector&lt; C &gt; fa(sz);
    for(int i = 0; i &lt; sz; i++) {
      int x = (i &lt; (int) a.size() ? a[i] : 0);
      int y = (i &lt; (int) b.size() ? b[i] : 0);
      fa[i] = C(x, y);
    }
    fft(fa, sz);
    C r(0, -0.25 / (sz &gt;&gt; 1)), s(0, 1), t(0.5, 0);
    for(int i = 0; i &lt;= (sz &gt;&gt; 1); i++) {
      int j = (sz - i) &amp; (sz - 1);
      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;
      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;
      fa[i] = z;
    }
    for(int i = 0; i &lt; (sz &gt;&gt; 1); i++) {
      C A0 = (fa[i] + fa[i + (sz &gt;&gt; 1)]) * t;
      C A1 = (fa[i] - fa[i + (sz &gt;&gt; 1)]) * t * rts[(sz &gt;&gt; 1) + i];
      fa[i] = A0 + A1 * s;
    }
    fft(fa, sz &gt;&gt; 1);
    vector&lt; int64_t &gt; ret(need);
    for(int i = 0; i &lt; need; i++) {
      ret[i] = llround(i &amp; 1 ? fa[i &gt;&gt; 1].y : fa[i &gt;&gt; 1].x);
    }
    return ret;
  }
};

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>