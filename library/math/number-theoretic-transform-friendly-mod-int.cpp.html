<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: math/number-theoretic-transform-friendly-mod-int.cpp</h1>
<ul>
<li>category: math</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">template&lt; typename Mint &gt;
struct NumberTheoreticTransformFriendlyModInt {

  vector&lt; int &gt; rev;
  vector&lt; Mint &gt; rts;
  int base, max_base;
  Mint root;

  NumberTheoreticTransformFriendlyModInt() : base(1), rev{0, 1}, rts{0, 1} {
    const int mod = Mint::get_mod();
    assert(mod &gt;= 3 &amp;&amp; mod % 2 == 1);
    auto tmp = mod - 1;
    max_base = 0;
    while(tmp % 2 == 0) tmp &gt;&gt;= 1, max_base++;
    root = 2;
    while(root.pow((mod - 1) &gt;&gt; 1) == 1) root += 1;
    assert(root.pow(mod - 1) == 1);
    root = root.pow((mod - 1) &gt;&gt; max_base);
  }

  void ensure_base(int nbase) {
    if(nbase &lt;= base) return;
    rev.resize(1 &lt;&lt; nbase);
    rts.resize(1 &lt;&lt; nbase);
    for(int i = 0; i &lt; (1 &lt;&lt; nbase); i++) {
      rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1));
    }
    assert(nbase &lt;= max_base);
    while(base &lt; nbase) {
      Mint z = root.pow(1 &lt;&lt; (max_base - 1 - base));
      for(int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) {
        rts[i &lt;&lt; 1] = rts[i];
        rts[(i &lt;&lt; 1) + 1] = rts[i] * z;
      }
      ++base;
    }
  }


  void ntt(vector&lt; Mint &gt; &amp;a) {
    const int n = (int) a.size();
    assert((n &amp; (n - 1)) == 0);
    int zeros = __builtin_ctz(n);
    ensure_base(zeros);
    int shift = base - zeros;
    for(int i = 0; i &lt; n; i++) {
      if(i &lt; (rev[i] &gt;&gt; shift)) {
        swap(a[i], a[rev[i] &gt;&gt; shift]);
      }
    }
    for(int k = 1; k &lt; n; k &lt;&lt;= 1) {
      for(int i = 0; i &lt; n; i += 2 * k) {
        for(int j = 0; j &lt; k; j++) {
          Mint z = a[i + j + k] * rts[j + k];
          a[i + j + k] = a[i + j] - z;
          a[i + j] = a[i + j] + z;
        }
      }
    }
  }


  void intt(vector&lt; Mint &gt; &amp;a) {
    const int n = (int) a.size();
    ntt(a);
    reverse(a.begin() + 1, a.end());
    Mint inv_sz = Mint(1) / n;
    for(int i = 0; i &lt; n; i++) a[i] *= inv_sz;
  }

  vector&lt; Mint &gt; multiply(vector&lt; Mint &gt; a, vector&lt; Mint &gt; b) {
    int need = a.size() + b.size() - 1;
    int nbase = 1;
    while((1 &lt;&lt; nbase) &lt; need) nbase++;
    ensure_base(nbase);
    int sz = 1 &lt;&lt; nbase;
    a.resize(sz, 0);
    b.resize(sz, 0);
    ntt(a);
    ntt(b);
    Mint inv_sz = Mint(1) / sz;
    for(int i = 0; i &lt; sz; i++) {
      a[i] *= b[i] * inv_sz;
    }
    reverse(a.begin() + 1, a.end());
    ntt(a);
    a.resize(need);
    return a;
  }
};

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>