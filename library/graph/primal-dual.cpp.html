<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: graph/primal-dual.cpp</h1>
<ul>
<li>category: graph</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Verified</h2>
<ul>
<li>:warning: <a href="../../verify/graph/verify/aoj-grl-6-b.test.cpp.html">graph/verify/aoj-grl-6-b.test.cpp</a></li>
</ul>
<h2>Code</h2>
<pre><code class="cpp">template&lt; typename flow_t, typename cost_t &gt;
struct PrimalDual {
  const cost_t INF;

  struct edge {
    int to;
    flow_t cap;
    cost_t cost;
    int rev;
    bool isrev;
  };
  vector&lt; vector&lt; edge &gt; &gt; graph;
  vector&lt; cost_t &gt; potential, min_cost;
  vector&lt; int &gt; prevv, preve;

  PrimalDual(int V) : graph(V), INF(numeric_limits&lt; cost_t &gt;::max()) {}

  void add_edge(int from, int to, flow_t cap, cost_t cost) {
    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});
    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});
  }

  cost_t min_cost_flow(int s, int t, flow_t f) {
    int V = (int) graph.size();
    cost_t ret = 0;
    using Pi = pair&lt; cost_t, int &gt;;
    priority_queue&lt; Pi, vector&lt; Pi &gt;, greater&lt; Pi &gt; &gt; que;
    potential.assign(V, 0);
    preve.assign(V, -1);
    prevv.assign(V, -1);

    while(f &gt; 0) {
      min_cost.assign(V, INF);
      que.emplace(0, s);
      min_cost[s] = 0;
      while(!que.empty()) {
        Pi p = que.top();
        que.pop();
        if(min_cost[p.second] &lt; p.first) continue;
        for(int i = 0; i &lt; graph[p.second].size(); i++) {
          edge &amp;e = graph[p.second][i];
          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];
          if(e.cap &gt; 0 &amp;&amp; min_cost[e.to] &gt; nextCost) {
            min_cost[e.to] = nextCost;
            prevv[e.to] = p.second, preve[e.to] = i;
            que.emplace(min_cost[e.to], e.to);
          }
        }
      }
      if(min_cost[t] == INF) return -1;
      for(int v = 0; v &lt; V; v++) potential[v] += min_cost[v];
      flow_t addflow = f;
      for(int v = t; v != s; v = prevv[v]) {
        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);
      }
      f -= addflow;
      ret += addflow * potential[t];
      for(int v = t; v != s; v = prevv[v]) {
        edge &amp;e = graph[prevv[v]][preve[v]];
        e.cap -= addflow;
        graph[v][e.rev].cap += addflow;
      }
    }
    return ret;
  }

  void output() {
    for(int i = 0; i &lt; graph.size(); i++) {
      for(auto &amp;e : graph[i]) {
        if(e.isrev) continue;
        auto &amp;rev_e = graph[e.to][e.rev];
        cout &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e.to &lt;&lt; &quot; (flow: &quot; &lt;&lt; rev_e.cap &lt;&lt; &quot;/&quot; &lt;&lt; rev_e.cap + e.cap &lt;&lt; &quot;)&quot; &lt;&lt; endl;
      }
    }
  }
};

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>