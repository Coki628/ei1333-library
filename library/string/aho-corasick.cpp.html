<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: string/aho-corasick.cpp</h1>
<ul>
<li>category: string</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">template&lt; int char_size, int margin &gt;
struct AhoCorasick : Trie&lt; char_size + 1, margin &gt; {
  using Trie&lt; char_size + 1, margin &gt;::Trie;

  const int FAIL = char_size;
  vector&lt; int &gt; correct;

  void build(bool heavy = true) {
    correct.resize(this-&gt;size());
    for(int i = 0; i &lt; this-&gt;size(); i++) {
      correct[i] = (int) this-&gt;nodes[i].accept.size();
    }
    queue&lt; int &gt; que;
    for(int i = 0; i &lt;= char_size; i++) {
      if(~this-&gt;nodes[0].nxt[i]) {
        this-&gt;nodes[this-&gt;nodes[0].nxt[i]].nxt[FAIL] = 0;
        que.emplace(this-&gt;nodes[0].nxt[i]);
      } else {
        this-&gt;nodes[0].nxt[i] = 0;
      }
    }
    while(!que.empty()) {
      auto &amp;now = this-&gt;nodes[que.front()];
      int fail = now.nxt[FAIL];
      correct[que.front()] += correct[fail];
      que.pop();
      for(int i = 0; i &lt; char_size; i++) {
        if(~now.nxt[i]) {
          this-&gt;nodes[now.nxt[i]].nxt[FAIL] = this-&gt;nodes[fail].nxt[i];
          if(heavy) {
            auto &amp;u = this-&gt;nodes[now.nxt[i]].accept;
            auto &amp;v = this-&gt;nodes[this-&gt;nodes[fail].nxt[i]].accept;
            vector&lt; int &gt; accept;
            set_union(begin(u), end(u), begin(v), end(v), back_inserter(accept));
            u = accept;
          }
          que.emplace(now.nxt[i]);
        } else {
          now.nxt[i] = this-&gt;nodes[fail].nxt[i];
        }
      }
    }
  }

  map&lt; int, int &gt; match(const string &amp;str, int now = 0) {
    map&lt; int, int &gt; result;
    for(auto &amp;c : str) {
      now = this-&gt;nodes[now].nxt[c - margin];
      for(auto &amp;v : this-&gt;nodes[now].accept) result[v] += 1;
    }
    return result;
  }

  pair&lt; int64_t, int &gt; move(const char &amp;c, int now = 0) {
    now = this-&gt;nodes[now].nxt[c - margin];
    return {correct[now], now};
  }

  pair&lt; int64_t, int &gt; move(const string &amp;str, int now = 0) {
    int64_t sum = 0;
    for(auto &amp;c : str) {
      auto nxt = move(c, now);
      sum += nxt.first;
      now = nxt.second;
    }
    return {sum, now};
  }
};

</code></pre>

<p><a href="../../index.html">Back to top page</a></p>