<!-- mathjax config similar to math.stackexchange -->

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" }},
    tex2jax: {
      inlineMath: [ ['$','$'] ],
      processEscapes: true
    },
    "HTML-CSS": { matchFontHeight: false },
    displayAlign: "left",
    displayIndent: "2em"
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-balloon-js@1.1.2/jquery.balloon.min.js" integrity="sha256-ZEYs9VrgAeNuPvs15E39OsyOJaIkXEEt10fzxJ20+2I=" crossorigin="anonymous"></script>

<script type="text/javascript" src="../../assets/js/copy-button.js"></script>

<p><link rel="stylesheet" href="../../assets/css/copy-button.css" /></p>
<h1>:warning: icpc/library.cpp</h1>
<ul>
<li>category: icpc</li>
</ul>
<p><a href="../../index.html">Back to top page</a></p>
<h2>Code</h2>
<pre><code class="cpp">ICPC Library @ tapu
--------------------------------------------------
|                      tree                      |
--------------------------------------------------

##################################################
############### tree-diameter.cpp ################
##################################################

template&lt; typename T &gt;
pair&lt; T, int &gt; dfs(const WeightedGraph&lt; T &gt; &amp;g, int idx, int par) {
  pair&lt; T, int &gt; ret(0, idx);
  for(auto &amp;e : g[idx]) {
    if(e.to == par) continue;
    auto cost = dfs(g, e.to, idx);
    cost.first += e.cost;
    ret = max(ret, cost);
  }
  return ret;
}

template&lt; typename T &gt;
T tree_diameter(const WeightedGraph&lt; T &gt; &amp;g) {
  auto p = dfs(g, 0, -1);
  auto q = dfs(g, p.second, -1);
  return (q.first);
}


##################################################
###### doubling-lowest-common-ancestor.cpp #######
##################################################

template&lt; typename G &gt;
struct DoublingLowestCommonAncestor {
  const int LOG;
  vector&lt; int &gt; dep;
  const G &amp;g;
  vector&lt; vector&lt; int &gt; &gt; table;

  DoublingLowestCommonAncestor(const G &amp;g) : g(g), dep(g.size()), LOG(32 - __builtin_clz(g.size())) {
    table.assign(LOG, vector&lt; int &gt;(g.size(), -1));
  }

  void dfs(int idx, int par, int d) {
    table[0][idx] = par;
    dep[idx] = d;
    for(auto &amp;to : g[idx]) {
      if(to != par) dfs(to, idx, d + 1);
    }
  }

  void build() {
    dfs(0, -1, 0);
    for(int k = 0; k + 1 &lt; LOG; k++) {
      for(int i = 0; i &lt; table[k].size(); i++) {
        if(table[k][i] == -1) table[k + 1][i] = -1;
        else table[k + 1][i] = table[k][table[k][i]];
      }
    }
  }

  int query(int u, int v) {
    if(dep[u] &gt; dep[v]) swap(u, v);
    for(int i = LOG - 1; i &gt;= 0; i--) {
      if(((dep[v] - dep[u]) &gt;&gt; i) &amp; 1) v = table[i][v];
    }
    if(u == v) return u;
    for(int i = LOG - 1; i &gt;= 0; i--) {
      if(table[i][u] != table[i][v]) {
        u = table[i][u];
        v = table[i][v];
      }
    }
    return table[0][u];
  }
};


##################################################
############## tree-isomorphism.cpp ##############
##################################################

template&lt; typename G &gt;
bool tree_isomorphism(const G &amp;a, const G &amp;b) {
  if(a.size() != b.size()) return false;

  const int N = (int) a.size();
  using pvi = pair&lt; vector&lt; int &gt;, vector&lt; int &gt; &gt;;

  auto get_uku = [&amp;](const G &amp;t, int e) {
    stack&lt; pair&lt; int, int &gt; &gt; st;
    st.emplace(e, -1);
    vector&lt; int &gt; dep(N, -1), par(N);
    while(!st.empty()) {
      auto p = st.top();
      if(dep[p.first] == -1) {
        dep[p.first] = p.second == -1 ? 0 : dep[p.second] + 1;
        for(auto &amp;to : t[p.first]) if(to != p.second) st.emplace(to, p.first);
      } else {
        par[p.first] = p.second;
        st.pop();
      }
    }
    return make_pair(dep, par);
  };

  auto solve = [&amp;](const pvi &amp;latte, const pvi &amp;malta) {

    int d = *max_element(begin(latte.first), end(latte.first));
    if(d != *max_element(begin(malta.first), end(malta.first))) return false;

    vector&lt; vector&lt; int &gt; &gt; latte_d(d + 1), malta_d(d + 1), latte_key(N), malta_key(N);

    for(int i = 0; i &lt; N; i++) latte_d[latte.first[i]].emplace_back(i);
    for(int i = 0; i &lt; N; i++) malta_d[malta.first[i]].emplace_back(i);

    for(int i = d; i &gt;= 0; i--) {
      map&lt; vector&lt; int &gt;, int &gt; ord;
      for(auto &amp;idx : latte_d[i]) {
        sort(begin(latte_key[idx]), end(latte_key[idx]));
        ord[latte_key[idx]]++;
      }
      for(auto &amp;idx : malta_d[i]) {
        sort(begin(malta_key[idx]), end(malta_key[idx]));
        if(--ord[malta_key[idx]] &lt; 0) return false;
      }
      if(i == 0) return ord.size() == 1;

      int ptr = 0;
      for(auto &amp;p : ord) {
        if(p.second != 0) return false;
        p.second = ptr++;
      }
      for(auto &amp;idx : latte_d[i]) {
        latte_key[latte.second[idx]].emplace_back(ord[latte_key[idx]]);
      }
      for(auto &amp;idx : malta_d[i]) {
        malta_key[malta.second[idx]].emplace_back(ord[malta_key[idx]]);
      }
    }
    assert(0);
  };
  auto p = centroid(a), q = centroid(b);
  if(p.size() != q.size()) return false;
  auto a1 = get_uku(a, p[0]);
  auto b1 = get_uku(b, q[0]);
  if(solve(a1, b1)) return true;
  if(p.size() == 1) return false;
  auto a2 = get_uku(a, p[1]);
  return solve(a2, b1);
}


##################################################
######### heavy-light-decomposition.cpp ##########
##################################################

template&lt; typename G &gt;
struct HeavyLightDecomposition {
  G &amp;g;
  vector&lt; int &gt; sz, in, out, head, rev, par;

  HeavyLightDecomposition(G &amp;g) :
      g(g), sz(g.size()), in(g.size()), out(g.size()), head(g.size()), rev(g.size()), par(g.size()) {}

  void dfs_sz(int idx, int p) {
    par[idx] = p;
    sz[idx] = 1;
    if(g[idx].size() &amp;&amp; g[idx][0] == p) swap(g[idx][0], g[idx].back());
    for(auto &amp;to : g[idx]) {
      if(to == p) continue;
      dfs_sz(to, idx);
      sz[idx] += sz[to];
      if(sz[g[idx][0]] &lt; sz[to]) swap(g[idx][0], to);
    }
  }

  void dfs_hld(int idx, int par, int &amp;times) {
    in[idx] = times++;
    rev[in[idx]] = idx;
    for(auto &amp;to : g[idx]) {
      if(to == par) continue;
      head[to] = (g[idx][0] == to ? head[idx] : to);
      dfs_hld(to, idx, times);
    }
    out[idx] = times;
  }

  void build() {
    dfs_sz(0, -1);
    int t = 0;
    dfs_hld(0, -1, t);
  }

  int la(int v, int k) {
    while(1) {
      int u = head[v];
      if(in[v] - k &gt;= in[u]) return rev[in[v] - k];
      k -= in[v] - in[u] + 1;
      v = par[u];
    }
  }

  int lca(int u, int v) {
    for(;; v = par[head[v]]) {
      if(in[u] &gt; in[v]) swap(u, v);
      if(head[u] == head[v]) return u;
    }
  }

  template&lt; typename T, typename Q, typename F &gt;
  T query(int u, int v, const T &amp;ti, const Q &amp;q, const F &amp;f, bool edge = false) {
    T l = ti, r = ti;
    for(;; v = par[head[v]]) {
      if(in[u] &gt; in[v]) swap(u, v), swap(l, r);
      if(head[u] == head[v]) break;
      l = f(q(in[head[v]], in[v] + 1), l);
    }
    return f(f(q(in[u] + edge, in[v] + 1), l), r);
//  return {f(q(in[u] + edge, in[v] + 1), l), r};
  }

  template&lt; typename Q &gt;
  void add(int u, int v, const Q &amp;q, bool edge = false) {
    for(;; v = par[head[v]]) {
      if(in[u] &gt; in[v]) swap(u, v);
      if(head[u] == head[v]) break;
      q(in[head[v]], in[v] + 1);
    }
    q(in[u] + edge, in[v] + 1);
  }
};


##################################################
################# rerooting.cpp ##################
##################################################

template&lt; typename Data, typename T &gt;
struct ReRooting {

  struct Node {
    int to, rev;
    Data data;
  };

  using F1 = function&lt; T(T, T) &gt;;
  using F2 = function&lt; T(T, Data) &gt;;

  vector&lt; vector&lt; Node &gt; &gt; g;
  vector&lt; vector&lt; T &gt; &gt; ldp, rdp;
  vector&lt; int &gt; lptr, rptr;
  const F1 f1;
  const F2 f2;
  const T ident;

  ReRooting(int n, const F1 &amp;f1, const F2 &amp;f2, const T &amp;ident) :
      g(n), ldp(n), rdp(n), lptr(n), rptr(n), f1(f1), f2(f2), ident(ident) {}

  void add_edge(int u, int v, const Data &amp;d) {
    g[u].emplace_back((Node) {v, (int) g[v].size(), d});
    g[v].emplace_back((Node) {u, (int) g[u].size() - 1, d});
  }

  void add_edge_bi(int u, int v, const Data &amp;d, const Data &amp;e) {
    g[u].emplace_back((Node) {v, (int) g[v].size(), d});
    g[v].emplace_back((Node) {u, (int) g[u].size() - 1, e});
  }


  T dfs(int idx, int par) {

    while(lptr[idx] != par &amp;&amp; lptr[idx] &lt; g[idx].size()) {
      auto &amp;e = g[idx][lptr[idx]];
      ldp[idx][lptr[idx] + 1] = f1(ldp[idx][lptr[idx]], f2(dfs(e.to, e.rev), e.data));
      ++lptr[idx];
    }
    while(rptr[idx] != par &amp;&amp; rptr[idx] &gt;= 0) {
      auto &amp;e = g[idx][rptr[idx]];
      rdp[idx][rptr[idx]] = f1(rdp[idx][rptr[idx] + 1], f2(dfs(e.to, e.rev), e.data));
      --rptr[idx];
    }
    if(par &lt; 0) return rdp[idx][0];
    return f1(ldp[idx][par], rdp[idx][par + 1]);
  }

  vector&lt; T &gt; solve() {
    for(int i = 0; i &lt; g.size(); i++) {
      ldp[i].assign(g[i].size() + 1, ident);
      rdp[i].assign(g[i].size() + 1, ident);
      lptr[i] = 0;
      rptr[i] = (int) g[i].size() - 1;
    }
    vector&lt; T &gt; ret;
    for(int i = 0; i &lt; g.size(); i++) {
      ret.push_back(dfs(i, -1));
    }
    return ret;
  }
};


##################################################
############ convert-rooted-tree.cpp #############
##################################################

template&lt; typename G &gt;
G convert_rooted_tree(const G &amp;g, int r = 0) {
  int N = (int) g.size();
  G rg(N);
  vector&lt; int &gt; v(N);
  v[r] = 1;
  queue&lt; int &gt; que;
  que.emplace(r);
  while(!que.empty()) {
    auto p = que.front();
    que.pop();
    for(auto &amp;to : g[p]) {
      if(v[to] == 0) {
        v[to] = 1;
        que.emplace(to);
        rg[p].emplace_back(to);
      }
    }
  }
  return rg;
}


##################################################
########### centroid-decomposition.cpp ###########
##################################################

template&lt; typename G &gt;
struct CentroidDecomposition {
  const G &amp;g;
  vector&lt; int &gt; sub;
  vector&lt; vector&lt; int &gt; &gt; belong;
  vector&lt; bool &gt; v;

  CentroidDecomposition(const G &amp;g) : g(g), sub(g.size()), v(g.size()), belong(g.size()) {}

  inline int build_dfs(int idx, int par) {
    sub[idx] = 1;
    for(auto &amp;to : g[idx]) {
      if(to == par || v[to]) continue;
      sub[idx] += build_dfs(to, idx);
    }
    return sub[idx];
  }

  inline int search_centroid(int idx, int par, const int mid) {
    for(auto &amp;to : g[idx]) {
      if(to == par || v[to]) continue;
      if(sub[to] &gt; mid) return search_centroid(to, idx, mid);
    }
    return idx;
  }

  inline void belong_dfs(int idx, int par, int centroid) {
    belong[idx].emplace_back(centroid);
    for(auto &amp;to : g[idx]) {
      if(to == par || v[to]) continue;
      belong_dfs(to, idx, centroid);
    }
  }

  inline int build(UnWeightedGraph &amp;t, int idx) {
    int centroid = search_centroid(idx, -1, build_dfs(idx, -1) / 2);
    v[centroid] = true;
    belong_dfs(centroid, -1, centroid);
    for(auto &amp;to : g[centroid]) {
      if(!v[to]) t[centroid].emplace_back(build(t, to));
    }
    v[centroid] = false;
    return centroid;
  }

  inline int build(UnWeightedGraph &amp;t) {
    t.resize(g.size());
    return build(t, 0);
  }
};


##################################################
################## centroid.cpp ##################
##################################################

template&lt; typename G &gt;
vector&lt; int &gt; centroid(const G &amp;g) {
  const int N = (int) g.size();

  stack&lt; pair&lt; int, int &gt; &gt; st;
  st.emplace(0, -1);
  vector&lt; int &gt; sz(N), par(N);
  while(!st.empty()) {
    auto p = st.top();
    if(sz[p.first] == 0) {
      sz[p.first] = 1;
      for(auto &amp;to : g[p.first]) if(to != p.second) st.emplace(to, p.first);
    } else {
      for(auto &amp;to : g[p.first]) if(to != p.second) sz[p.first] += sz[to];
      par[p.first] = p.second;
      st.pop();
    }
  }

  vector&lt; int &gt; ret;
  int size = N;
  for(int i = 0; i &lt; N; i++) {
    int val = N - sz[i];
    for(auto &amp;to : g[i]) if(to != par[i]) val = max(val, sz[to]);
    if(val &lt; size) size = val, ret.clear();
    if(val == size) ret.emplace_back(i);
  }

  return ret;
}


--------------------------------------------------
|                     graph                      |
--------------------------------------------------

##################################################
################## boruvka.cpp ###################
##################################################

template&lt; typename T, typename F &gt;
T boruvka(int N, F f) {
  vector&lt; int &gt; rev(N), belong(N);
  UnionFind uf(N);
  T ret = T();
  while(uf.size(0) != N) {
    int ptr = 0;
    for(int i = 0; i &lt; N; i++) {
      if(uf.find(i) == i) {
        belong[i] = ptr++;
        rev[belong[i]] = i;
      }
    }
    for(int i = 0; i &lt; N; i++) {
      belong[i] = belong[uf.find(i)];
    }
    auto v = f(ptr, belong);
    bool update = false;
    for(int i = 0; i &lt; ptr; i++) {
      if(~v[i].second &amp;&amp; uf.unite(rev[i], rev[v[i].second])) {
        ret += v[i].first;
        update = true;
      }
    }
    if(!update) return -1; // notice!!
  }
  return ret;
}


##################################################
################## dijkstra.cpp ##################
##################################################

template&lt; typename T &gt;
vector&lt; T &gt; dijkstra(WeightedGraph&lt; T &gt; &amp;g, int s) {
  const auto INF = numeric_limits&lt; T &gt;::max();
  vector&lt; T &gt; dist(g.size(), INF);

  using Pi = pair&lt; T, int &gt;;
  priority_queue&lt; Pi, vector&lt; Pi &gt;, greater&lt; Pi &gt; &gt; que;
  dist[s] = 0;
  que.emplace(dist[s], s);
  while(!que.empty()) {
    T cost;
    int idx;
    tie(cost, idx) = que.top();
    que.pop();
    if(dist[idx] &lt; cost) continue;
    for(auto &amp;e : g[idx]) {
      auto next_cost = cost + e.cost;
      if(dist[e.to] &lt;= next_cost) continue;
      dist[e.to] = next_cost;
      que.emplace(dist[e.to], e.to);
    }
  }
  return dist;
}


##################################################
################## template.cpp ##################
##################################################

template&lt; typename T &gt;
struct edge {
  int src, to;
  T cost;

  edge(int to, T cost) : src(-1), to(to), cost(cost) {}

  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}

  edge &amp;operator=(const int &amp;x) {
    to = x;
    return *this;
  }

  operator int() const { return to; }
};

template&lt; typename T &gt;
using Edges = vector&lt; edge&lt; T &gt; &gt;;
template&lt; typename T &gt;
using WeightedGraph = vector&lt; Edges&lt; T &gt; &gt;;
using UnWeightedGraph = vector&lt; vector&lt; int &gt; &gt;;
template&lt; typename T &gt;
using Matrix = vector&lt; vector&lt; T &gt; &gt;;


##################################################
############# bipartite-matching.cpp #############
##################################################

struct BipartiteMatching {
  vector&lt; vector&lt; int &gt; &gt; graph;
  vector&lt; int &gt; match, alive, used;
  int timestamp;

  BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}

  void add_edge(int u, int v) {
    graph[u].push_back(v);
    graph[v].push_back(u);
  }

  bool dfs(int idx) {
    used[idx] = timestamp;
    for(auto &amp;to : graph[idx]) {
      int to_match = match[to];
      if(alive[to] == 0) continue;
      if(to_match == -1 || (used[to_match] != timestamp &amp;&amp; dfs(to_match))) {
        match[idx] = to;
        match[to] = idx;
        return true;
      }
    }
    return false;
  }

  int bipartite_matching() {
    int ret = 0;
    for(int i = 0; i &lt; graph.size(); i++) {
      if(alive[i] == 0) continue;
      if(match[i] == -1) {
        ++timestamp;
        ret += dfs(i);
      }
    }
    return ret;
  }

  void output() {
    for(int i = 0; i &lt; graph.size(); i++) {
      if(i &lt; match[i]) {
        cout &lt;&lt; i &lt;&lt; &quot;-&quot; &lt;&lt; match[i] &lt;&lt; endl;
      }
    }
  }
};



##################################################
############### warshall-floyd.cpp ###############
##################################################

template&lt; typename T &gt;
void warshall_floyd(Matrix&lt; T &gt; &amp;g, T INF) {
  for(int k = 0; k &lt; g.size(); k++) {
    for(int i = 0; i &lt; g.size(); i++) {
      for(int j = 0; j &lt; g.size(); j++) {
        if(g[i][k] == INF || g[k][j] == INF) continue;
        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);
      }
    }
  }
}


##################################################
############### gabow-edmonds.cpp ################
##################################################

// https://qiita.com/Kutimoti_T/items/5b579773e0a24d650bdf
struct GabowEdmonds {

  struct edge {
    int to, idx;
  };

  vector&lt; vector&lt; edge &gt; &gt; g;
  vector&lt; pair&lt; int, int &gt; &gt; edges;
  vector&lt; int &gt; mate, label, first;
  queue&lt; int &gt; que;

  GabowEdmonds(int n) : g(n + 1), mate(n + 1), label(n + 1, -1), first(n + 1) {}

  void add_edge(int u, int v) {
    ++u, ++v;
    g[u].push_back((edge) {v, (int) (edges.size() + g.size())});
    g[v].push_back((edge) {u, (int) (edges.size() + g.size())});
    edges.emplace_back(u, v);
  }

  int find(int x) {
    if(label[first[x]] &lt; 0) return first[x];
    first[x] = find(first[x]);
    return first[x];
  }

  void rematch(int v, int w) {
    int t = mate[v];
    mate[v] = w;
    if(mate[t] != v) return;
    if(label[v] &lt; g.size()) {
      mate[t] = label[v];
      rematch(label[v], t);
    } else {
      int x = edges[label[v] - g.size()].first;
      int y = edges[label[v] - g.size()].second;
      rematch(x, y);
      rematch(y, x);
    }
  }

  void assign_label(int x, int y, int num) {
    int r = find(x);
    int s = find(y);
    int join = 0;
    if(r == s) return;
    label[r] = -num;
    label[s] = -num;
    while(true) {
      if(s != 0) swap(r, s);
      r = find(label[mate[r]]);
      if(label[r] == -num) {
        join = r;
        break;
      }
      label[r] = -num;
    }
    int v = first[x];
    while(v != join) {
      que.push(v);
      label[v] = num;
      first[v] = join;
      v = first[label[mate[v]]];
    }
    v = first[y];
    while(v != join) {
      que.push(v);
      label[v] = num;
      first[v] = join;
      v = first[label[mate[v]]];
    }
  }

  bool augment_check(int u) {
    que = queue&lt; int &gt;();
    first[u] = 0;
    label[u] = 0;
    que.push(u);
    while(!que.empty()) {
      int x = que.front();
      que.pop();
      for(auto e : g[x]) {
        int y = e.to;
        if(mate[y] == 0 &amp;&amp; y != u) {
          mate[y] = x;
          rematch(x, y);
          return true;
        } else if(label[y] &gt;= 0) {
          assign_label(x, y, e.idx);
        } else if(label[mate[y]] &lt; 0) {
          label[mate[y]] = x;
          first[mate[y]] = y;
          que.push(mate[y]);
        }
      }
    }
    return false;
  }

  vector&lt; pair&lt; int, int &gt; &gt; max_matching() {
    for(int i = 1; i &lt; g.size(); i++) {
      if(mate[i] != 0) continue;
      if(augment_check(i)) label.assign(g.size(), -1);
    }
    vector&lt; pair&lt; int, int &gt; &gt; ret;
    for(int i = 1; i &lt; g.size(); i++) {
      if(i &lt; mate[i]) ret.emplace_back(i - 1, mate[i] - 1);
    }
    return ret;
  }
};


##################################################
############ maxflow-lower-bound.cpp #############
##################################################

template&lt; typename flow_t, template&lt; typename &gt; class F &gt;
struct MaxFlowLowerBound {
  F&lt; flow_t &gt; flow;
  vector&lt; flow_t &gt; in, up;
  typename F&lt; flow_t &gt;::edge *latte, *malta;
  int X, Y, V;
  flow_t sum;

  MaxFlowLowerBound(int V) : V(V), flow(V + 2), X(V), Y(V + 1), sum(0), in(V) {}

  void add_edge(int from, int to, flow_t low, flow_t high) {
    assert(from != to);
    flow.add_edge(from, to, high - low, up.size());
    in[from] -= low;
    in[to] += low;
    up.emplace_back(high);
  }

  void build() {
    for(int i = 0; i &lt; V; i++) {
      if(in[i] &gt; 0) {
        flow.add_edge(X, i, in[i]);
        sum += in[i];
      } else if(in[i] &lt; 0) {
        flow.add_edge(i, Y, -in[i]);
      }
    }
  }

  bool can_flow(int s, int t) {
    assert(s != t);
    flow.add_edge(t, s, flow.INF);
    latte = &amp;flow.graph[t].back();
    malta = &amp;flow.graph[s].back();
    return can_flow();
  }

  bool can_flow() {
    build();
    auto ret = flow.max_flow(X, Y);
    return ret &gt;= sum;
  }

  flow_t max_flow(int s, int t) {
    if(can_flow(s, t)) {
      return flow.max_flow(s, t);
    } else {
      return -1;
    }
  }

  flow_t min_flow(int s, int t) {
    if(can_flow(s, t)) {
      auto ret = flow.INF - latte-&gt;cap;
      latte-&gt;cap = malta-&gt;cap = 0;
      return ret - flow.max_flow(t, s);
    } else {
      return -1;
    }
  }

  void output(int M) {
    vector&lt; flow_t &gt; ans(M);
    for(int i = 0; i &lt; flow.graph.size(); i++) {
      for(auto &amp;e : flow.graph[i]) {
        if(!e.isrev &amp;&amp; ~e.idx) ans[e.idx] = up[e.idx] - e.cap;
      }
    }
    for(auto &amp;p : ans) cout &lt;&lt; p &lt;&lt; endl;
  }
};


##################################################
################ primal-dual.cpp #################
##################################################

template&lt; typename flow_t, typename cost_t &gt;
struct PrimalDual {
  const cost_t INF;

  struct edge {
    int to;
    flow_t cap;
    cost_t cost;
    int rev;
    bool isrev;
  };
  vector&lt; vector&lt; edge &gt; &gt; graph;
  vector&lt; cost_t &gt; potential, min_cost;
  vector&lt; int &gt; prevv, preve;

  PrimalDual(int V) : graph(V), INF(numeric_limits&lt; cost_t &gt;::max()) {}

  void add_edge(int from, int to, flow_t cap, cost_t cost) {
    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});
    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});
  }

  cost_t min_cost_flow(int s, int t, flow_t f) {
    int V = (int) graph.size();
    cost_t ret = 0;
    using Pi = pair&lt; cost_t, int &gt;;
    priority_queue&lt; Pi, vector&lt; Pi &gt;, greater&lt; Pi &gt; &gt; que;
    potential.assign(V, 0);
    preve.assign(V, -1);
    prevv.assign(V, -1);

    while(f &gt; 0) {
      min_cost.assign(V, INF);
      que.emplace(0, s);
      min_cost[s] = 0;
      while(!que.empty()) {
        Pi p = que.top();
        que.pop();
        if(min_cost[p.second] &lt; p.first) continue;
        for(int i = 0; i &lt; graph[p.second].size(); i++) {
          edge &amp;e = graph[p.second][i];
          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];
          if(e.cap &gt; 0 &amp;&amp; min_cost[e.to] &gt; nextCost) {
            min_cost[e.to] = nextCost;
            prevv[e.to] = p.second, preve[e.to] = i;
            que.emplace(min_cost[e.to], e.to);
          }
        }
      }
      if(min_cost[t] == INF) return -1;
      for(int v = 0; v &lt; V; v++) potential[v] += min_cost[v];
      flow_t addflow = f;
      for(int v = t; v != s; v = prevv[v]) {
        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);
      }
      f -= addflow;
      ret += addflow * potential[t];
      for(int v = t; v != s; v = prevv[v]) {
        edge &amp;e = graph[prevv[v]][preve[v]];
        e.cap -= addflow;
        graph[v][e.rev].cap += addflow;
      }
    }
    return ret;
  }

  void output() {
    for(int i = 0; i &lt; graph.size(); i++) {
      for(auto &amp;e : graph[i]) {
        if(e.isrev) continue;
        auto &amp;rev_e = graph[e.to][e.rev];
        cout &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e.to &lt;&lt; &quot; (flow: &quot; &lt;&lt; rev_e.cap &lt;&lt; &quot;/&quot; &lt;&lt; rev_e.cap + e.cap &lt;&lt; &quot;)&quot; &lt;&lt; endl;
      }
    }
  }
};


##################################################
################ bellman-ford.cpp ################
##################################################

template&lt; typename T &gt;
vector&lt; T &gt; bellman_ford(Edges&lt; T &gt; &amp;edges, int V, int s) {
  const auto INF = numeric_limits&lt; T &gt;::max();
  vector&lt; T &gt; dist(V, INF);
  dist[s] = 0;
  for(int i = 0; i &lt; V - 1; i++) {
    for(auto &amp;e : edges) {
      if(dist[e.src] == INF) continue;
      dist[e.to] = min(dist[e.to], dist[e.src] + e.cost);
    }
  }
  for(auto &amp;e : edges) {
    if(dist[e.src] == INF) continue;
    if(dist[e.src] + e.cost &lt; dist[e.to]) return vector&lt; T &gt;();
  }
  return dist;
}



##################################################
################# hungarian.cpp ##################
##################################################

template&lt; typename T &gt;
T hungarian(Matrix&lt; T &gt; &amp;A) {
  const T infty = numeric_limits&lt; T &gt;::max();
  const int N = (int) A.size();
  const int M = (int) A[0].size();
  vector&lt; int &gt; P(M), way(M);
  vector&lt; T &gt; U(N, 0), V(M, 0), minV;
  vector&lt; bool &gt; used;

  for(int i = 1; i &lt; N; i++) {
    P[0] = i;
    minV.assign(M, infty);
    used.assign(M, false);
    int j0 = 0;
    while(P[j0] != 0) {
      int i0 = P[j0], j1 = 0;
      used[j0] = true;
      T delta = infty;
      for(int j = 1; j &lt; M; j++) {
        if(used[j]) continue;
        T curr = A[i0][j] - U[i0] - V[j];
        if(curr &lt; minV[j]) minV[j] = curr, way[j] = j0;
        if(minV[j] &lt; delta) delta = minV[j], j1 = j;
      }
      for(int j = 0; j &lt; M; j++) {
        if(used[j]) U[P[j]] += delta, V[j] -= delta;
        else minV[j] -= delta;
      }
      j0 = j1;
    }
    do {
      P[j0] = P[way[j0]];
      j0 = way[j0];
    } while(j0 != 0);
  }
  return -V[0];
}


##################################################
########## maximum-independent-set.cpp ###########
##################################################

template&lt; typename T &gt;
vector&lt; int &gt; maximum_independent_set(const Matrix&lt; T &gt; &amp;g, int trial = 1000000) {

  int N = (int) g.size();
  vector&lt; uint64_t &gt; bit(N);

  assert(N &lt;= 64);
  for(int i = 0; i &lt; N; i++) {
    for(int j = 0; j &lt; N; j++) {
      if(i != j) {
        assert(g[i][j] == g[j][i]);
        if(g[i][j]) bit[i] |= uint64_t(1) &lt;&lt; j;
      }
    }
  }

  vector&lt; int &gt; ord(N);
  iota(begin(ord), end(ord), 0);
  mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());
  int ret = 0;
  uint64_t ver;
  for(int i = 0; i &lt; trial; i++) {
    shuffle(begin(ord), end(ord), mt);
    uint64_t used = 0;
    int add = 0;
    for(int j : ord) {
      if(used &amp; bit[j]) continue;
      used |= uint64_t(1) &lt;&lt; j;
      ++add;
    }
    if(ret &lt; add) {
      ret = add;
      ver = used;
    }
  }
  vector&lt; int &gt; ans;
  for(int i = 0; i &lt; N; i++) {
    if((ver &gt;&gt; i) &amp; 1) ans.emplace_back(i);
  }
  return ans;
}


##################################################
################ push-relabel.cpp ################
##################################################

template&lt; typename flow_t &gt;
struct PushRelabel {
  const flow_t INF;

  struct edge {
    int to;
    flow_t cap;
    int rev;
    bool isrev;
    int idx;
  };
  vector&lt; vector&lt; edge &gt; &gt; graph;
  vector&lt; flow_t &gt; ex;
  int relabels, high;
  vector&lt; int &gt; cnt, h;
  vector&lt; vector&lt; int &gt; &gt; hs;

  PushRelabel(int V) : graph(V), INF(numeric_limits&lt; flow_t &gt;::max()), hs(V + 1), high(0) {}


  void add_edge(int from, int to, flow_t cap, int idx = -1) {
    graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false, idx});
    graph[to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1, true, idx});
  }

  void update_height(int idx, int nxt_height) {
    ++relabels;
    if(h[idx] != graph.size() + 1) {
      --cnt[h[idx]];
    }
    h[idx] = nxt_height;
    if(h[idx] != graph.size() + 1) {
      high = nxt_height;
      ++cnt[nxt_height];
      if(ex[idx] &gt; 0) hs[nxt_height].emplace_back(idx);
    }
  }

  void global_relabel(int idx) {
    for(int i = 0; i &lt;= high; i++) hs[i].clear();
    relabels = 0;
    high = 0;
    h.assign(graph.size(), graph.size() + 1);
    cnt.assign(graph.size(), 0);
    queue&lt; int &gt; que;
    que.emplace(idx);
    h[idx] = 0;
    while(que.size()) {
      int p = que.front();
      que.pop();
      for(auto &amp;e : graph[p]) {
        if(h[e.to] == graph.size() + 1 &amp;&amp; graph[e.to][e.rev].cap &gt; 0) {
          que.emplace(e.to);
          high = h[p] + 1;
          update_height(e.to, high);
        }
      }
    }
  }


  void push(int idx, edge &amp;e) {
    if(h[e.to] == graph.size() + 1) return;
    if(ex[e.to] == 0) {
      hs[h[e.to]].emplace_back(e.to);
    }
    flow_t df = min(ex[idx], e.cap);
    e.cap -= df;
    graph[e.to][e.rev].cap += df;
    ex[idx] -= df;
    ex[e.to] += df;
  }

  void discharge(int idx) {
    int next_height = (int) graph.size() + 1;
    for(auto &amp;&amp;e : graph[idx]) {
      if(e.cap &gt; 0) {
        if(h[idx] == h[e.to] + 1) {
          push(idx, e);
          if(ex[idx] &lt;= 0) return;
        } else {
          next_height = min(next_height, h[e.to] + 1);
        }
      }
    }
    if(cnt[h[idx]] &gt; 1) {
      update_height(idx, next_height);
    } else {
      for(; high &gt;= h[idx]; hs[high--].clear()) {
        for(int j : hs[high]) update_height(j, graph.size() + 1);
      }
    }
  }

  flow_t max_flow(int s, int t) {
    ex.assign(graph.size(), 0);
    ex[s] = INF;
    ex[t] = -INF;
    global_relabel(t);
    for(auto &amp;e : graph[s]) push(s, e);
    for(; high &gt;= 0; high--) {
      while(!hs[high].empty()) {
        int idx = hs[high].back();
        hs[high].pop_back();
        discharge(idx);
        if(relabels &gt;= graph.size() * 4) global_relabel(t);
      }
    }
    return ex[t] + INF;
  }

  void output() {
    for(int i = 0; i &lt; graph.size(); i++) {
      for(auto &amp;e : graph[i]) {
        if(e.isrev) continue;
        auto &amp;rev_e = graph[e.to][e.rev];
        cout &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e.to &lt;&lt; &quot; (flow: &quot; &lt;&lt; rev_e.cap &lt;&lt; &quot;/&quot; &lt;&lt; e.cap + rev_e.cap &lt;&lt; &quot;)&quot; &lt;&lt; endl;
      }
    }
  }
};


##################################################
################## kruskal.cpp ###################
##################################################

template&lt; typename T &gt;
T kruskal(Edges&lt; T &gt; &amp;edges, int V) {
  sort(begin(edges), end(edges), [](const edge&lt; T &gt; &amp;a, const edge&lt; T &gt; &amp;b) {
    return (a.cost &lt; b.cost);
  });
  UnionFind tree(V);
  T ret = 0;
  for(auto &amp;e : edges) {
    if(tree.unite(e.src, e.to)) ret += e.cost;
  }
  return (ret);
}


##################################################
############### ford-fulkerson.cpp ###############
##################################################

template&lt; typename flow_t &gt;
struct FordFulkerson {
  struct edge {
    int to;
    flow_t cap;
    int rev;
    bool isrev;
    int idx;
  };

  vector&lt; vector&lt; edge &gt; &gt; graph;
  vector&lt; int &gt; used;
  const flow_t INF;
  int timestamp;

  FordFulkerson(int n) : INF(numeric_limits&lt; flow_t &gt;::max()), timestamp(0) {
    graph.resize(n);
    used.assign(n, -1);
  }

  void add_edge(int from, int to, flow_t cap, int idx = -1) {
    graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false, idx});
    graph[to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1, true, idx});
  }

  flow_t dfs(int idx, const int t, flow_t flow) {
    if(idx == t) return flow;
    used[idx] = timestamp;
    for(auto &amp;e : graph[idx]) {
      if(e.cap &gt; 0 &amp;&amp; used[e.to] != timestamp) {
        flow_t d = dfs(e.to, t, min(flow, e.cap));
        if(d &gt; 0) {
          e.cap -= d;
          graph[e.to][e.rev].cap += d;
          return d;
        }
      }
    }
    return 0;
  }

  flow_t max_flow(int s, int t) {
    flow_t flow = 0;
    for(flow_t f; (f = dfs(s, t, INF)) &gt; 0; timestamp++) {
      flow += f;
    }
    return flow;
  }

  void output() {
    for(int i = 0; i &lt; graph.size(); i++) {
      for(auto &amp;e : graph[i]) {
        if(e.isrev) continue;
        auto &amp;rev_e = graph[e.to][e.rev];
        cout &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e.to &lt;&lt; &quot; (flow: &quot; &lt;&lt; rev_e.cap &lt;&lt; &quot;/&quot; &lt;&lt; e.cap + rev_e.cap &lt;&lt; &quot;)&quot; &lt;&lt; endl;
      }
    }
  }
};


##################################################
########## offline-dag-reachability.cpp ##########
##################################################

template&lt; typename G &gt;
vector&lt; int &gt; offline_dag_reachability(const G &amp;g, vector&lt; pair&lt; int, int &gt; &gt; &amp;qs) {
  const int N = (int) g.size();
  const int Q = (int) qs.size();
  auto ord = topological_sort(g);
  vector&lt; int &gt; ans(Q);
  for(int l = 0; l &lt; Q; l += 64) {
    int r = min(Q, l + 64);
    vector&lt; int64_t &gt; dp(N);
    for(int k = l; k &lt; r; k++) {
      dp[qs[k].first] |= int64_t(1) &lt;&lt; (k - l);
    }
    for(auto &amp;idx : ord) {
      for(auto &amp;to : g[idx]) dp[to] |= dp[idx];
    }
    for(int k = l; k &lt; r; k++) {
      ans[k] = (dp[qs[k].second] &gt;&gt; (k - l)) &amp; 1;
    }
  }
  return ans;
}


##################################################
############## chromatic-number.cpp ##############
##################################################

int chromatic_number(const Matrix&lt; bool &gt; &amp;g) {
  int N = (int) g.size();
  vector&lt; int &gt; es(N);
  for(int i = 0; i &lt; g.size(); i++) {
    for(int j = 0; j &lt; g.size(); j++) {
      es[i] |= g[i][j] &lt;&lt; j;
    }
  }
  int ret = N;
  for(int d : {7, 11, 21}) {
    int mod = 1e9 + d;
    vector&lt; int &gt; ind(1 &lt;&lt; N), aux(1 &lt;&lt; N, 1);
    ind[0] = 1;
    for(int S = 1; S &lt; 1 &lt;&lt; N; S++) {
      int u = __builtin_ctz(S);
      ind[S] = ind[S ^ (1 &lt;&lt; u)] + ind[(S ^ (1 &lt;&lt; u)) &amp; ~es[u]];
    }
    for(int i = 1; i &lt; ret; i++) {
      int64_t all = 0;
      for(int j = 0; j &lt; 1 &lt;&lt; N; j++) {
        int S = j ^(j &gt;&gt; 1);
        aux[S] = (1LL * aux[S] * ind[S]) % mod;
        all += j &amp; 1 ? aux[S] : mod - aux[S];
      }
      if(all % mod) ret = i;
    }
  }
  return ret;
}



##################################################
################## grid-bfs.cpp ##################
##################################################

vector&lt; vector&lt; int &gt; &gt; grid_bfs(vector&lt; string &gt; &amp;s, char start, const string &amp;wall = &quot;#&quot;) {
  const int vx[] = {0, 1, 0, -1}, vy[] = {1, 0, -1, 0};
  vector&lt; vector&lt; int &gt; &gt; min_cost(s.size(), vector&lt; int &gt;(s[0].size(), -1));
  queue&lt; pair&lt; int, int &gt; &gt; que;
  for(int i = 0; i &lt; s.size(); i++) {
    for(int j = 0; j &lt; s[i].size(); j++) {
      if(s[i][j] == start) {
        que.emplace(i, j);
        min_cost[i][j] = 0;
      }
    }
  }
  while(!que.empty()) {
    auto p = que.front();
    que.pop();
    for(int i = 0; i &lt; 4; i++) {
      int ny = p.first + vy[i], nx = p.second + vx[i];
      if(nx &lt; 0 || ny &lt; 0 || nx &gt;= s[0].size() || ny &gt;= s.size()) continue;
      if(min_cost[ny][nx] != -1) continue;
      if(wall.find(s[ny][nx]) != string::npos) continue;
      min_cost[ny][nx] = min_cost[p.first][p.second] + 1;
      que.emplace(ny, nx);
    }
  }
  return min_cost;
}


##################################################
####### two-edge-connected-components.cpp ########
##################################################

template&lt; typename G &gt;
struct TwoEdgeConnectedComponents : LowLink&lt; G &gt; {
  using LL = LowLink&lt; G &gt;;
  vector&lt; int &gt; comp;

  TwoEdgeConnectedComponents(const G &amp;g) : LL(g) {}

  int operator[](const int &amp;k) {
    return comp[k];
  }

  void dfs(int idx, int par, int &amp;k) {
    if(~par &amp;&amp; this-&gt;ord[par] &gt;= this-&gt;low[idx]) comp[idx] = comp[par];
    else comp[idx] = k++;
    for(auto &amp;to : this-&gt;g[idx]) {
      if(comp[to] == -1) dfs(to, idx, k);
    }
  }

  void build(UnWeightedGraph &amp;t) {
    LL::build();
    comp.assign(this-&gt;g.size(), -1);
    int k = 0;
    for(int i = 0; i &lt; comp.size(); i++) {
      if(comp[i] == -1) dfs(i, -1, k);
    }
    t.resize(k);
    for(auto &amp;e : this-&gt;bridge) {
      int x = comp[e.first], y = comp[e.second];
      t[x].push_back(y);
      t[y].push_back(x);
    }
  }
};


##################################################
########### dinic-capacity-scaling.cpp ###########
##################################################

template&lt; typename flow_t &gt;
struct DinicCapacityScaling {

  const flow_t INF;

  struct edge {
    int to;
    flow_t cap;
    int rev;
    bool isrev;
  };

  vector&lt; vector&lt; edge &gt; &gt; graph;
  vector&lt; int &gt; min_cost, iter;
  flow_t max_cap;

  DinicCapacityScaling(int V) : INF(numeric_limits&lt; flow_t &gt;::max()), graph(V), max_cap(0) {}

  void add_edge(int from, int to, flow_t cap) {
    max_cap = max(max_cap, cap);
    graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false});
    graph[to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1, true});
  }

  bool bfs(int s, int t, const flow_t &amp;base) {
    min_cost.assign(graph.size(), -1);
    queue&lt; int &gt; que;
    min_cost[s] = 0;
    que.push(s);
    while(!que.empty() &amp;&amp; min_cost[t] == -1) {
      int p = que.front();
      que.pop();
      for(auto &amp;e : graph[p]) {
        if(e.cap &gt;= base &amp;&amp; min_cost[e.to] == -1) {
          min_cost[e.to] = min_cost[p] + 1;
          que.push(e.to);
        }
      }
    }
    return min_cost[t] != -1;
  }

  flow_t dfs(int idx, const int t, const flow_t base, flow_t flow) {
    if(idx == t) return flow;
    flow_t sum = 0;
    for(int &amp;i = iter[idx]; i &lt; graph[idx].size(); i++) {
      edge &amp;e = graph[idx][i];
      if(e.cap &gt;= base &amp;&amp; min_cost[idx] &lt; min_cost[e.to]) {
        flow_t d = dfs(e.to, t, base, min(flow - sum, e.cap));
        if(d &gt; 0) {
          e.cap -= d;
          graph[e.to][e.rev].cap += d;
          sum += d;
          if(flow - sum &lt; base) break;
        }
      }
    }
    return sum;
  }

  flow_t max_flow(int s, int t) {
    if(max_cap == flow_t(0)) return flow_t(0);
    flow_t flow = 0;
    for(int i = 63 - __builtin_clzll(max_cap); i &gt;= 0; i--) {
      flow_t now = flow_t(1) &lt;&lt; i;
      while(bfs(s, t, now)) {
        iter.assign(graph.size(), 0);
        flow += dfs(s, t, now, INF);
      }
    }
    return flow;
  }

  void output() {
    for(int i = 0; i &lt; graph.size(); i++) {
      for(auto &amp;e : graph[i]) {
        if(e.isrev) continue;
        auto &amp;rev_e = graph[e.to][e.rev];
        cout &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e.to &lt;&lt; &quot; (flow: &quot; &lt;&lt; rev_e.cap &lt;&lt; &quot;/&quot; &lt;&lt; e.cap + rev_e.cap &lt;&lt; &quot;)&quot; &lt;&lt; endl;
      }
    }
  }
};



##################################################
########## bi-connected-components.cpp ###########
##################################################

template&lt; typename G &gt;
struct BiConnectedComponents : LowLink&lt; G &gt; {
  using LL = LowLink&lt; G &gt;;

  vector&lt; int &gt; used;
  vector&lt; vector&lt; pair&lt; int, int &gt; &gt; &gt; bc;
  vector&lt; pair&lt; int, int &gt; &gt; tmp;

  BiConnectedComponents(const G &amp;g) : LL(g) {}

  void dfs(int idx, int par) {
    used[idx] = true;
    for(auto &amp;to : this-&gt;g[idx]) {
      if(to == par) continue;
      if(!used[to] || this-&gt;ord[to] &lt; this-&gt;ord[idx]) {
        tmp.emplace_back(minmax(idx, to));
      }
      if(!used[to]) {
        dfs(to, idx);
        if(this-&gt;low[to] &gt;= this-&gt;ord[idx]) {
          bc.emplace_back();
          for(;;) {
            auto e = tmp.back();
            bc.back().emplace_back(e);
            tmp.pop_back();
            if(e.first == min(idx, to) &amp;&amp; e.second == max(idx, to)) {
              break;
            }
          }
        }
      }
    }
  }

  void build() override {
    LL::build();
    used.assign(this-&gt;g.size(), 0);
    for(int i = 0; i &lt; used.size(); i++) {
      if(!used[i]) dfs(i, -1);
    }
  }
};


##################################################
####### strongly-connected-components.cpp ########
##################################################

template&lt; typename G &gt;
struct StronglyConnectedComponents {
  const G &amp;g;
  UnWeightedGraph gg, rg;
  vector&lt; int &gt; comp, order, used;

  StronglyConnectedComponents(G &amp;g) : g(g), gg(g.size()), rg(g.size()), comp(g.size(), -1), used(g.size()) {
    for(int i = 0; i &lt; g.size(); i++) {
      for(auto e : g[i]) {
        gg[i].emplace_back((int) e);
        rg[(int) e].emplace_back(i);
      }
    }
  }

  int operator[](int k) {
    return comp[k];
  }

  void dfs(int idx) {
    if(used[idx]) return;
    used[idx] = true;
    for(int to : gg[idx]) dfs(to);
    order.push_back(idx);
  }

  void rdfs(int idx, int cnt) {
    if(comp[idx] != -1) return;
    comp[idx] = cnt;
    for(int to : rg[idx]) rdfs(to, cnt);
  }

  void build(UnWeightedGraph &amp;t) {
    for(int i = 0; i &lt; gg.size(); i++) dfs(i);
    reverse(begin(order), end(order));
    int ptr = 0;
    for(int i : order) if(comp[i] == -1) rdfs(i, ptr), ptr++;

    t.resize(ptr);
    for(int i = 0; i &lt; g.size(); i++) {
      for(auto &amp;to : g[i]) {
        int x = comp[i], y = comp[to];
        if(x == y) continue;
        t[x].push_back(y);
      }
    }
  }
};


##################################################
############### dominator-tree.cpp ###############
##################################################

template&lt; typename G &gt;
struct DominatorTree {

  struct UnionFind {
    const vector&lt; int &gt; &amp;semi;
    vector&lt; int &gt; par, m;

    UnionFind(const vector&lt; int &gt; &amp;semi) : semi(semi), par(semi.size()), m(semi.size()) {
      iota(begin(par), end(par), 0);
      iota(begin(m), end(m), 0);
    }

    int find(int v) {
      if(par[v] == v) return v;
      int r = find(par[v]);
      if(semi[m[v]] &gt; semi[m[par[v]]]) m[v] = m[par[v]];
      return par[v] = r;
    }

    int eval(int v) {
      find(v);
      return m[v];
    }

    void link(int p, int c) {
      par[c] = p;
    }
  };

  const G &amp;g;
  vector&lt; vector&lt; int &gt; &gt; rg;
  vector&lt; int &gt; ord, par;
  vector&lt; int &gt; idom, semi;
  UnionFind uf;

  DominatorTree(G &amp;g) : g(g), rg(g.size()), par(g.size()), idom(g.size(), -1), semi(g.size(), -1), uf(semi) {
    ord.reserve(g.size());
  }


  void dfs(int idx) {
    semi[idx] = (int) ord.size();
    ord.emplace_back(idx);
    for(auto &amp;to : g[idx]) {
      if(~semi[to]) continue;
      dfs(to);
      par[to] = idx;
    }
  }

  void build(int root) {
    const int N = (int) g.size();
    dfs(root);
    for(int i = 0; i &lt; N; i++) {
      for(auto &amp;to : g[i]) {
        if(~semi[i]) rg[to].emplace_back(i);
      }
    }

    vector&lt; vector&lt; int &gt; &gt; bucket(N);
    vector&lt; int &gt; U(N);
    for(int i = (int) ord.size() - 1; i &gt;= 0; i--) {
      int x = ord[i];
      for(int v : rg[x]) {
        v = uf.eval(v);
        if(semi[x] &gt; semi[v]) semi[x] = semi[v];
      }
      bucket[ord[semi[x]]].emplace_back(x);
      for(int v : bucket[par[x]]) U[v] = uf.eval(v);
      bucket[par[x]].clear();
      uf.link(par[x], x);
    }
    for(int i = 1; i &lt; ord.size(); i++) {
      int x = ord[i], u = U[x];
      idom[x] = semi[x] == semi[u] ? semi[x] : idom[u];
    }
    for(int i = 1; i &lt; ord.size(); i++) {
      int x = ord[i];
      idom[x] = ord[idom[x]];
    }
    idom[root] = root;
  }

  int operator[](const int &amp;k) {
    return idom[k];
  }
};


##################################################
#################### prim.cpp ####################
##################################################

template&lt; typename T &gt;
T prim(WeightedGraph&lt; T &gt; &amp;g) {
  using Pi = pair&lt; T, int &gt;;

  T total = 0;
  vector&lt; bool &gt; used(g.size(), false);
  priority_queue&lt; Pi, vector&lt; Pi &gt;, greater&lt; Pi &gt; &gt; que;
  que.emplace(0, 0);
  while(!que.empty()) {
    auto p = que.top();
    que.pop();
    if(used[p.second]) continue;
    used[p.second] = true;
    total += p.first;
    for(auto &amp;e : g[p.second]) {
      que.emplace(e.cost, e.to);
    }
  }
  return total;
}


##################################################
############### eulerian-trail.cpp ###############
##################################################

template&lt; typename T &gt;
vector&lt; edge&lt; T &gt; &gt; eulerian_path(Edges&lt; T &gt; es, int s, bool directed) {
  int V = 0;
  for(auto &amp;e : es) V = max(V, max(e.to, e.src) + 1);
  vector&lt; vector&lt; pair&lt; edge&lt; T &gt;, int &gt; &gt; &gt; g(V);
  for(auto &amp;e : es) {
    int sz_to = (int) g[e.to].size();
    g[e.src].emplace_back(e, sz_to);
    if(!directed) {
      int sz_src = (int) g[e.src].size() - 1;
      swap(e.src, e.to);
      g[e.src].emplace_back(e, sz_src);
    }
  }
  vector&lt; edge&lt; T &gt; &gt; ord;
  stack&lt; pair&lt; int, edge&lt; T &gt; &gt; &gt; st;
  st.emplace(s, edge&lt; T &gt;(-1, -1));
  while(st.size()) {
    int idx = st.top().first;
    if(g[idx].empty()) {
      ord.emplace_back(st.top().second);
      st.pop();
    } else {
      auto e = g[idx].back();
      g[idx].pop_back();
      if(e.second == -1) continue;
      if(!directed) g[e.first.to][e.second].second = -1;
      st.emplace(e.first.to, e.first);
    }
  }
  ord.pop_back();
  reverse(begin(ord), end(ord));
  if(ord.size() != es.size()) return {};
  return ord;
}


##################################################
################### dinic.cpp ####################
##################################################

template&lt; typename flow_t &gt;
struct Dinic {
  const flow_t INF;

  struct edge {
    int to;
    flow_t cap;
    int rev;
    bool isrev;
    int idx;
  };

  vector&lt; vector&lt; edge &gt; &gt; graph;
  vector&lt; int &gt; min_cost, iter;

  Dinic(int V) : INF(numeric_limits&lt; flow_t &gt;::max()), graph(V) {}

  void add_edge(int from, int to, flow_t cap, int idx = -1) {
    graph[from].emplace_back((edge) {to, cap, (int) graph[to].size(), false, idx});
    graph[to].emplace_back((edge) {from, 0, (int) graph[from].size() - 1, true, idx});
  }

  bool bfs(int s, int t) {
    min_cost.assign(graph.size(), -1);
    queue&lt; int &gt; que;
    min_cost[s] = 0;
    que.push(s);
    while(!que.empty() &amp;&amp; min_cost[t] == -1) {
      int p = que.front();
      que.pop();
      for(auto &amp;e : graph[p]) {
        if(e.cap &gt; 0 &amp;&amp; min_cost[e.to] == -1) {
          min_cost[e.to] = min_cost[p] + 1;
          que.push(e.to);
        }
      }
    }
    return min_cost[t] != -1;
  }

  flow_t dfs(int idx, const int t, flow_t flow) {
    if(idx == t) return flow;
    for(int &amp;i = iter[idx]; i &lt; graph[idx].size(); i++) {
      edge &amp;e = graph[idx][i];
      if(e.cap &gt; 0 &amp;&amp; min_cost[idx] &lt; min_cost[e.to]) {
        flow_t d = dfs(e.to, t, min(flow, e.cap));
        if(d &gt; 0) {
          e.cap -= d;
          graph[e.to][e.rev].cap += d;
          return d;
        }
      }
    }
    return 0;
  }

  flow_t max_flow(int s, int t) {
    flow_t flow = 0;
    while(bfs(s, t)) {
      iter.assign(graph.size(), 0);
      flow_t f = 0;
      while((f = dfs(s, t, INF)) &gt; 0) flow += f;
    }
    return flow;
  }

  void output() {
    for(int i = 0; i &lt; graph.size(); i++) {
      for(auto &amp;e : graph[i]) {
        if(e.isrev) continue;
        auto &amp;rev_e = graph[e.to][e.rev];
        cout &lt;&lt; i &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e.to &lt;&lt; &quot; (flow: &quot; &lt;&lt; rev_e.cap &lt;&lt; &quot;/&quot; &lt;&lt; e.cap + rev_e.cap &lt;&lt; &quot;)&quot; &lt;&lt; endl;
      }
    }
  }
};


##################################################
############## topological-sort.cpp ##############
##################################################

template&lt; typename G &gt;
vector&lt; int &gt; topological_sort(const G &amp;g) {
  const int N = (int) g.size();
  vector&lt; int &gt; deg(N);
  for(int i = 0; i &lt; N; i++) {
    for(auto &amp;to : g[i]) ++deg[to];
  }
  stack&lt; int &gt; st;
  for(int i = 0; i &lt; N; i++) {
    if(deg[i] == 0) st.emplace(i);
  }
  vector&lt; int &gt; ord;
  while(!st.empty()) {
    auto p = st.top();
    st.pop();
    ord.emplace_back(p);
    for(auto &amp;to : g[p]) {
      if(--deg[to] == 0) st.emplace(to);
    }
  }
  return ord;
}


##################################################
############### chu-liu-edmond.cpp ###############
##################################################

template&lt; typename T &gt;
struct MinimumSpanningTreeArborescence
{
  using Pi = pair&lt; T, int &gt;;
  using Heap = SkewHeap&lt; Pi, int &gt;;
  using Node = typename Heap::Node;
  const Edges&lt; T &gt; &amp;es;
  const int V;
  T INF;

  MinimumSpanningTreeArborescence(const Edges&lt; T &gt; &amp;es, int V) :
      INF(numeric_limits&lt; T &gt;::max()), es(es), V(V) {}

  T build(int start)
  {
    auto g = [](const Pi &amp;a, const T &amp;b) { return Pi(a.first + b, a.second); };
    auto h = [](const T &amp;a, const T &amp;b) { return a + b; };
    Heap heap(g, h);
    vector&lt; Node * &gt; heaps(V, heap.makeheap());
    for(auto &amp;e : es) heap.push(heaps[e.to], {e.cost, e.src});
    UnionFind uf(V);
    vector&lt; int &gt; used(V, -1);
    used[start] = start;

    T ret = 0;
    for(int s = 0; s &lt; V; s++) {
      stack&lt; int &gt; path;
      for(int u = s; used[u] &lt; 0;) {
        path.push(u);
        used[u] = s;
        if(heap.empty(heaps[u])) return -1;
        auto p = heap.top(heaps[u]);
        ret += p.first;
        heap.add(heaps[u], -p.first);
        heap.pop(heaps[u]);
        int v = uf.find(p.second);
        if(used[v] == s) {
          int w;
          Node *nextheap = heap.makeheap();
          do {
            w = path.top();
            path.pop();
            nextheap = heap.merge(nextheap, heaps[w]);
          } while(uf.unite(v, w));
          heaps[uf.find(v)] = nextheap;
          used[uf.find(v)] = -1;
        }
        u = uf.find(v);
      }
    }
    return ret;
  }
};


##################################################
####### shortest-path-faster-algorithm.cpp #######
##################################################

template&lt; typename T &gt;
vector&lt; T &gt; shortest_path_faster_algorithm(WeightedGraph&lt; T &gt; &amp;g, int s) {
  const auto INF = numeric_limits&lt; T &gt;::max();
  vector&lt; T &gt; dist(g.size(), INF);
  vector&lt; int &gt; pending(g.size(), 0), times(g.size(), 0);
  queue&lt; int &gt; que;

  que.emplace(s);
  pending[s] = true;
  ++times[s];
  dist[s] = 0;

  while(!que.empty()) {
    int p = que.front();
    que.pop();
    pending[p] = false;
    for(auto &amp;e : g[p]) {
      T next_cost = dist[p] + e.cost;
      if(next_cost &gt;= dist[e.to]) continue;
      dist[e.to] = next_cost;
      if(!pending[e.to]) {
        if(++times[e.to] &gt;= g.size()) return vector&lt; T &gt;();
        pending[e.to] = true;
        que.emplace(e.to);
      }
    }
  }
  return dist;
}


##################################################
############### hopcroft-karp.cpp ################
##################################################

struct HopcroftKarp {
  vector&lt; vector&lt; int &gt; &gt; graph;
  vector&lt; int &gt; dist, match;
  vector&lt; bool &gt; used, vv;

  HopcroftKarp(int n, int m) : graph(n), match(m, -1), used(n) {}

  void add_edge(int u, int v) {
    graph[u].push_back(v);
  }

  void bfs() {
    dist.assign(graph.size(), -1);
    queue&lt; int &gt; que;
    for(int i = 0; i &lt; graph.size(); i++) {
      if(!used[i]) {
        que.emplace(i);
        dist[i] = 0;
      }
    }

    while(!que.empty()) {
      int a = que.front();
      que.pop();
      for(auto &amp;b : graph[a]) {
        int c = match[b];
        if(c &gt;= 0 &amp;&amp; dist[c] == -1) {
          dist[c] = dist[a] + 1;
          que.emplace(c);
        }
      }
    }
  }

  bool dfs(int a) {
    vv[a] = true;
    for(auto &amp;b : graph[a]) {
      int c = match[b];
      if(c &lt; 0 || (!vv[c] &amp;&amp; dist[c] == dist[a] + 1 &amp;&amp; dfs(c))) {
        match[b] = a;
        used[a] = true;
        return (true);
      }
    }
    return (false);
  }

  int bipartite_matching() {
    int ret = 0;
    while(true) {
      bfs();
      vv.assign(graph.size(), false);
      int flow = 0;
      for(int i = 0; i &lt; graph.size(); i++) {
        if(!used[i] &amp;&amp; dfs(i)) ++flow;
      }
      if(flow == 0) return (ret);
      ret += flow;
    }
  }

  void output() {
    for(int i = 0; i &lt; match.size(); i++) {
      if(~match[i]) {
        cout &lt;&lt; match[i] &lt;&lt; &quot;-&quot; &lt;&lt; i &lt;&lt; endl;
      }
    }
  }
};


##################################################
################## lowlink.cpp ###################
##################################################

template&lt; typename G &gt;
struct LowLink {
  const G &amp;g;
  vector&lt; int &gt; used, ord, low;
  vector&lt; int &gt; articulation;
  vector&lt; pair&lt; int, int &gt; &gt; bridge;

  LowLink(const G &amp;g) : g(g) {}

  int dfs(int idx, int k, int par) {
    used[idx] = true;
    ord[idx] = k++;
    low[idx] = ord[idx];
    bool is_articulation = false;
    int cnt = 0;
    for(auto &amp;to : g[idx]) {
      if(!used[to]) {
        ++cnt;
        k = dfs(to, k, idx);
        low[idx] = min(low[idx], low[to]);
        is_articulation |= ~par &amp;&amp; low[to] &gt;= ord[idx];
        if(ord[idx] &lt; low[to]) bridge.emplace_back(minmax(idx, (int) to));
      } else if(to != par) {
        low[idx] = min(low[idx], ord[to]);
      }
    }
    is_articulation |= par == -1 &amp;&amp; cnt &gt; 1;
    if(is_articulation) articulation.push_back(idx);
    return k;
  }

  virtual void build() {
    used.assign(g.size(), 0);
    ord.assign(g.size(), 0);
    low.assign(g.size(), 0);
    int k = 0;
    for(int i = 0; i &lt; g.size(); i++) {
      if(!used[i]) k = dfs(i, k, -1);
    }
  }
};


##################################################
############### maximum-clique.cpp ###############
##################################################

template&lt; typename T &gt;
T maximum_clique(Matrix&lt; bool &gt; g, function&lt; T(vector&lt; int &gt;) &gt; f) {

  int N = (int) g.size(), M = 0;
  vector&lt; int &gt; deg(N), v(N);
  for(int i = 0; i &lt; N; i++) {
    for(int j = 0; j &lt; i; j++) {
      assert(g[i][j] == g[j][i]);
      if(g[i][j]) {
        ++deg[i];
        ++M;
      }
    }
  }
  T t = 0;
  int lim = (int) sqrt(2 * M);

  for(int i = 0; i &lt; N; i++) {
    vector&lt; int &gt; notice;
    for(int j = 0; j &lt; N; j++) {
      if(!v[j] &amp;&amp; deg[j] &lt; lim) {
        for(int k = 0; k &lt; N; k++) {
          if(j == k) continue;
          if(g[j][k]) notice.emplace_back(k);
        }
        notice.emplace_back(j);
        break;
      }
    }
    if(notice.empty()) break;
    int neighbor = (int) notice.size() - 1;
    vector&lt; int &gt; bit(neighbor);
    for(int j = 0; j &lt; neighbor; j++) {
      for(int k = 0; k &lt; j; k++) {
        if(!g[notice[j]][notice[k]]) {
          bit[j] |= 1 &lt;&lt; k;
          bit[k] |= 1 &lt;&lt; j;
        }
      }
    }
    for(int j = 0; j &lt; (1 &lt;&lt; neighbor); j++) {
      bool ok = true;
      for(int k = 0; k &lt; neighbor; k++) {
        if((j &gt;&gt; k) &amp; 1) ok &amp;= (j &amp; bit[k]) == 0;
      }
      if(ok) {
        vector&lt; int &gt; stock{notice.back()};
        for(int k = 0; k &lt; neighbor; k++) {
          if((j &gt;&gt; k) &amp; 1) stock.emplace_back(notice[k]);
        }
        t = max(t, f(stock));
      }
    }
    v[notice.back()] = true;
    for(int j = 0; j &lt; N; j++) {
      if(g[j][notice.back()]) {
        --deg[j];
        g[notice.back()][j] = g[j][notice.back()] = false;
      }
    }
  }

  vector&lt; int &gt; notice;
  for(int j = 0; j &lt; N; j++) {
    if(!v[j]) notice.emplace_back(j);
  }
  int neighbor = (int) notice.size();
  vector&lt; int &gt; bit(neighbor);
  for(int j = 0; j &lt; neighbor; j++) {
    for(int k = 0; k &lt; j; k++) {
      if(!g[notice[j]][notice[k]]) {
        bit[j] |= 1 &lt;&lt; k;
        bit[k] |= 1 &lt;&lt; j;
      }
    }
  }
  for(int j = 0; j &lt; (1 &lt;&lt; neighbor); j++) {
    bool ok = true;
    for(int k = 0; k &lt; neighbor; k++) {
      if((j &gt;&gt; k) &amp; 1) ok &amp;= (j &amp; bit[k]) == 0;
    }
    if(ok) {
      vector&lt; int &gt; stock;
      for(int k = 0; k &lt; neighbor; k++) {
        if((j &gt;&gt; k) &amp; 1) stock.emplace_back(notice[k]);
      }
      t = max(t, f(stock));
    }
  }
  return t;
}



--------------------------------------------------
|                     other                      |
--------------------------------------------------

##################################################
##################### mo.cpp #####################
##################################################

struct Mo {
  using ADD = function&lt; void(int) &gt;;
  using DEL = function&lt; void(int) &gt;;
  using REM = function&lt; void(int) &gt;;

  int width;
  vector&lt; int &gt; left, right, order;
  vector&lt; bool &gt; v;

  Mo(int N, int Q) : width((int) sqrt(N)), order(Q), v(N) {
    iota(begin(order), end(order), 0);
  }

  void add(int l, int r) { /* [l, r) */
    left.emplace_back(l);
    right.emplace_back(r);
  }

  int run(const ADD &amp;add, const DEL &amp;del, const REM &amp;rem) {
    assert(left.size() == order.size());
    sort(begin(order), end(order), [&amp;](int a, int b) {
      int ablock = left[a] / width, bblock = left[b] / width;
      if(ablock != bblock) return ablock &lt; bblock;
      if(ablock &amp; 1) return right[a] &lt; right[b];
      return right[a] &gt; right[b];
    });
    int nl = 0, nr = 0;
    auto push = [&amp;](int idx) {
      v[idx].flip();
      if(v[idx]) add(idx);
      else del(idx);
    };
    for(auto idx : order) {
      while(nl &gt; left[idx]) push(--nl);
      while(nr &lt; right[idx]) push(nr++);
      while(nl &lt; left[idx]) push(nl++);
      while(nr &gt; right[idx]) push(--nr);
      rem(idx);
    }
  }
};


##################################################
#################### dice.cpp ####################
##################################################

struct Dice
{
  // int x, y;
  int l, r, f, b, d, u;

  void RollN()
  {
    //  --y;
    int buff = d;
    d = f;
    f = u;
    u = b;
    b = buff;
  }

  void RollS()
  {
    // ++y;
    int buff = d;
    d = b;
    b = u;
    u = f;
    f = buff;
  }

  void RollL() // -----&gt;
  {
    int buff = f;
    f = l;
    l = b;
    b = r;
    r = buff;
  }

  void RollR() // &lt;------
  {
    int buff = f;
    f = r;
    r = b;
    b = l;
    l = buff;
  }

  void RollE() // .o -&gt; o.
  {
    // --x;
    int buff = d;
    d = l;
    l = u;
    u = r;
    r = buff;
  }


  void RollW() // o. -&gt; .o
  {
    //  ++x;
    int buff = d;
    d = r;
    r = u;
    u = l;
    l = buff;
  }


  vector&lt; Dice &gt; makeDice()
  {
    vector&lt; Dice &gt; ret;
    for(int i = 0; i &lt; 6; i++) {
      Dice d(*this);
      if(i == 1) d.RollN();
      if(i == 2) d.RollS();
      if(i == 3) d.RollS(), d.RollS();
      if(i == 4) d.RollL();
      if(i == 5) d.RollR();
      for(int j = 0; j &lt; 4; j++) {
        ret.emplace_back(d);
        d.RollE();
      }
    }
    return (ret);
  }
};


##################################################
################### timer.cpp ####################
##################################################

struct Timer {
  chrono::high_resolution_clock::time_point st;

  Timer() { reset(); }

  void reset() {
    st = chrono::high_resolution_clock::now();
  }

  chrono::milliseconds::rep elapsed() {
    auto ed = chrono::high_resolution_clock::now();
    return chrono::duration_cast&lt; chrono::milliseconds &gt;(ed - st).count();
  }
};


##################################################
################# fast-input.cpp #################
##################################################

template&lt; int sz &gt;
struct FastInput {
  char buf[sz + 1];
  char *o;

  FastInput() { init(); }

  void init() {
    o = buf;
    buf[fread(buf, sizeof(char), sizeof(char) * sz, stdin)] = '\0';
  }

  int64_t read() {
    int64_t ret = 0, sign = 1;
    while(*o &amp;&amp; *o &lt;= 32) ++o;
    if(*o == '-') sign *= -1, ++o;
    while(*o &gt;= '0' &amp;&amp; *o &lt;= '9') {
      ret *= 10;
      ret += *o++ - '0';
    }
    return ret * sign;
  }
};


##################################################
######## offline-dynamic-connectivity.cpp ########
##################################################

struct OfflineDynamicConnectivity {
  using edge = pair&lt; int, int &gt;;

  UnionFindUndo uf;
  int V, Q, segsz;
  vector&lt; vector&lt; edge &gt; &gt; seg;
  int comp;

  vector&lt; pair&lt; pair&lt; int, int &gt;, edge &gt; &gt; pend;
  map&lt; edge, int &gt; cnt, appear;

  OfflineDynamicConnectivity(int V, int Q) : uf(V), V(V), Q(Q), comp(V) {
    segsz = 1;
    while(segsz &lt; Q) segsz &lt;&lt;= 1;
    seg.resize(2 * segsz - 1);
  }

  void insert(int idx, int s, int t) {
    auto e = minmax(s, t);
    if(cnt[e]++ == 0) appear[e] = idx;
  }

  void erase(int idx, int s, int t) {
    auto e = minmax(s, t);
    if(--cnt[e] == 0) pend.emplace_back(make_pair(appear[e], idx), e);
  }

  void add(int a, int b, const edge &amp;e, int k, int l, int r) {
    if(r &lt;= a || b &lt;= l) return;
    if(a &lt;= l &amp;&amp; r &lt;= b) {
      seg[k].emplace_back(e);
      return;
    }
    add(a, b, e, 2 * k + 1, l, (l + r) &gt;&gt; 1);
    add(a, b, e, 2 * k + 2, (l + r) &gt;&gt; 1, r);
  }

  void add(int a, int b, const edge &amp;e) {
    add(a, b, e, 0, 0, segsz);
  }

  void build() {
    for(auto &amp;p : cnt) {
      if(p.second &gt; 0) pend.emplace_back(make_pair(appear[p.first], Q), p.first);
    }
    for(auto &amp;s : pend) {
      add(s.first.first, s.first.second, s.second);
    }
  }

  int run(const function&lt; void(int) &gt; &amp;f, int k = 0) {
    int add = 0;
    for(auto &amp;e : seg[k]) {
      add += uf.unite(e.first, e.second);
    }
    comp -= add;
    if(k &lt; segsz - 1) {
      run(f, 2 * k + 1);
      run(f, 2 * k + 2);
    } else if(k - (segsz - 1) &lt; Q) {
      int query_index = k - (segsz - 1);
      f(query_index);
    }
    for(auto &amp;e : seg[k]) {
      uf.undo();
    }
    comp += add;
  }
};


##################################################
########## random-number-generator.cpp ###########
##################################################

struct RandomNumberGenerator {
  mt19937 mt;

  RandomNumberGenerator() : mt(chrono::steady_clock::now().time_since_epoch().count()) {}

  int operator()(int a, int b) { // [a, b)
    uniform_int_distribution&lt; int &gt; dist(a, b - 1);
    return dist(mt);
  }

  int operator()(int b) { // [0, b)
    return (*this)(0, b);
  }
};


##################################################
################ mo-rollback.cpp #################
##################################################

struct MoRollBack {
  using ADD = function&lt; void(int) &gt;;
  using REM = function&lt; void(int) &gt;;
  using RESET = function&lt; void() &gt;;
  using SNAPSHOT = function&lt; void() &gt;;
  using ROLLBACK = function&lt; void() &gt;;

  int width;
  vector&lt; int &gt; left, right, order;

  MoRollBack(int N, int Q) : width((int) sqrt(N)), order(Q) {
    iota(begin(order), end(order), 0);
  }

  void add(int l, int r) { /* [l, r) */
    left.emplace_back(l);
    right.emplace_back(r);
  }

  int run(const ADD &amp;add, const REM &amp;rem, const RESET &amp;reset, const SNAPSHOT &amp;snapshot, const ROLLBACK &amp;rollback) {
    assert(left.size() == order.size());
    sort(begin(order), end(order), [&amp;](int a, int b) {
      int ablock = left[a] / width, bblock = left[b] / width;
      if(ablock != bblock) return ablock &lt; bblock;
      return right[a] &lt; right[b];
    });
    reset();
    for(auto idx : order) {
      if(right[idx] - left[idx] &lt; width) {
        for(int i = left[idx]; i &lt; right[idx]; i++) add(i);
        rem(idx);
        rollback();
      }
    }
    int nr = 0, last_block = -1;
    for(auto idx : order) {
      if(right[idx] - left[idx] &lt; width) continue;
      int block = left[idx] / width;
      if(last_block != block) {
        reset();
        last_block = block;
        nr = (block + 1) * width;
      }
      while(nr &lt; right[idx]) add(nr++);
      snapshot();
      for(int j = (block + 1) * width - 1; j &gt;= left[idx]; j--) add(j);
      rem(idx);
      rollback();
    }
  }
};



##################################################
################## compress.cpp ##################
##################################################

template&lt; typename T &gt;
struct Compress {
  vector&lt; T &gt; xs;

  Compress() = default;

  Compress(const vector&lt; T &gt; &amp;vs) {
    add(vs);
  }

  Compress(const initializer_list&lt; vector&lt; T &gt; &gt; &amp;vs) {
    for(auto &amp;p : vs) add(p);
  }

  void add(const vector&lt; T &gt; &amp;vs) {
    copy(begin(vs), end(vs), back_inserter(xs));
  }

  void add(const T &amp;x) {
    xs.emplace_back(x);
  }

  void build() {
    sort(begin(xs), end(xs));
    xs.erase(unique(begin(xs), end(xs)), end(xs));
  }

  vector&lt; int &gt; get(const vector&lt; T &gt; &amp;vs) const {
    vector&lt; int &gt; ret;
    transform(begin(vs), end(vs), back_inserter(ret), [&amp;](const T &amp;x) {
      return lower_bound(begin(xs), end(xs), x) - begin(xs);
    });
    return ret;
  }

  int get(const T &amp;x) const {
    return lower_bound(begin(xs), end(xs), x) - begin(xs);
  }

  const T &amp;operator[](int k) const {
    return xs[k];
  }
};


--------------------------------------------------
|                    template                    |
--------------------------------------------------

##################################################
################## template.cpp ##################
##################################################

#include&lt;bits/stdc++.h&gt;

using namespace std;

using int64 = long long;
const int mod = 1e9 + 7;

const int64 infll = (1LL &lt;&lt; 62) - 1;
const int inf = (1 &lt;&lt; 30) - 1;

struct IoSetup {
  IoSetup() {
    cin.tie(nullptr);
    ios::sync_with_stdio(false);
    cout &lt;&lt; fixed &lt;&lt; setprecision(10);
    cerr &lt;&lt; fixed &lt;&lt; setprecision(10);
  }
} iosetup;


template&lt; typename T1, typename T2 &gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, const pair&lt; T1, T2 &gt;&amp; p) {
  os &lt;&lt; p.first &lt;&lt; &quot; &quot; &lt;&lt; p.second;
  return os;
}

template&lt; typename T1, typename T2 &gt;
istream &amp;operator&gt;&gt;(istream &amp;is, pair&lt; T1, T2 &gt; &amp;p) {
  is &gt;&gt; p.first &gt;&gt; p.second;
  return is;
}

template&lt; typename T &gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, const vector&lt; T &gt; &amp;v) {
  for(int i = 0; i &lt; (int) v.size(); i++) {
    os &lt;&lt; v[i] &lt;&lt; (i + 1 != v.size() ? &quot; &quot; : &quot;&quot;);
  }
  return os;
}

template&lt; typename T &gt;
istream &amp;operator&gt;&gt;(istream &amp;is, vector&lt; T &gt; &amp;v) {
  for(T &amp;in : v) is &gt;&gt; in;
  return is;
}

template&lt; typename T1, typename T2 &gt;
inline bool chmax(T1 &amp;a, T2 b) { return a &lt; b &amp;&amp; (a = b, true); }

template&lt; typename T1, typename T2 &gt;
inline bool chmin(T1 &amp;a, T2 b) { return a &gt; b &amp;&amp; (a = b, true); }

template&lt; typename T = int64 &gt;
vector&lt; T &gt; make_v(size_t a) {
  return vector&lt; T &gt;(a);
}

template&lt; typename T, typename... Ts &gt;
auto make_v(size_t a, Ts... ts) {
  return vector&lt; decltype(make_v&lt; T &gt;(ts...)) &gt;(a, make_v&lt; T &gt;(ts...));
}

template&lt; typename T, typename V &gt;
typename enable_if&lt; is_class&lt; T &gt;::value == 0 &gt;::type fill_v(T &amp;t, const V &amp;v) {
  t = v;
}

template&lt; typename T, typename V &gt;
typename enable_if&lt; is_class&lt; T &gt;::value != 0 &gt;::type fill_v(T &amp;t, const V &amp;v) {
  for(auto &amp;e : t) fill_v(e, v);
}

template&lt; typename F &gt;
struct FixPoint : F {
  FixPoint(F &amp;&amp;f) : F(forward&lt; F &gt;(f)) {}

  template&lt; typename... Args &gt;
  decltype(auto) operator()(Args &amp;&amp;... args) const {
    return F::operator()(*this, forward&lt; Args &gt;(args)...);
  }
};

template&lt; typename F &gt;
inline decltype(auto) MFP(F &amp;&amp;f) {
  return FixPoint&lt; F &gt;{forward&lt; F &gt;(f)};
}


--------------------------------------------------
|                      math                      |
--------------------------------------------------

##################################################
################ prime-factor.cpp ################
##################################################

map&lt; int64_t, int &gt; prime_factor(int64_t n) {
  map&lt; int64_t, int &gt; ret;
  for(int64_t i = 2; i * i &lt;= n; i++) {
    while(n % i == 0) {
      ret[i]++;
      n /= i;
    }
  }
  if(n != 1) ret[n] = 1;
  return ret;
}


##################################################
########### stirling-number-second.cpp ###########
##################################################

template&lt; typename T &gt;
T stirling_number_second(int n, int k) {
  Combination&lt; T &gt; table(k);
  T ret = 0;
  for(int i = 0; i &lt;= k; i++) {
    auto add = T(i).pow(n) * table.C(k, i);
    if((k - i) &amp; 1) ret -= add;
    else ret += add;
  }
  return ret * table.rfact(k);
}



##################################################
################## mod-int.cpp ###################
##################################################

template&lt; int mod &gt;
struct ModInt {
  int x;

  ModInt() : x(0) {}

  ModInt(int64_t y) : x(y &gt;= 0 ? y % mod : (mod - (-y) % mod) % mod) {}

  ModInt &amp;operator+=(const ModInt &amp;p) {
    if((x += p.x) &gt;= mod) x -= mod;
    return *this;
  }

  ModInt &amp;operator-=(const ModInt &amp;p) {
    if((x += mod - p.x) &gt;= mod) x -= mod;
    return *this;
  }

  ModInt &amp;operator*=(const ModInt &amp;p) {
    x = (int) (1LL * x * p.x % mod);
    return *this;
  }

  ModInt &amp;operator/=(const ModInt &amp;p) {
    *this *= p.inverse();
    return *this;
  }

  ModInt operator-() const { return ModInt(-x); }

  ModInt operator+(const ModInt &amp;p) const { return ModInt(*this) += p; }

  ModInt operator-(const ModInt &amp;p) const { return ModInt(*this) -= p; }

  ModInt operator*(const ModInt &amp;p) const { return ModInt(*this) *= p; }

  ModInt operator/(const ModInt &amp;p) const { return ModInt(*this) /= p; }

  bool operator==(const ModInt &amp;p) const { return x == p.x; }

  bool operator!=(const ModInt &amp;p) const { return x != p.x; }

  ModInt inverse() const {
    int a = x, b = mod, u = 1, v = 0, t;
    while(b &gt; 0) {
      t = a / b;
      swap(a -= t * b, b);
      swap(u -= t * v, v);
    }
    return ModInt(u);
  }

  ModInt pow(int64_t n) const {
    ModInt ret(1), mul(x);
    while(n &gt; 0) {
      if(n &amp; 1) ret *= mul;
      mul *= mul;
      n &gt;&gt;= 1;
    }
    return ret;
  }

  friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const ModInt &amp;p) {
    return os &lt;&lt; p.x;
  }

  friend istream &amp;operator&gt;&gt;(istream &amp;is, ModInt &amp;a) {
    int64_t t;
    is &gt;&gt; t;
    a = ModInt&lt; mod &gt;(t);
    return (is);
  }

  static int get_mod() { return mod; }
};

using modint = ModInt&lt; mod &gt;;


##################################################
################## binomial.cpp ##################
##################################################

template&lt; typename T &gt;
T binomial(int64_t N, int64_t K) {
  if(K &lt; 0 || N &lt; K) return 0;
  T ret = 1;
  for(T i = 1; i &lt;= K; ++i) {
    ret *= N--;
    ret /= i;
  }
  return ret;
}


##################################################
################# factorial.cpp ##################
##################################################

template&lt; typename T &gt;
T factorial(int64_t n) {
  if(n &gt;= T::get_mod()) return 0;
  if(n == 0) return 1;

  const int64_t sn = sqrt(n);
  const T sn_inv = T(1) / sn;

  Combination&lt; modint &gt; comb(sn);
  using P = vector&lt; T &gt;;

  ArbitraryModConvolution&lt; T &gt; fft;
  using FPS = FormalPowerSeries&lt; T &gt;;
  auto mult = [&amp;](const typename FPS::P &amp;a, const typename FPS::P &amp;b) {
    auto ret = fft.multiply(a, b);
    return typename FPS::P(ret.begin(), ret.end());
  };
  FPS::set_fft(mult);


  auto shift = [&amp;](const P &amp;f, T dx) {
    int n = (int) f.size();
    T a = dx * sn_inv;
    auto p1 = P(f);
    for(int i = 0; i &lt; n; i++) {
      T d = comb.rfact(i) * comb.rfact((n - 1) - i);
      if(((n - 1 - i) &amp; 1)) d = -d;
      p1[i] *= d;
    }
    auto p2 = P(2 * n);
    for(int i = 0; i &lt; p2.size(); i++) {
      p2[i] = (a.x + i - n) &lt;= 0 ? 1 : a + i - n;
    }
    for(int i = 1; i &lt; p2.size(); i++) {
      p2[i] *= p2[i - 1];
    }
    T prod = p2[2 * n - 1];
    T prod_inv = T(1) / prod;
    for(int i = 2 * n - 1; i &gt; 0; --i) {
      p2[i] = prod_inv * p2[i - 1];
      prod_inv *= a + i - n;
    }
    p2[0] = prod_inv;
    auto p3 = fft.multiply(p1, p2, (int) p2.size());
    p1 = P(p3.begin() + p1.size(), p3.begin() + p2.size());
    prod = 1;
    for(int i = 0; i &lt; n; i++) {
      prod *= a + n - 1 - i;
    }
    for(int i = n - 1; i &gt;= 0; --i) {
      p1[i] *= prod;
      prod *= p2[n + i] * (a + i - n);
    }
    return p1;
  };
  function&lt; P(int) &gt; rec = [&amp;](int64_t n) {
    if(n == 1) return P({1, 1 + sn});
    int64_t nh = n &gt;&gt; 1;
    auto a1 = rec(nh);
    auto a2 = shift(a1, nh);
    auto b1 = shift(a1, sn * nh);
    auto b2 = shift(a1, sn * nh + nh);
    for(int i = 0; i &lt;= nh; i++) a1[i] *= a2[i];
    for(int i = 1; i &lt;= nh; i++) a1.emplace_back(b1[i] * b2[i]);
    if(n &amp; 1) {
      for(int64_t i = 0; i &lt; n; i++) {
        a1[i] *= n + 1LL * sn * i;
      }
      T prod = 1;
      for(int64_t i = 1LL * n * sn; i &lt; 1LL * n * sn + n; i++) {
        prod *= (i + 1);
      }
      a1.push_back(prod);
    }
    return a1;
  };
  auto vs = rec(sn);
  T ret = 1;
  for(int64_t i = 0; i &lt; sn; i++) ret *= vs[i];
  for(int64_t i = 1LL * sn * sn + 1; i &lt;= n; i++) ret *= i;
  return ret;
}


##################################################
############### binomial-table.cpp ###############
##################################################

template&lt; typename T &gt;
vector&lt; vector&lt; T &gt; &gt; binomial_table(int N) {
  vector&lt; vector&lt; T &gt; &gt; mat(N + 1, vector&lt; T &gt;(N + 1));
  for(int i = 0; i &lt;= N; i++) {
    for(int j = 0; j &lt;= i; j++) {
      if(j == 0 || j == i) mat[i][j] = 1;
      else mat[i][j] = mat[i - 1][j - 1] + mat[i - 1][j];
    }
  }
  return mat;
}


##################################################
########## polynomial-interpolation.cpp ##########
##################################################

template&lt; class T &gt;
FormalPowerSeries&lt; T &gt; polynomial_interpolation(const FormalPowerSeries&lt; T &gt; &amp;xs, const vector&lt; T &gt; &amp;ys) {
  assert(xs.size() == ys.size());
  using FPS = FormalPowerSeries&lt; T &gt;;
  PolyBuf&lt; T &gt; buf(xs);
  FPS w = buf.query(0, xs.size()).diff();
  auto vs = multipoint_evaluation(w, xs, buf);
  function&lt; FPS(int, int) &gt; rec = [&amp;](int l, int r) -&gt; FPS {
    if(r - l == 1) return {ys[l] / vs[l]};
    int m = (l + r) &gt;&gt; 1;
    return rec(l, m) * buf.query(m, r) + rec(m, r) * buf.query(l, m);
  };
  return rec(0, xs.size());
}


##################################################
################ bell-number.cpp #################
##################################################

template&lt; typename T &gt;
T bell_number(int n, int k) {
  if(n == 0) return 1;
  k = min(k, n);
  Combination&lt; T &gt; uku(k);
  T ret = 0;
  vector&lt; T &gt; pref(k + 1);
  pref[0] = 1;
  for(int i = 1; i &lt;= k; i++) {
    if(i &amp; 1) pref[i] = pref[i - 1] - uku.rfact(i);
    else pref[i] = pref[i - 1] + uku.rfact(i);
  }
  for(int i = 1; i &lt;= k; i++) {
    ret += T(i).pow(n) * uku.rfact(i) * pref[k - i];
  }
  return ret;
}


##################################################
################## divisor.cpp ###################
##################################################

vector&lt; int64_t &gt; divisor(int64_t n) {
  vector&lt; int64_t &gt; ret;
  for(int64_t i = 1; i * i &lt;= n; i++) {
    if(n % i == 0) {
      ret.push_back(i);
      if(i * i != n) ret.push_back(n / i);
    }
  }
  sort(begin(ret), end(ret));
  return (ret);
}


##################################################
####### arbitrary-mod-convolution-long.cpp #######
##################################################

template&lt; typename T &gt;
struct ArbitraryModConvolutionLong {
  using real = FastFourierTransform::real;
  using C = FastFourierTransform::C;

  ArbitraryModConvolutionLong() = default;

  vector&lt; T &gt; multiply(const vector&lt; T &gt; &amp;a, const vector&lt; T &gt; &amp;b, int need = -1) {
    if(need == -1) need = a.size() + b.size() - 1;
    int nbase = 0;
    while((1 &lt;&lt; nbase) &lt; need) nbase++;
    FastFourierTransform::ensure_base(nbase);
    int sz = 1 &lt;&lt; nbase;
    vector&lt; C &gt; fa(sz);
    for(int i = 0; i &lt; a.size(); i++) {
      fa[i] = C(a[i].x &amp; ((1 &lt;&lt; 19) - 1), a[i].x &gt;&gt; 19);
    }
    fft(fa, sz);
    vector&lt; C &gt; fb(sz);
    if(a == b) {
      fb = fa;
    } else {
      for(int i = 0; i &lt; b.size(); i++) {
        fb[i] = C(b[i].x &amp; ((1 &lt;&lt; 19) - 1), b[i].x &gt;&gt; 19);
      }
      fft(fb, sz);
    }
    real ratio = 0.25 / sz;
    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);
    for(int i = 0; i &lt;= (sz &gt;&gt; 1); i++) {
      int j = (sz - i) &amp; (sz - 1);
      C a1 = (fa[i] + fa[j].conj());
      C a2 = (fa[i] - fa[j].conj()) * r2;
      C b1 = (fb[i] + fb[j].conj()) * r3;
      C b2 = (fb[i] - fb[j].conj()) * r4;
      if(i != j) {
        C c1 = (fa[j] + fa[i].conj());
        C c2 = (fa[j] - fa[i].conj()) * r2;
        C d1 = (fb[j] + fb[i].conj()) * r3;
        C d2 = (fb[j] - fb[i].conj()) * r4;
        fa[i] = c1 * d1 + c2 * d2 * r5;
        fb[i] = c1 * d2 + c2 * d1;
      }
      fa[j] = a1 * b1 + a2 * b2 * r5;
      fb[j] = a1 * b2 + a2 * b1;
    }
    fft(fa, sz);
    fft(fb, sz);
    vector&lt; T &gt; ret(need);
    auto mul1 = T(2).pow(19);
    auto mul2 = T(2).pow(38);
    for(int i = 0; i &lt; need; i++) {
      int64_t aa = llround(fa[i].x);
      int64_t bb = llround(fb[i].x);
      int64_t cc = llround(fa[i].y);
      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;
      ret[i] = (mul1 * bb) + (mul2 * cc) + aa;
    }
    return ret;
  }
};


##################################################
################## mod-pow.cpp ###################
##################################################

template&lt; typename T &gt;
T mod_pow(T x, T n, const T &amp;p) {
  T ret = 1;
  while(n &gt; 0) {
    if(n &amp; 1) (ret *= x) %= p;
    (x *= x) %= p;
    n &gt;&gt;= 1;
  }
  return ret;
}



##################################################
################ prime-table.cpp #################
##################################################

vector&lt; bool &gt; prime_table(int n) {
  vector&lt; bool &gt; prime(n + 1, true);
  if(n &gt;= 0) prime[0] = false;
  if(n &gt;= 1) prime[1] = false;
  for(int i = 2; i * i &lt;= n; i++) {
    if(!prime[i]) continue;
    for(int j = i + i; j &lt;= n; j += i) {
      prime[j] = false;
    }
  }
  return prime;
}


##################################################
########### multipoint-evaluation.cpp ############
##################################################

template&lt; typename T &gt;
struct PolyBuf {
  using FPS = FormalPowerSeries&lt; T &gt;;
  const FPS xs;
  using pi = pair&lt; int, int &gt;;
  map&lt; pi, FPS &gt; buf;

  PolyBuf(const FPS &amp;xs) : xs(xs) {}

  const FPS &amp;query(int l, int r) {
    if(buf.count({l, r})) return buf[{l, r}];
    if(l + 1 == r) return buf[{l, r}] = {-xs[l], 1};
    return buf[{l, r}] = query(l, (l + r) &gt;&gt; 1) * query((l + r) &gt;&gt; 1, r);
  }
};


template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; multipoint_evaluation(const FormalPowerSeries&lt; T &gt; &amp;as, const FormalPowerSeries&lt; T &gt; &amp;xs, PolyBuf&lt; T &gt; &amp;buf) {
  using FPS = FormalPowerSeries&lt; T &gt;;
  FPS ret;
  const int B = 64;
  function&lt; void(FPS, int, int) &gt; rec = [&amp;](FPS a, int l, int r) -&gt; void {
    a %= buf.query(l, r);
    if(a.size() &lt;= B) {
      for(int i = l; i &lt; r; i++) ret.emplace_back(a.eval(xs[i]));
      return;
    }
    rec(a, l, (l + r) &gt;&gt; 1);
    rec(a, (l + r) &gt;&gt; 1, r);
  };
  rec(as, 0, xs.size());
  return ret;
};

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; multipoint_evaluation(const FormalPowerSeries&lt; T &gt; &amp;as, const FormalPowerSeries&lt; T &gt; &amp;xs) {
  PolyBuf&lt; T &gt; buff(xs);
  return multipoint_evaluation(as, xs, buff);
}



##################################################
################## mod-sqrt.cpp ##################
##################################################

template&lt; typename T &gt;
T mod_sqrt(const T &amp;a, const T &amp;p) {
  if(a == 0) return 0;
  if(p == 2) return a;
  if(mod_pow(a, (p - 1) &gt;&gt; 1, p) != 1) return -1;
  T b = 1;
  while(mod_pow(b, (p - 1) &gt;&gt; 1, p) == 1) ++b;
  T e = 0, m = p - 1;
  while(m % 2 == 0) m &gt;&gt;= 1, ++e;
  T x = mod_pow(a, (m - 1) &gt;&gt; 1, p);
  T y = a * (x * x % p) % p;
  (x *= a) %= p;
  T z = mod_pow(b, m, p);
  while(y != 1) {
    T j = 0, t = y;
    while(t != 1) {
      j += 1;
      (t *= t) %= p;
    }
    z = mod_pow(z, T(1) &lt;&lt; (e - j - 1), p);
    (x *= z) %= p;
    (z *= z) %= p;
    (y *= z) %= p;
    e = j;
  }
  return x;
}


##################################################
######### arbitrary-mod-convolution.cpp ##########
##################################################

template&lt; typename T &gt;
struct ArbitraryModConvolution {
  using real = FastFourierTransform::real;
  using C = FastFourierTransform::C;

  ArbitraryModConvolution() = default;

  vector&lt; T &gt; multiply(const vector&lt; T &gt; &amp;a, const vector&lt; T &gt; &amp;b, int need = -1) {
    if(need == -1) need = a.size() + b.size() - 1;
    int nbase = 0;
    while((1 &lt;&lt; nbase) &lt; need) nbase++;
    FastFourierTransform::ensure_base(nbase);
    int sz = 1 &lt;&lt; nbase;
    vector&lt; C &gt; fa(sz);
    for(int i = 0; i &lt; a.size(); i++) {
      fa[i] = C(a[i].x &amp; ((1 &lt;&lt; 15) - 1), a[i].x &gt;&gt; 15);
    }
    fft(fa, sz);
    vector&lt; C &gt; fb(sz);
    if(a == b) {
      fb = fa;
    } else {
      for(int i = 0; i &lt; b.size(); i++) {
        fb[i] = C(b[i].x &amp; ((1 &lt;&lt; 15) - 1), b[i].x &gt;&gt; 15);
      }
      fft(fb, sz);
    }
    real ratio = 0.25 / sz;
    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);
    for(int i = 0; i &lt;= (sz &gt;&gt; 1); i++) {
      int j = (sz - i) &amp; (sz - 1);
      C a1 = (fa[i] + fa[j].conj());
      C a2 = (fa[i] - fa[j].conj()) * r2;
      C b1 = (fb[i] + fb[j].conj()) * r3;
      C b2 = (fb[i] - fb[j].conj()) * r4;
      if(i != j) {
        C c1 = (fa[j] + fa[i].conj());
        C c2 = (fa[j] - fa[i].conj()) * r2;
        C d1 = (fb[j] + fb[i].conj()) * r3;
        C d2 = (fb[j] - fb[i].conj()) * r4;
        fa[i] = c1 * d1 + c2 * d2 * r5;
        fb[i] = c1 * d2 + c2 * d1;
      }
      fa[j] = a1 * b1 + a2 * b2 * r5;
      fb[j] = a1 * b2 + a2 * b1;
    }
    fft(fa, sz);
    fft(fb, sz);
    vector&lt; T &gt; ret(need);
    for(int i = 0; i &lt; need; i++) {
      int64_t aa = llround(fa[i].x);
      int64_t bb = llround(fb[i].x);
      int64_t cc = llround(fa[i].y);
      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;
      ret[i] = aa + (bb &lt;&lt; 15) + (cc &lt;&lt; 30);
    }
    return ret;
  }
};


##################################################
 number-theoretic-transform-friendly-mod-int.cpp #
##################################################

template&lt; typename Mint &gt;
struct NumberTheoreticTransformFriendlyModInt {

  vector&lt; int &gt; rev;
  vector&lt; Mint &gt; rts;
  int base, max_base;
  Mint root;

  NumberTheoreticTransformFriendlyModInt() : base(1), rev{0, 1}, rts{0, 1} {
    const int mod = Mint::get_mod();
    assert(mod &gt;= 3 &amp;&amp; mod % 2 == 1);
    auto tmp = mod - 1;
    max_base = 0;
    while(tmp % 2 == 0) tmp &gt;&gt;= 1, max_base++;
    root = 2;
    while(root.pow((mod - 1) &gt;&gt; 1) == 1) root += 1;
    assert(root.pow(mod - 1) == 1);
    root = root.pow((mod - 1) &gt;&gt; max_base);
  }

  void ensure_base(int nbase) {
    if(nbase &lt;= base) return;
    rev.resize(1 &lt;&lt; nbase);
    rts.resize(1 &lt;&lt; nbase);
    for(int i = 0; i &lt; (1 &lt;&lt; nbase); i++) {
      rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1));
    }
    assert(nbase &lt;= max_base);
    while(base &lt; nbase) {
      Mint z = root.pow(1 &lt;&lt; (max_base - 1 - base));
      for(int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) {
        rts[i &lt;&lt; 1] = rts[i];
        rts[(i &lt;&lt; 1) + 1] = rts[i] * z;
      }
      ++base;
    }
  }


  void ntt(vector&lt; Mint &gt; &amp;a) {
    const int n = (int) a.size();
    assert((n &amp; (n - 1)) == 0);
    int zeros = __builtin_ctz(n);
    ensure_base(zeros);
    int shift = base - zeros;
    for(int i = 0; i &lt; n; i++) {
      if(i &lt; (rev[i] &gt;&gt; shift)) {
        swap(a[i], a[rev[i] &gt;&gt; shift]);
      }
    }
    for(int k = 1; k &lt; n; k &lt;&lt;= 1) {
      for(int i = 0; i &lt; n; i += 2 * k) {
        for(int j = 0; j &lt; k; j++) {
          Mint z = a[i + j + k] * rts[j + k];
          a[i + j + k] = a[i + j] - z;
          a[i + j] = a[i + j] + z;
        }
      }
    }
  }


  void intt(vector&lt; Mint &gt; &amp;a) {
    const int n = (int) a.size();
    ntt(a);
    reverse(a.begin() + 1, a.end());
    Mint inv_sz = Mint(1) / n;
    for(int i = 0; i &lt; n; i++) a[i] *= inv_sz;
  }

  vector&lt; Mint &gt; multiply(vector&lt; Mint &gt; a, vector&lt; Mint &gt; b) {
    int need = a.size() + b.size() - 1;
    int nbase = 1;
    while((1 &lt;&lt; nbase) &lt; need) nbase++;
    ensure_base(nbase);
    int sz = 1 &lt;&lt; nbase;
    a.resize(sz, 0);
    b.resize(sz, 0);
    ntt(a);
    ntt(b);
    Mint inv_sz = Mint(1) / sz;
    for(int i = 0; i &lt; sz; i++) {
      a[i] *= b[i] * inv_sz;
    }
    reverse(a.begin() + 1, a.end());
    ntt(a);
    a.resize(need);
    return a;
  }
};


##################################################
################# euler-phi.cpp ##################
##################################################

int64_t euler_phi(int64_t n) {
  int64_t ret = n;
  for(int64_t i = 2; i * i &lt;= n; i++) {
    if(n % i == 0) {
      ret -= ret / i;
      while(n % i == 0) n /= i;
    }
  }
  if(n &gt; 1) ret -= ret / n;
  return ret;
}


##################################################
############ lagrange-polynomial.cpp #############
##################################################

template&lt; typename T &gt;
T lagrange_polynomial(const vector&lt; T &gt; &amp;y, int64_t t) {
  int N = y.size() - 1;
  Combination&lt; T &gt; comb(N);
  if(t &lt;= N) return y[t];
  T ret(0);
  vector&lt; T &gt; dp(N + 1, 1), pd(N + 1, 1);
  for(int i = 0; i &lt; N; i++) dp[i + 1] = dp[i] * (t - i);
  for(int i = N; i &gt; 0; i--) pd[i - 1] = pd[i] * (t - i);
  for(int i = 0; i &lt;= N; i++) {
    T tmp = y[i] * dp[i] * pd[i] * comb.rfact(i) * comb.rfact(N - i);
    if((N - i) &amp; 1) ret -= tmp;
    else ret += tmp;
  }
  return ret;
}


##################################################
################ combination.cpp #################
##################################################

template&lt; typename T &gt;
struct Combination {
  vector&lt; T &gt; _fact, _rfact, _inv;

  Combination(int sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {
    _fact[0] = _rfact[sz] = _inv[0] = 1;
    for(int i = 1; i &lt;= sz; i++) _fact[i] = _fact[i - 1] * i;
    _rfact[sz] /= _fact[sz];
    for(int i = sz - 1; i &gt;= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);
    for(int i = 1; i &lt;= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];
  }

  inline T fact(int k) const { return _fact[k]; }

  inline T rfact(int k) const { return _rfact[k]; }

  inline T inv(int k) const { return _inv[k]; }

  T P(int n, int r) const {
    if(r &lt; 0 || n &lt; r) return 0;
    return fact(n) * rfact(n - r);
  }

  T C(int p, int q) const {
    if(q &lt; 0 || p &lt; q) return 0;
    return fact(p) * rfact(q) * rfact(p - q);
  }

  T H(int n, int r) const {
    if(n &lt; 0 || r &lt; 0) return (0);
    return r == 0 ? 1 : C(n + r - 1, r);
  }
};


##################################################
################## mod-log.cpp ###################
##################################################

int64_t mod_log(int64_t a, int64_t b, int64_t p) {
  int64_t g = 1;

  for(int64_t i = p; i; i /= 2) (g *= a) %= p;
  g = __gcd(g, p);

  int64_t t = 1, c = 0;
  for(; t % g; c++) {
    if(t == b) return c;
    (t *= a) %= p;
  }
  if(b % g) return -1;

  t /= g;
  b /= g;

  int64_t n = p / g, h = 0, gs = 1;

  for(; h * h &lt; n; h++) (gs *= a) %= n;

  unordered_map&lt; int64_t, int64_t &gt; bs;
  for(int64_t s = 0, e = b; s &lt; h; bs[e] = ++s) {
    (e *= a) %= n;
  }

  for(int64_t s = 0, e = t; s &lt; n;) {
    (e *= gs) %= n;
    s += h;
    if(bs.count(e)) return c + s - bs[e];
  }
  return -1;
}


##################################################
############### quotient-range.cpp ###############
##################################################

template&lt; typename T &gt;
vector&lt; pair&lt; pair&lt; T, T &gt;, T &gt; &gt; quotient_range(T N) {
  T M;
  vector&lt; pair&lt; pair&lt; T, T &gt;, T &gt; &gt; ret;
  for(M = 1; M * M &lt;= N; M++) {
    ret.emplace_back(make_pair(M, M), N / M);
  }
  for(T i = M; i &gt;= 1; i--) {
    T L = N / (i + 1) + 1;
    T R = N / i;
    if(L &lt;= R &amp;&amp; ret.back().first.second &lt; L) ret.emplace_back(make_pair(L, R), N / L);
  }
  return ret;
}


##################################################
########## formal-power-series-seq.cpp ###########
##################################################

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; bernoulli(int N) {
  FormalPowerSeries&lt; T &gt; poly(N + 1);
  poly[0] = T(1);
  for(int i = 1; i &lt;= N; i++) {
    poly[i] = poly[i - 1] / T(i + 1);
  }
  poly = poly.inv();
  T tmp(1);
  for(int i = 1; i &lt;= N; i++) {
    tmp *= T(i);
    poly[i] *= tmp;
  }
  return poly;
}

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; partition(int N) {
  FormalPowerSeries&lt; T &gt; poly(N + 1);
  poly[0] = 1;
  for(int k = 1; k &lt;= N; k++) {
    if(1LL * k * (3 * k + 1) / 2 &lt;= N) poly[k * (3 * k + 1) / 2] += (k % 2 ? -1 : 1);
    if(1LL * k * (3 * k - 1) / 2 &lt;= N) poly[k * (3 * k - 1) / 2] += (k % 2 ? -1 : 1);
  }
  return poly.inv();
}

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; bell(int N) {
  FormalPowerSeries&lt; T &gt; poly(N + 1), ret(N + 1);
  poly[1] = 1;
  poly = poly.exp();
  poly[0] -= 1;
  poly = poly.exp();
  T mul = 1;
  for(int i = 0; i &lt;= N; i++) {
    ret[i] = poly[i] * mul;
    mul *= i + 1;
  }
  return ret;
}

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; stirling_first(int N) {
  if(N == 0) return {1};
  int M = N / 2;
  FormalPowerSeries&lt; T &gt; A = stirling_first&lt; T &gt;(M), B, C(N - M + 1);

  if(N % 2 == 0) {
    B = A;
  } else {
    B.resize(M + 2);
    B[M + 1] = 1;
    for(int i = 1; i &lt; M + 1; i++) B[i] = A[i - 1] + A[i] * M;
  }

  T tmp = 1;
  for(int i = 0; i &lt;= N - M; i++) {
    C[N - M - i] = T(M).pow(i) / tmp;
    B[i] *= tmp;
    tmp *= T(i + 1);
  }
  C *= B;
  tmp = 1;
  for(int i = 0; i &lt;= N - M; i++) {
    B[i] = C[N - M + i] / tmp;
    tmp *= T(i + 1);
  }
  return A * B;
}

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; stirling_second(int N) {
  FormalPowerSeries&lt; T &gt; A(N + 1), B(N + 1);
  modint tmp = 1;
  for(int i = 0; i &lt;= N; i++) {
    T rev = T(1) / tmp;
    A[i] = T(i).pow(N) * rev;
    B[i] = T(1) * rev;
    if(i &amp; 1) B[i] *= -1;
    tmp *= i + 1;
  }
  return (A * B).pre(N + 1);
}

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; stirling_second_kth_column(int N, int K) {
  FormalPowerSeries&lt; T &gt; poly(N + 1), ret(N + 1);
  poly[1] = 1;
  poly = poly.exp();
  poly[0] -= 1;
  poly = poly.pow(K);
  T rev = 1, mul = 1;
  for(int i = 2; i &lt;= K; i++) rev *= i;
  rev = T(1) / rev;
  poly *= rev;
  for(int i = 0; i &lt;= N; i++) {
    ret[i] = poly[i] * mul;
    mul *= i + 1;
  }
  return ret;
}

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; eulerian(int N) {
  vector&lt; T &gt; fact(N + 2), rfact(N + 2);
  fact[0] = rfact[N + 1] = 1;
  for(int i = 1; i &lt;= N + 1; i++) fact[i] = fact[i - 1] * i;
  rfact[N + 1] /= fact[N + 1];
  for(int i = N; i &gt;= 0; i--) rfact[i] = rfact[i + 1] * (i + 1);

  FormalPowerSeries&lt; T &gt; A(N + 1), B(N + 1);
  for(int i = 0; i &lt;= N; i++) {
    A[i] = fact[N + 1] * rfact[i] * rfact[N + 1 - i];
    if(i &amp; 1) A[i] *= -1;
    B[i] = T(i + 1).pow(N);
  }
  return (A * B).pre(N + 1);
}


##################################################
########## fast-prime-factorization.cpp ##########
##################################################

namespace FastPrimeFactorization {

  template&lt; typename word, typename dword, typename sword &gt;
  struct UnsafeMod {
    UnsafeMod() : x(0) {}

    UnsafeMod(word _x) : x(init(_x)) {}

    bool operator==(const UnsafeMod &amp;rhs) const {
      return x == rhs.x;
    }

    bool operator!=(const UnsafeMod &amp;rhs) const {
      return x != rhs.x;
    }

    UnsafeMod &amp;operator+=(const UnsafeMod &amp;rhs) {
      if((x += rhs.x) &gt;= mod) x -= mod;
      return *this;
    }

    UnsafeMod &amp;operator-=(const UnsafeMod &amp;rhs) {
      if(sword(x -= rhs.x) &lt; 0) x += mod;
      return *this;
    }

    UnsafeMod &amp;operator*=(const UnsafeMod &amp;rhs) {
      x = reduce(dword(x) * rhs.x);
      return *this;
    }

    UnsafeMod operator+(const UnsafeMod &amp;rhs) const {
      return UnsafeMod(*this) += rhs;
    }

    UnsafeMod operator-(const UnsafeMod &amp;rhs) const {
      return UnsafeMod(*this) -= rhs;
    }

    UnsafeMod operator*(const UnsafeMod &amp;rhs) const {
      return UnsafeMod(*this) *= rhs;
    }

    UnsafeMod pow(uint64_t e) const {
      UnsafeMod ret(1);
      for(UnsafeMod base = *this; e; e &gt;&gt;= 1, base *= base) {
        if(e &amp; 1) ret *= base;
      }
      return ret;
    }

    word get() const {
      return reduce(x);
    }

    static constexpr int word_bits = sizeof(word) * 8;

    static word modulus() {
      return mod;
    }

    static word init(word w) {
      return reduce(dword(w) * r2);
    }

    static void set_mod(word m) {
      mod = m;
      inv = mul_inv(mod);
      r2 = -dword(mod) % mod;
    }

    static word reduce(dword x) {
      word y = word(x &gt;&gt; word_bits) - word((dword(word(x) * inv) * mod) &gt;&gt; word_bits);
      return sword(y) &lt; 0 ? y + mod : y;
    }

    static word mul_inv(word n, int e = 6, word x = 1) {
      return !e ? x : mul_inv(n, e - 1, x * (2 - x * n));
    }

    static word mod, inv, r2;

    word x;
  };

  using uint128_t = __uint128_t;

  using Mod64 = UnsafeMod&lt; uint64_t, uint128_t, int64_t &gt;;
  template&lt;&gt; uint64_t Mod64::mod = 0;
  template&lt;&gt; uint64_t Mod64::inv = 0;
  template&lt;&gt; uint64_t Mod64::r2 = 0;

  using Mod32 = UnsafeMod&lt; uint32_t, uint64_t, int32_t &gt;;
  template&lt;&gt; uint32_t Mod32::mod = 0;
  template&lt;&gt; uint32_t Mod32::inv = 0;
  template&lt;&gt; uint32_t Mod32::r2 = 0;

  bool miller_rabin_primality_test_uint64(uint64_t n) {
    Mod64::set_mod(n);
    uint64_t d = n - 1;
    while(d % 2 == 0) d /= 2;
    Mod64 e{1}, rev{n - 1};
    // http://miller-rabin.appspot.com/  &lt; 2^64
    for(uint64_t a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {
      if(n &lt;= a) break;
      uint64_t t = d;
      Mod64 y = Mod64(a).pow(t);
      while(t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {
        y *= y;
        t *= 2;
      }
      if(y != rev &amp;&amp; t % 2 == 0) return false;
    }
    return true;
  }

  bool miller_rabin_primality_test_uint32(uint32_t n) {
    Mod32::set_mod(n);
    uint32_t d = n - 1;
    while(d % 2 == 0) d /= 2;
    Mod32 e{1}, rev{n - 1};
    for(uint32_t a : {2, 7, 61}) {
      if(n &lt;= a) break;
      uint32_t t = d;
      Mod32 y = Mod32(a).pow(t);
      while(t != n - 1 &amp;&amp; y != e &amp;&amp; y != rev) {
        y *= y;
        t *= 2;
      }
      if(y != rev &amp;&amp; t % 2 == 0) return false;
    }
    return true;
  }

  bool is_prime(uint64_t n) {
    if(n == 2) return true;
    if(n == 1 || n % 2 == 0) return false;
    if(n &lt; uint64_t(1) &lt;&lt; 31) return miller_rabin_primality_test_uint32(n);
    return miller_rabin_primality_test_uint64(n);
  }

  uint64_t pollard_rho(uint64_t n) {
    if(is_prime(n)) return n;
    if(n % 2 == 0) return 2;
    Mod64::set_mod(n);
    uint64_t d;
    Mod64 one{1};
    for(Mod64 c{one};; c += one) {
      Mod64 x{2}, y{2};
      do {
        x = x * x + c;
        y = y * y + c;
        y = y * y + c;
        d = __gcd((x - y).get(), n);
      } while(d == 1);
      if(d &lt; n) return d;
    }
    assert(0);
  }

  vector&lt; uint64_t &gt; prime_factor(uint64_t n) {
    if(n &lt;= 1) return {};
    uint64_t p = pollard_rho(n);
    if(p == n) return {p};
    auto l = prime_factor(p);
    auto r = prime_factor(n / p);
    copy(begin(r), end(r), back_inserter(l));
    return l;
  }
};


##################################################
################## is-prime.cpp ##################
##################################################

bool is_prime(int64_t x) {
  for(int64_t i = 2; i * i &lt;= x; i++) {
    if(x % i == 0) return false;
  }
  return true;
}


##################################################
############### sparse-matrix.cpp ################
##################################################

template&lt; typename T &gt;
using FPSGraph = vector&lt; vector&lt; pair&lt; int, T &gt; &gt; &gt;;

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; random_poly(int n) {
  mt19937 mt(1333333);
  FormalPowerSeries&lt; T &gt; res(n);
  uniform_int_distribution&lt; int &gt; rand(0, T::get_mod() - 1);
  for(int i = 0; i &lt; n; i++) res[i] = rand(mt);
  return res;
}

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; next_poly(const FormalPowerSeries&lt; T &gt; &amp;dp, const FPSGraph&lt; T &gt; &amp;g) {
  const int N = (int) dp.size();
  FormalPowerSeries&lt; T &gt; nxt(N);
  for(int i = 0; i &lt; N; i++) {
    for(auto &amp;p : g[i]) nxt[p.first] += p.second * dp[i];
  }
  return nxt;
}

template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; minimum_poly(const FPSGraph&lt; T &gt; &amp;g) {
  const int N = (int) g.size();
  auto dp = random_poly&lt; T &gt;(N), u = random_poly&lt; T &gt;(N);
  FormalPowerSeries&lt; T &gt; f(2 * N);
  for(int i = 0; i &lt; 2 * N; i++) {
    for(auto &amp;p : u.dot(dp)) f[i] += p;
    dp = next_poly(dp, g);
  }
  return berlekamp_massey(f);
}

/* O(N(N+S) + N log N log Q) (O(S): time complexity of nex) */
template&lt; typename T &gt;
FormalPowerSeries&lt; T &gt; sparse_pow(int64_t Q, FormalPowerSeries&lt; modint &gt; dp, const FPSGraph&lt; T &gt; &amp;g) {
  const int N = (int) dp.size();
  auto A = FormalPowerSeries&lt; T &gt;({0, 1}).pow_mod(Q, minimum_poly(g));
  FormalPowerSeries&lt; T &gt; res(N);
  for(int i = 0; i &lt; A.size(); i++) {
    res += dp * A[i];
    dp = next_poly(dp, g);
  }
  return res;
}

/* O(N(N+S)) (S: none-zero elements)*/
template&lt; typename T &gt;
T sparse_determinant(FPSGraph&lt; T &gt; g) {
  using FPS = FormalPowerSeries&lt; T &gt;;
  int N = (int) g.size();
  auto C = random_poly&lt; T &gt;(N);
  for(int i = 0; i &lt; N; i++) for(auto &amp;p : g[i]) p.second *= C[i];
  auto u = minimum_poly(g);
  T acdet = u[0];
  if(N % 2 == 0) acdet *= -1;
  T cdet = 1;
  for(int i = 0; i &lt; N; i++) cdet *= C[i];
  return acdet / cdet;
}


##################################################
################ convert-base.cpp ################
##################################################

template&lt; typename T &gt;
vector&lt; T &gt; convert_base(T x, T b) {
  vector&lt; T &gt; ret;
  T t = 1, k = abs(b);
  while(x) {
    ret.emplace_back((x * t) % k);
    if(ret.back() &lt; 0) ret.back() += k;
    x -= ret.back() * t;
    x /= k;
    t *= b / k;
  }
  if(ret.empty()) ret.emplace_back(0);
  reverse(begin(ret), end(ret));
  return ret;
}


##################################################
############## partition-table.cpp ###############
##################################################

template&lt; typename T &gt;
vector&lt; vector&lt; T &gt; &gt; get_partition(int n, int k) {
  vector&lt; vector&lt; T &gt; &gt; dp(n + 1, vector&lt; T &gt;(k + 1));
  dp[0][0] = 1;
  for(int i = 0; i &lt;= n; i++) {
    for(int j = 1; j &lt;= k; j++) {
      if(i - j &gt;= 0) dp[i][j] = dp[i][j - 1] + dp[i - j][j];
      else dp[i][j] = dp[i][j - 1];
    }
  }
  return dp;
}


##################################################
########### fast-fourier-transform.cpp ###########
##################################################

namespace FastFourierTransform {
  using real = double;

  struct C {
    real x, y;

    C() : x(0), y(0) {}

    C(real x, real y) : x(x), y(y) {}

    inline C operator+(const C &amp;c) const { return C(x + c.x, y + c.y); }

    inline C operator-(const C &amp;c) const { return C(x - c.x, y - c.y); }

    inline C operator*(const C &amp;c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }

    inline C conj() const { return C(x, -y); }
  };

  const real PI = acosl(-1);
  int base = 1;
  vector&lt; C &gt; rts = { {0, 0},
                     {1, 0} };
  vector&lt; int &gt; rev = {0, 1};


  void ensure_base(int nbase) {
    if(nbase &lt;= base) return;
    rev.resize(1 &lt;&lt; nbase);
    rts.resize(1 &lt;&lt; nbase);
    for(int i = 0; i &lt; (1 &lt;&lt; nbase); i++) {
      rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1));
    }
    while(base &lt; nbase) {
      real angle = PI * 2.0 / (1 &lt;&lt; (base + 1));
      for(int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) {
        rts[i &lt;&lt; 1] = rts[i];
        real angle_i = angle * (2 * i + 1 - (1 &lt;&lt; base));
        rts[(i &lt;&lt; 1) + 1] = C(cos(angle_i), sin(angle_i));
      }
      ++base;
    }
  }

  void fft(vector&lt; C &gt; &amp;a, int n) {
    assert((n &amp; (n - 1)) == 0);
    int zeros = __builtin_ctz(n);
    ensure_base(zeros);
    int shift = base - zeros;
    for(int i = 0; i &lt; n; i++) {
      if(i &lt; (rev[i] &gt;&gt; shift)) {
        swap(a[i], a[rev[i] &gt;&gt; shift]);
      }
    }
    for(int k = 1; k &lt; n; k &lt;&lt;= 1) {
      for(int i = 0; i &lt; n; i += 2 * k) {
        for(int j = 0; j &lt; k; j++) {
          C z = a[i + j + k] * rts[j + k];
          a[i + j + k] = a[i + j] - z;
          a[i + j] = a[i + j] + z;
        }
      }
    }
  }

  vector&lt; int64_t &gt; multiply(const vector&lt; int &gt; &amp;a, const vector&lt; int &gt; &amp;b) {
    int need = (int) a.size() + (int) b.size() - 1;
    int nbase = 1;
    while((1 &lt;&lt; nbase) &lt; need) nbase++;
    ensure_base(nbase);
    int sz = 1 &lt;&lt; nbase;
    vector&lt; C &gt; fa(sz);
    for(int i = 0; i &lt; sz; i++) {
      int x = (i &lt; (int) a.size() ? a[i] : 0);
      int y = (i &lt; (int) b.size() ? b[i] : 0);
      fa[i] = C(x, y);
    }
    fft(fa, sz);
    C r(0, -0.25 / (sz &gt;&gt; 1)), s(0, 1), t(0.5, 0);
    for(int i = 0; i &lt;= (sz &gt;&gt; 1); i++) {
      int j = (sz - i) &amp; (sz - 1);
      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;
      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;
      fa[i] = z;
    }
    for(int i = 0; i &lt; (sz &gt;&gt; 1); i++) {
      C A0 = (fa[i] + fa[i + (sz &gt;&gt; 1)]) * t;
      C A1 = (fa[i] - fa[i + (sz &gt;&gt; 1)]) * t * rts[(sz &gt;&gt; 1) + i];
      fa[i] = A0 + A1 * s;
    }
    fft(fa, sz &gt;&gt; 1);
    vector&lt; int64_t &gt; ret(need);
    for(int i = 0; i &lt; need; i++) {
      ret[i] = llround(i &amp; 1 ? fa[i &gt;&gt; 1].y : fa[i &gt;&gt; 1].x);
    }
    return ret;
  }
};


##################################################
################### extgcd.cpp ###################
##################################################

template&lt; typename T &gt;
T extgcd(T a, T b, T &amp;x, T &amp;y) {
  T d = a;
  if(b != 0) {
    d = extgcd(b, a % b, y, x);
    y -= (a / b) * x;
  } else {
    x = 1;
    y = 0;
  }
  return d;
}


##################################################
############ formal-power-series.cpp #############
##################################################

template&lt; typename T &gt;
struct FormalPowerSeries : vector&lt; T &gt; {
  using vector&lt; T &gt;::vector;
  using P = FormalPowerSeries;

  using MULT = function&lt; P(P, P) &gt;;
  using FFT = function&lt; void(P &amp;) &gt;;

  static MULT &amp;get_mult() {
    static MULT mult = nullptr;
    return mult;
  }

  static void set_mult(MULT f) { get_mult() = f; }

  static FFT &amp;get_fft() {
    static FFT fft = nullptr;
    return fft;
  }

  static FFT &amp;get_ifft() {
    static FFT ifft = nullptr;
    return ifft;
  }

  static void set_fft(FFT f, FFT g) {
    get_fft() = f;
    get_ifft() = g;
  }

  void shrink() {
    while(this-&gt;size() &amp;&amp; this-&gt;back() == T(0)) this-&gt;pop_back();
  }

  P operator+(const P &amp;r) const { return P(*this) += r; }

  P operator+(const T &amp;v) const { return P(*this) += v; }

  P operator-(const P &amp;r) const { return P(*this) -= r; }

  P operator-(const T &amp;v) const { return P(*this) -= v; }

  P operator*(const P &amp;r) const { return P(*this) *= r; }

  P operator*(const T &amp;v) const { return P(*this) *= v; }

  P operator/(const P &amp;r) const { return P(*this) /= r; }

  P operator%(const P &amp;r) const { return P(*this) %= r; }

  P &amp;operator+=(const P &amp;r) {
    if(r.size() &gt; this-&gt;size()) this-&gt;resize(r.size());
    for(int i = 0; i &lt; r.size(); i++) (*this)[i] += r[i];
    return *this;
  }

  P &amp;operator+=(const T &amp;r) {
    if(this-&gt;empty()) this-&gt;resize(1);
    (*this)[0] += r;
    return *this;
  }

  P &amp;operator-=(const P &amp;r) {
    if(r.size() &gt; this-&gt;size()) this-&gt;resize(r.size());
    for(int i = 0; i &lt; r.size(); i++) (*this)[i] -= r[i];
    shrink();
    return *this;
  }

  P &amp;operator-=(const T &amp;r) {
    if(this-&gt;empty()) this-&gt;resize(1);
    (*this)[0] -= r;
    shrink();
    return *this;
  }

  P &amp;operator*=(const T &amp;v) {
    const int n = (int) this-&gt;size();
    for(int k = 0; k &lt; n; k++) (*this)[k] *= v;
    return *this;
  }

  P &amp;operator*=(const P &amp;r) {
    if(this-&gt;empty() || r.empty()) {
      this-&gt;clear();
      return *this;
    }
    assert(get_mult() != nullptr);
    return *this = get_mult()(*this, r);
  }

  P &amp;operator%=(const P &amp;r) { return *this -= *this / r * r; }

  P operator-() const {
    P ret(this-&gt;size());
    for(int i = 0; i &lt; this-&gt;size(); i++) ret[i] = -(*this)[i];
    return ret;
  }

  P &amp;operator/=(const P &amp;r) {
    if(this-&gt;size() &lt; r.size()) {
      this-&gt;clear();
      return *this;
    }
    int n = this-&gt;size() - r.size() + 1;
    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);
  }

  P dot(P r) const {
    P ret(min(this-&gt;size(), r.size()));
    for(int i = 0; i &lt; ret.size(); i++) ret[i] = (*this)[i] * r[i];
    return ret;
  }

  P pre(int sz) const { return P(begin(*this), begin(*this) + min((int) this-&gt;size(), sz)); }

  P operator&gt;&gt;(int sz) const {
    if(this-&gt;size() &lt;= sz) return {};
    P ret(*this);
    ret.erase(ret.begin(), ret.begin() + sz);
    return ret;
  }

  P operator&lt;&lt;(int sz) const {
    P ret(*this);
    ret.insert(ret.begin(), sz, T(0));
    return ret;
  }

  P rev(int deg = -1) const {
    P ret(*this);
    if(deg != -1) ret.resize(deg, T(0));
    reverse(begin(ret), end(ret));
    return ret;
  }

  P diff() const {
    const int n = (int) this-&gt;size();
    P ret(max(0, n - 1));
    for(int i = 1; i &lt; n; i++) ret[i - 1] = (*this)[i] * T(i);
    return ret;
  }

  P integral() const {
    const int n = (int) this-&gt;size();
    P ret(n + 1);
    ret[0] = T(0);
    for(int i = 0; i &lt; n; i++) ret[i + 1] = (*this)[i] / T(i + 1);
    return ret;
  }

  // F(0) must not be 0
  P inv(int deg = -1) const {
    assert(((*this)[0]) != T(0));
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    if(get_fft() != nullptr) {
      P ret(*this);
      ret.resize(deg, T(0));
      return ret.inv_fast();
    }
    P ret({T(1) / (*this)[0]});
    for(int i = 1; i &lt; deg; i &lt;&lt;= 1) {
      ret = (ret + ret - ret * ret * pre(i &lt;&lt; 1)).pre(i &lt;&lt; 1);
    }
    return ret.pre(deg);
  }

  // F(0) must be 1
  P log(int deg = -1) const {
    assert((*this)[0] == 1);
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    return (this-&gt;diff() * this-&gt;inv(deg)).pre(deg - 1).integral();
  }

  P sqrt(int deg = -1) const {
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    if((*this)[0] == T(0)) {
      for(int i = 1; i &lt; n; i++) {
        if((*this)[i] != T(0)) {
          if(i &amp; 1) return {};
          if(deg - i / 2 &lt;= 0) break;
          auto ret = (*this &gt;&gt; i).sqrt(deg - i / 2) &lt;&lt; (i / 2);
          if(ret.size() &lt; deg) ret.resize(deg, T(0));
          return ret;
        }
      }
      return P(deg, 0);
    }

    P ret({T(1)});
    T inv2 = T(1) / T(2);
    for(int i = 1; i &lt; deg; i &lt;&lt;= 1) {
      ret = (ret + pre(i &lt;&lt; 1) * ret.inv(i &lt;&lt; 1)) * inv2;
    }
    return ret.pre(deg);
  }

  // F(0) must be 0
  P exp(int deg = -1) const {
    assert((*this)[0] == T(0));
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    if(get_fft() != nullptr) {
      P ret(*this);
      ret.resize(deg, T(0));
      return ret.exp_rec();
    }
    P ret({T(1)});
    for(int i = 1; i &lt; deg; i &lt;&lt;= 1) {
      ret = (ret * (pre(i &lt;&lt; 1) + T(1) - ret.log(i &lt;&lt; 1))).pre(i &lt;&lt; 1);
    }
    return ret.pre(deg);
  }


  P online_convolution_exp(const P &amp;conv_coeff) const {
    const int n = (int) conv_coeff.size();
    assert((n &amp; (n - 1)) == 0);
    vector&lt; P &gt; conv_ntt_coeff;
    for(int i = n; i &gt;= 1; i &gt;&gt;= 1) {
      P g(conv_coeff.pre(i));
      get_fft()(g);
      conv_ntt_coeff.emplace_back(g);
    }
    P conv_arg(n), conv_ret(n);
    auto rec = [&amp;](auto rec, int l, int r, int d) -&gt; void {
      if(r - l &lt;= 16) {
        for(int i = l; i &lt; r; i++) {
          T sum = 0;
          for(int j = l; j &lt; i; j++) sum += conv_arg[j] * conv_coeff[i - j];
          conv_ret[i] += sum;
          conv_arg[i] = i == 0 ? T(1) : conv_ret[i] / i;
        }
      } else {
        int m = (l + r) / 2;
        rec(rec, l, m, d + 1);
        P pre(r - l);
        for(int i = 0; i &lt; m - l; i++) pre[i] = conv_arg[l + i];
        get_fft()(pre);
        for(int i = 0; i &lt; r - l; i++) pre[i] *= conv_ntt_coeff[d][i];
        get_ifft()(pre);
        for(int i = 0; i &lt; r - m; i++) conv_ret[m + i] += pre[m + i - l];
        rec(rec, m, r, d + 1);
      }
    };
    rec(rec, 0, n, 0);
    return conv_arg;
  }

  P exp_rec() const {
    assert((*this)[0] == T(0));
    const int n = (int) this-&gt;size();
    int m = 1;
    while(m &lt; n) m *= 2;
    P conv_coeff(m);
    for(int i = 1; i &lt; n; i++) conv_coeff[i] = (*this)[i] * i;
    return online_convolution_exp(conv_coeff).pre(n);
  }


  P inv_fast() const {
    assert(((*this)[0]) != T(0));

    const int n = (int) this-&gt;size();
    P res{T(1) / (*this)[0]};

    for(int d = 1; d &lt; n; d &lt;&lt;= 1) {
      P f(2 * d), g(2 * d);
      for(int j = 0; j &lt; min(n, 2 * d); j++) f[j] = (*this)[j];
      for(int j = 0; j &lt; d; j++) g[j] = res[j];
      get_fft()(f);
      get_fft()(g);
      for(int j = 0; j &lt; 2 * d; j++) f[j] *= g[j];
      get_ifft()(f);
      for(int j = 0; j &lt; d; j++) {
        f[j] = 0;
        f[j + d] = -f[j + d];
      }
      get_fft()(f);
      for(int j = 0; j &lt; 2 * d; j++) f[j] *= g[j];
      get_ifft()(f);
      for(int j = 0; j &lt; d; j++) f[j] = res[j];
      res = f;
    }
    return res.pre(n);
  }

  P pow(int64_t k, int deg = -1) const {
    const int n = (int) this-&gt;size();
    if(deg == -1) deg = n;
    for(int i = 0; i &lt; n; i++) {
      if((*this)[i] != T(0)) {
        T rev = T(1) / (*this)[i];
        P ret = (((*this * rev) &gt;&gt; i).log() * k).exp() * ((*this)[i].pow(k));
        if(i * k &gt; deg) return P(deg, T(0));
        ret = (ret &lt;&lt; (i * k)).pre(deg);
        if(ret.size() &lt; deg) ret.resize(deg, T(0));
        return ret;
      }
    }
    return *this;
  }

  T eval(T x) const {
    T r = 0, w = 1;
    for(auto &amp;v : *this) {
      r += w * v;
      w *= x;
    }
    return r;
  }

  P pow_mod(int64_t n, P mod) const {
    P modinv = mod.rev().inv();
    auto get_div = [&amp;](P base) {
      if(base.size() &lt; mod.size()) {
        base.clear();
        return base;
      }
      int n = base.size() - mod.size() + 1;
      return (base.rev().pre(n) * modinv.pre(n)).pre(n).rev(n);
    };
    P x(*this), ret{1};
    while(n &gt; 0) {
      if(n &amp; 1) {
        ret *= x;
        ret -= get_div(ret) * mod;
      }
      x *= x;
      x -= get_div(x) * mod;
      n &gt;&gt;= 1;
    }
    return ret;
  }
};


##################################################
################### matrix.cpp ###################
##################################################

template&lt; class T &gt;
struct Matrix {
  vector&lt; vector&lt; T &gt; &gt; A;

  Matrix() {}

  Matrix(size_t n, size_t m) : A(n, vector&lt; T &gt;(m, 0)) {}

  Matrix(size_t n) : A(n, vector&lt; T &gt;(n, 0)) {};

  size_t height() const {
    return (A.size());
  }

  size_t width() const {
    return (A[0].size());
  }

  inline const vector&lt; T &gt; &amp;operator[](int k) const {
    return (A.at(k));
  }

  inline vector&lt; T &gt; &amp;operator[](int k) {
    return (A.at(k));
  }

  static Matrix I(size_t n) {
    Matrix mat(n);
    for(int i = 0; i &lt; n; i++) mat[i][i] = 1;
    return (mat);
  }

  Matrix &amp;operator+=(const Matrix &amp;B) {
    size_t n = height(), m = width();
    assert(n == B.height() &amp;&amp; m == B.width());
    for(int i = 0; i &lt; n; i++)
      for(int j = 0; j &lt; m; j++)
        (*this)[i][j] += B[i][j];
    return (*this);
  }

  Matrix &amp;operator-=(const Matrix &amp;B) {
    size_t n = height(), m = width();
    assert(n == B.height() &amp;&amp; m == B.width());
    for(int i = 0; i &lt; n; i++)
      for(int j = 0; j &lt; m; j++)
        (*this)[i][j] -= B[i][j];
    return (*this);
  }

  Matrix &amp;operator*=(const Matrix &amp;B) {
    size_t n = height(), m = B.width(), p = width();
    assert(p == B.height());
    vector&lt; vector&lt; T &gt; &gt; C(n, vector&lt; T &gt;(m, 0));
    for(int i = 0; i &lt; n; i++)
      for(int j = 0; j &lt; m; j++)
        for(int k = 0; k &lt; p; k++)
          C[i][j] = (C[i][j] + (*this)[i][k] * B[k][j]);
    A.swap(C);
    return (*this);
  }

  Matrix &amp;operator^=(long long k) {
    Matrix B = Matrix::I(height());
    while(k &gt; 0) {
      if(k &amp; 1) B *= *this;
      *this *= *this;
      k &gt;&gt;= 1LL;
    }
    A.swap(B.A);
    return (*this);
  }

  Matrix operator+(const Matrix &amp;B) const {
    return (Matrix(*this) += B);
  }

  Matrix operator-(const Matrix &amp;B) const {
    return (Matrix(*this) -= B);
  }

  Matrix operator*(const Matrix &amp;B) const {
    return (Matrix(*this) *= B);
  }

  Matrix operator^(const long long k) const {
    return (Matrix(*this) ^= k);
  }

  friend ostream &amp;operator&lt;&lt;(ostream &amp;os, Matrix &amp;p) {
    size_t n = p.height(), m = p.width();
    for(int i = 0; i &lt; n; i++) {
      os &lt;&lt; &quot;[&quot;;
      for(int j = 0; j &lt; m; j++) {
        os &lt;&lt; p[i][j] &lt;&lt; (j + 1 == m ? &quot;]\n&quot; : &quot;,&quot;);
      }
    }
    return (os);
  }


  T determinant() {
    Matrix B(*this);
    assert(width() == height());
    T ret = 1;
    for(int i = 0; i &lt; width(); i++) {
      int idx = -1;
      for(int j = i; j &lt; width(); j++) {
        if(B[j][i] != 0) idx = j;
      }
      if(idx == -1) return (0);
      if(i != idx) {
        ret *= -1;
        swap(B[i], B[idx]);
      }
      ret *= B[i][i];
      T vv = B[i][i];
      for(int j = 0; j &lt; width(); j++) {
        B[i][j] /= vv;
      }
      for(int j = i + 1; j &lt; width(); j++) {
        T a = B[j][i];
        for(int k = 0; k &lt; width(); k++) {
          B[j][k] -= B[i][k] * a;
        }
      }
    }
    return (ret);
  }
};


##################################################
############## berlekamp-massey.cpp ##############
##################################################

template&lt; class T &gt;
FormalPowerSeries&lt; T &gt; berlekamp_massey(const FormalPowerSeries&lt; T &gt; &amp;s) {
  const int N = (int) s.size();
  FormalPowerSeries&lt; T &gt; b = {T(-1)}, c = {T(-1)};
  T y = T(1);
  for(int ed = 1; ed &lt;= N; ed++) {
    int l = int(c.size()), m = int(b.size());
    T x = 0;
    for(int i = 0; i &lt; l; i++) x += c[i] * s[ed - l + i];
    b.emplace_back(0);
    m++;
    if(x == T(0)) continue;
    T freq = x / y;
    if(l &lt; m) {
      auto tmp = c;
      c.insert(begin(c), m - l, T(0));
      for(int i = 0; i &lt; m; i++) c[m - 1 - i] -= freq * b[m - 1 - i];
      b = tmp;
      y = x;
    } else {
      for(int i = 0; i &lt; m; i++) c[l - 1 - i] -= freq * b[m - 1 - i];
    }
  }
  return c;
}


##################################################
############## euler-phi-table.cpp ###############
##################################################

vector&lt; int &gt; euler_phi_table(int n) {
  vector&lt; int &gt; euler(n + 1);
  for(int i = 0; i &lt;= n; i++) {
    euler[i] = i;
  }
  for(int i = 2; i &lt;= n; i++) {
    if(euler[i] == i) {
      for(int j = i; j &lt;= n; j += i) {
        euler[j] = euler[j] / i * (i - 1);
      }
    }
  }
  return euler;
}


##################################################
######### number-theoretic-transform.cpp #########
##################################################

template&lt; int mod &gt;
struct NumberTheoreticTransform {

  vector&lt; int &gt; rev, rts;
  int base, max_base, root;

  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {
    assert(mod &gt;= 3 &amp;&amp; mod % 2 == 1);
    auto tmp = mod - 1;
    max_base = 0;
    while(tmp % 2 == 0) tmp &gt;&gt;= 1, max_base++;
    root = 2;
    while(mod_pow(root, (mod - 1) &gt;&gt; 1) == 1) ++root;
    assert(mod_pow(root, mod - 1) == 1);
    root = mod_pow(root, (mod - 1) &gt;&gt; max_base);
  }

  inline int mod_pow(int x, int n) {
    int ret = 1;
    while(n &gt; 0) {
      if(n &amp; 1) ret = mul(ret, x);
      x = mul(x, x);
      n &gt;&gt;= 1;
    }
    return ret;
  }

  inline int inverse(int x) {
    return mod_pow(x, mod - 2);
  }

  inline unsigned add(unsigned x, unsigned y) {
    x += y;
    if(x &gt;= mod) x -= mod;
    return x;
  }

  inline unsigned mul(unsigned a, unsigned b) {
    return 1ull * a * b % (unsigned long long) mod;
  }

  void ensure_base(int nbase) {
    if(nbase &lt;= base) return;
    rev.resize(1 &lt;&lt; nbase);
    rts.resize(1 &lt;&lt; nbase);
    for(int i = 0; i &lt; (1 &lt;&lt; nbase); i++) {
      rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) + ((i &amp; 1) &lt;&lt; (nbase - 1));
    }
    assert(nbase &lt;= max_base);
    while(base &lt; nbase) {
      int z = mod_pow(root, 1 &lt;&lt; (max_base - 1 - base));
      for(int i = 1 &lt;&lt; (base - 1); i &lt; (1 &lt;&lt; base); i++) {
        rts[i &lt;&lt; 1] = rts[i];
        rts[(i &lt;&lt; 1) + 1] = mul(rts[i], z);
      }
      ++base;
    }
  }


  void ntt(vector&lt; int &gt; &amp;a) {
    const int n = (int) a.size();
    assert((n &amp; (n - 1)) == 0);
    int zeros = __builtin_ctz(n);
    ensure_base(zeros);
    int shift = base - zeros;
    for(int i = 0; i &lt; n; i++) {
      if(i &lt; (rev[i] &gt;&gt; shift)) {
        swap(a[i], a[rev[i] &gt;&gt; shift]);
      }
    }
    for(int k = 1; k &lt; n; k &lt;&lt;= 1) {
      for(int i = 0; i &lt; n; i += 2 * k) {
        for(int j = 0; j &lt; k; j++) {
          int z = mul(a[i + j + k], rts[j + k]);
          a[i + j + k] = add(a[i + j], mod - z);
          a[i + j] = add(a[i + j], z);
        }
      }
    }
  }


  vector&lt; int &gt; multiply(vector&lt; int &gt; a, vector&lt; int &gt; b) {
    int need = a.size() + b.size() - 1;
    int nbase = 1;
    while((1 &lt;&lt; nbase) &lt; need) nbase++;
    ensure_base(nbase);
    int sz = 1 &lt;&lt; nbase;
    a.resize(sz, 0);
    b.resize(sz, 0);
    ntt(a);
    ntt(b);
    int inv_sz = inverse(sz);
    for(int i = 0; i &lt; sz; i++) {
      a[i] = mul(a[i], mul(b[i], inv_sz));
    }
    reverse(a.begin() + 1, a.end());
    ntt(a);
    a.resize(need);
    return a;
  }
};


##################################################
############# arbitrary-mod-int.cpp ##############
##################################################

struct ArbitraryModInt {

  int x;

  ArbitraryModInt() : x(0) {}

  ArbitraryModInt(int64_t y) : x(y &gt;= 0 ? y % mod() : (mod() - (-y) % mod()) % mod()) {}

  static int &amp;mod() {
    static int mod = 0;
    return mod;
  }

  static int set_mod(int md) {
    mod() = md;
  }

  ArbitraryModInt &amp;operator+=(const ArbitraryModInt &amp;p) {
    if((x += p.x) &gt;= mod()) x -= mod();
    return *this;
  }

  ArbitraryModInt &amp;operator-=(const ArbitraryModInt &amp;p) {
    if((x += mod() - p.x) &gt;= mod()) x -= mod();
    return *this;
  }

  ArbitraryModInt &amp;operator*=(const ArbitraryModInt &amp;p) {
    unsigned long long a = (unsigned long long) x * p.x;
    unsigned xh = (unsigned) (a &gt;&gt; 32), xl = (unsigned) a, d, m;
    asm(&quot;divl %4; \n\t&quot; : &quot;=a&quot; (d), &quot;=d&quot; (m) : &quot;d&quot; (xh), &quot;a&quot; (xl), &quot;r&quot; (mod()));
    x = m;
    return *this;
  }

  ArbitraryModInt &amp;operator/=(const ArbitraryModInt &amp;p) {
    *this *= p.inverse();
    return *this;
  }

  ArbitraryModInt operator-() const { return ArbitraryModInt(-x); }

  ArbitraryModInt operator+(const ArbitraryModInt &amp;p) const { return ArbitraryModInt(*this) += p; }

  ArbitraryModInt operator-(const ArbitraryModInt &amp;p) const { return ArbitraryModInt(*this) -= p; }

  ArbitraryModInt operator*(const ArbitraryModInt &amp;p) const { return ArbitraryModInt(*this) *= p; }

  ArbitraryModInt operator/(const ArbitraryModInt &amp;p) const { return ArbitraryModInt(*this) /= p; }

  bool operator==(const ArbitraryModInt &amp;p) const { return x == p.x; }

  bool operator!=(const ArbitraryModInt &amp;p) const { return x != p.x; }

  ArbitraryModInt inverse() const {
    int a = x, b = mod(), u = 1, v = 0, t;
    while(b &gt; 0) {
      t = a / b;
      swap(a -= t * b, b);
      swap(u -= t * v, v);
    }
    return ArbitraryModInt(u);
  }

  ArbitraryModInt pow(int64_t n) const {
    ArbitraryModInt ret(1), mul(x);
    while(n &gt; 0) {
      if(n &amp; 1) ret *= mul;
      mul *= mul;
      n &gt;&gt;= 1;
    }
    return ret;
  }

  friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const ArbitraryModInt &amp;p) {
    return os &lt;&lt; p.x;
  }

  friend istream &amp;operator&gt;&gt;(istream &amp;is, ArbitraryModInt &amp;a) {
    int64_t t;
    is &gt;&gt; t;
    a = ArbitraryModInt(t);
    return (is);
  }
};


--------------------------------------------------
|                       dp                       |
--------------------------------------------------

##################################################
############ knapsack-limitations.cpp ############
##################################################

template&lt; typename T, typename Compare = greater&lt; T &gt; &gt;
vector&lt; T &gt; knapsack_limitations(const vector&lt; int &gt; &amp;w, const vector&lt; int &gt; &amp;m, const vector&lt; T &gt; &amp;v,
                                 const int &amp;W, const T &amp;NG, const Compare &amp;comp = Compare()) {
  const int N = (int) w.size();
  vector&lt; T &gt; dp(W + 1, NG), deqv(W + 1);
  dp[0] = T();
  vector&lt; int &gt; deq(W + 1);
  for(int i = 0; i &lt; N; i++) {
    for(int a = 0; a &lt; w[i]; a++) {
      int s = 0, t = 0;
      for(int j = 0; w[i] * j + a &lt;= W; j++) {
        if(dp[w[i] * j + a] != NG) {
          auto val = dp[w[i] * j + a] - j * v[i];
          while(s &lt; t &amp;&amp; comp(val, deqv[t - 1])) --t;
          deq[t] = j;
          deqv[t++] = val;
        }
        if(s &lt; t) {
          dp[j * w[i] + a] = deqv[s] + j * v[i];
          if(deq[s] == j - m[i]) ++s;
        }
      }
    }
  }
  return dp;
}


##################################################
############# online-offline-dp.cpp ##############
##################################################

template&lt; typename T, typename Compare = less&lt; T &gt; &gt;
vector&lt; T &gt; online_offline_dp(int W, const function&lt; T(int, int) &gt; &amp;f, const Compare &amp;comp = Compare()) {
  vector&lt; T &gt; dp(W + 1);
  vector&lt; int &gt; isset(W + 1);
  int y_base = -1, x_base = -1;
  function&lt; T(int, int) &gt; get_cost = [&amp;](int y, int x) { // return dp[0, x+x_base)+f[x+x_base, y+y_base)
    return dp[x + x_base] + f(x + x_base, y + y_base);
  };
  function&lt; void(int, int, int) &gt; induce = [&amp;](int l, int m, int r) { // dp[l, m) -&gt; dp[m, r)
    x_base = l, y_base = m;
    auto ret = monotone_minima(r - m, m - l, get_cost, comp);
    for(int i = 0; i &lt; ret.size(); i++) {
      if(!isset[m + i] || comp(ret[i].second, dp[m + i])) {
        isset[m + i] = true;
        dp[m + i] = ret[i].second;
      }
    }
  };
  function&lt; void(int, int) &gt; dfs = [&amp;](int l, int r) {
    if(l + 1 == r) {
      x_base = l, y_base = l;
      T cst = l ? get_cost(0, -1) : 0;
      if(!isset[l] || comp(cst, dp[l])) {
        isset[l] = true;
        dp[l] = cst;
      }
    } else {
      int mid = (l + r) / 2;
      dfs(l, mid);
      induce(l, mid, r);
      dfs(mid, r);
    }
  };
  dfs(0, W + 1);
  return dp;
};


##################################################
############### cumulative-sum.cpp ###############
##################################################

template&lt; class T &gt;
struct CumulativeSum {
  vector&lt; T &gt; data;

  CumulativeSum(int sz) : data(sz, 0) {};

  void add(int k, T x) {
    data[k] += x;
  }

  void build() {
    for(int i = 1; i &lt; data.size(); i++) {
      data[i] += data[i - 1];
    }
  }

  T query(int k) {
    if(k &lt; 0) return (0);
    return (data[min(k, (int) data.size() - 1)]);
  }
};


##################################################
############# cumulative-sum-2d.cpp ##############
##################################################

template&lt; class T &gt;
struct CumulativeSum2D {
  vector&lt; vector&lt; T &gt; &gt; data;

  CumulativeSum2D(int W, int H) : data(W + 1, vector&lt; int &gt;(H + 1, 0)) {}

  void add(int x, int y, T z) {
    ++x, ++y;
    if(x &gt;= data.size() || y &gt;= data[0].size()) return;
    data[x][y] += z;
  }

  void build() {
    for(int i = 1; i &lt; data.size(); i++) {
      for(int j = 1; j &lt; data[i].size(); j++) {
        data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];
      }
    }
  }

  T query(int sx, int sy, int gx, int gy) {
    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);
  }
};


##################################################
############# largest-rectangle.cpp ##############
##################################################

template&lt; typename T &gt;
int64_t largest_rectangle(vector&lt; T &gt; height)
{
  stack&lt; int &gt; st;
  height.push_back(0);
  vector&lt; int &gt; left(height.size());
  int64_t ret = 0;
  for(int i = 0; i &lt; height.size(); i++) {
    while(!st.empty() &amp;&amp; height[st.top()] &gt;= height[i]) {
      ret = max(ret, (int64_t) (i - left[st.top()] - 1) * height[st.top()]);
      st.pop();
    }
    left[i] = st.empty() ? -1 : st.top();
    st.emplace(i);
  }
  return (ret);
}


##################################################
################# slide-min.cpp ##################
##################################################

template&lt; typename T &gt;
vector&lt; T &gt; slide_min(const vector&lt; T &gt; &amp;v, int k)
{
  deque&lt; int &gt; deq;
  vector&lt; T &gt; ret;
  for(int i = 0; i &lt; v.size(); i++) {
    while(!deq.empty() &amp;&amp; v[deq.back()] &gt;= v[i]) {
      deq.pop_back();
    }
    deq.push_back(i);
    if(i - k + 1 &gt;= 0) {
      ret.emplace_back(v[deq.front()]);
      if(deq.front() == i - k + 1) deq.pop_front();
    }
  }
  return ret;
}


##################################################
####### longest-increasing-subsequence.cpp #######
##################################################

template&lt; typename T &gt;
size_t longest_increasing_subsequence(const vector&lt; T &gt; &amp;a, bool strict) {
  vector&lt; T &gt; lis;
  for(auto &amp;p : a) {
    typename vector&lt; T &gt;::iterator it;
    if(strict) it = lower_bound(begin(lis), end(lis), p);
    else it = upper_bound(begin(lis), end(lis), p);
    if(end(lis) == it) lis.emplace_back(p);
    else *it = p;
  }
  return lis.size();
}


##################################################
############## monotone-minima.cpp ###############
##################################################

template&lt; typename T, typename Compare = less&lt; T &gt; &gt;
vector&lt; pair&lt; int, T &gt; &gt; monotone_minima(int H, int W, const function&lt; T(int, int) &gt; &amp;f, const Compare &amp;comp = Compare()) {
  vector&lt; pair&lt; int, T &gt; &gt; dp(H);
  function&lt; void(int, int, int, int) &gt; dfs = [&amp;](int top, int bottom, int left, int right) {
    if(top &gt; bottom) return;
    int line = (top + bottom) / 2;
    T ma;
    int mi = -1;
    for(int i = left; i &lt;= right; i++) {
      T cst = f(line, i);
      if(mi == -1 || comp(cst, ma)) {
        ma = cst;
        mi = i;
      }
    }
    dp[line] = make_pair(mi, ma);
    dfs(top, line - 1, left, mi);
    dfs(line + 1, bottom, mi, right);
  };
  dfs(0, H - 1, 0, W - 1);
  return dp;
}



##################################################
########### knapsack-limitations-2.cpp ###########
##################################################

template&lt; typename T &gt;
T knapsack_limitations(const vector&lt; T &gt; &amp;w, const vector&lt; T &gt; &amp;m, const vector&lt; int &gt; &amp;v,
                       const T &amp;W) {
  const int N = (int) w.size();
  auto v_max = *max_element(begin(v), end(v));
  if(v_max == 0) return 0;
  vector&lt; int &gt; ma(N);
  vector&lt; T &gt; mb(N);
  for(int i = 0; i &lt; N; i++) {
    ma[i] = min&lt; T &gt;(m[i], v_max - 1);
    mb[i] = m[i] - ma[i];
  }
  T sum = 0;
  for(int i = 0; i &lt; N; i++) sum += ma[i] * v[i];
  auto dp = knapsack_limitations(v, ma, w, sum, T(-1), less&lt;&gt;());
  vector&lt; int &gt; ord(N);
  iota(begin(ord), end(ord), 0);
  sort(begin(ord), end(ord), [&amp;](int a, int b) {
    return v[a] * w[b] &gt; v[b] * w[a];
  });
  T ret = T();
  for(int i = 0; i &lt; dp.size(); i++) {
    if(dp[i] &gt; W || dp[i] == -1) continue;
    T rest = W - dp[i], cost = i;
    for(auto &amp;p : ord) {
      auto get = min(mb[p], rest / w[p]);
      if(get == 0) break;
      cost += get * v[p];
      rest -= get * w[p];
    }
    ret = max(ret, cost);
  }
  return ret;
}


##################################################
###### divide-and-conquer-optimization.cpp #######
##################################################

template&lt; typename T, typename Compare = less&lt; T &gt; &gt;
vector&lt; vector&lt; T &gt; &gt; divide_and_conquer_optimization(int H, int W, T INF, const function&lt; T(int, int) &gt; &amp;f, const Compare &amp;comp = Compare()) {
  vector&lt; vector&lt; T &gt; &gt; dp(H + 1, vector&lt; T &gt;(W + 1, INF));
  dp[0][0] = 0;
  for(int i = 1; i &lt;= H; i++) {
    function&lt; T(int, int) &gt; get_cost = [&amp;](int y, int x) {
      if(x &gt;= y) return INF;
      return dp[i - 1][x] + f(x, y);
    };
    auto ret = monotone_minima(W + 1, W + 1, get_cost, comp);
    for(int j = 0; j &lt;= W; j++) dp[i][j] = ret[j].second;
  }
  return dp;
}


##################################################
################# hu-tucker.cpp ##################
##################################################

te&lt; typename Heap, typename T &gt;
T hu_tucker(vector&lt; T &gt; vs, T INF) {
  int N = (int) vs.size();
  Heap heap;
  vector&lt; typename Heap::Node * &gt; hs(N - 1, heap.makeheap());
  vector&lt; int &gt; ls(N), rs(N);
  vector&lt; T &gt; cs(N - 1);
  using pi = pair&lt; T, int &gt;;
  priority_queue&lt; pi, vector&lt; pi &gt;, greater&lt; pi &gt; &gt; que;
  for(int i = 0; i + 1 &lt; N; i++) {
    ls[i] = i - 1;
    rs[i] = i + 1;
    cs[i] = vs[i] + vs[i + 1];
    que.emplace(cs[i], i);
  }
  T ret = 0;
  for(int k = 0; k + 1 &lt; N; k++) {
    T c;
    int i;
    do {
      tie(c, i) = que.top();
      que.pop();
    } while(rs[i] &lt; 0 || cs[i] != c);

    bool ml = false, mr = false;
    if(!heap.empty(hs[i]) &amp;&amp; vs[i] + heap.top(hs[i]) == c) {
      heap.pop(hs[i]);
      ml = true;
    } else if(vs[i] + vs[rs[i]] == c) {
      ml = mr = true;
    } else {
      auto top = heap.pop(hs[i]);
      if(!heap.empty(hs[i]) &amp;&amp; heap.top(hs[i]) + top == c) {
        heap.pop(hs[i]);
      } else {
        mr = true;
      }
    }
    ret += c;
    heap.push(hs[i], c);
    if(ml) vs[i] = INF;
    if(mr) vs[rs[i]] = INF;

    if(ml &amp;&amp; i &gt; 0) {
      int j = ls[i];
      hs[j] = heap.merge(hs[j], hs[i]);
      rs[j] = rs[i];
      rs[i] = -1;
      ls[rs[j]] = j;
      i = j;
    }

    if(mr &amp;&amp; rs[i] + 1 &lt; N) {
      int j = rs[i];
      hs[i] = heap.merge(hs[i], hs[j]);
      rs[i] = rs[j];
      rs[j] = -1;
      ls[rs[i]] = i;
    }
    cs[i] = vs[i] + vs[rs[i]];

    if(!heap.empty(hs[i])) {
      T top = heap.pop(hs[i]);
      cs[i] = min(cs[i], min(vs[i], vs[rs[i]]) + top);
      if(!heap.empty(hs[i])) cs[i] = min(cs[i], top + heap.top(hs[i]));
      heap.push(hs[i], top);
    }
    que.emplace(cs[i], i);
  }
  return ret;
}


--------------------------------------------------
|                     string                     |
--------------------------------------------------

##################################################
################## manacher.cpp ##################
##################################################

vector&lt; int &gt; manacher(const string &amp;s) {
  vector&lt; int &gt; radius(s.size());
  int i = 0, j = 0;
  while(i &lt; s.size()) {
    while(i - j &gt;= 0 &amp;&amp; i + j &lt; s.size() &amp;&amp; s[i - j] == s[i + j]) {
      ++j;
    }
    radius[i] = j;
    int k = 1;
    while(i - k &gt;= 0 &amp;&amp; i + k &lt; s.size() &amp;&amp; k + radius[i - k] &lt; j) {
      radius[i + k] = radius[i - k];
      ++k;
    }
    i += k;
    j -= k;
  }
  return radius;
}


##################################################
################ rolling-hash.cpp ################
##################################################

template&lt; unsigned mod &gt;
struct RollingHash {
  vector&lt; unsigned &gt; hashed, power;

  inline unsigned mul(unsigned a, unsigned b) const {
    unsigned long long x = (unsigned long long) a * b;
    unsigned xh = (unsigned) (x &gt;&gt; 32), xl = (unsigned) x, d, m;
    asm(&quot;divl %4; \n\t&quot; : &quot;=a&quot; (d), &quot;=d&quot; (m) : &quot;d&quot; (xh), &quot;a&quot; (xl), &quot;r&quot; (mod));
    return m;
  }

  RollingHash(const string &amp;s, unsigned base = 10007) {
    int sz = (int) s.size();
    hashed.assign(sz + 1, 0);
    power.assign(sz + 1, 0);
    power[0] = 1;
    for(int i = 0; i &lt; sz; i++) {
      power[i + 1] = mul(power[i], base);
      hashed[i + 1] = mul(hashed[i], base) + s[i];
      if(hashed[i + 1] &gt;= mod) hashed[i + 1] -= mod;
    }
  }

  unsigned get(int l, int r) const {
    unsigned ret = hashed[r] + mod - mul(hashed[l], power[r - l]);
    if(ret &gt;= mod) ret -= mod;
    return ret;
  }

  unsigned connect(unsigned h1, int h2, int h2len) const {
    unsigned ret = mul(h1, power[h2len]) + h2;
    if(ret &gt;= mod) ret -= mod;
    return ret;
  }

  int LCP(const RollingHash&lt; mod &gt; &amp;b, int l1, int r1, int l2, int r2) {
    int len = min(r1 - l1, r2 - l2);
    int low = -1, high = len + 1;
    while(high - low &gt; 1) {
      int mid = (low + high) / 2;
      if(get(l1, l1 + mid) == b.get(l2, l2 + mid)) low = mid;
      else high = mid;
    }
    return (low);
  }
};

using RH = RollingHash&lt; 1000000007 &gt;;


##################################################
################ aho-corasick.cpp ################
##################################################

template&lt; int char_size, int margin &gt;
struct AhoCorasick : Trie&lt; char_size + 1, margin &gt; {
  using Trie&lt; char_size + 1, margin &gt;::Trie;

  const int FAIL = char_size;
  vector&lt; int &gt; correct;

  void build(bool heavy = true) {
    correct.resize(this-&gt;size());
    for(int i = 0; i &lt; this-&gt;size(); i++) {
      correct[i] = (int) this-&gt;nodes[i].accept.size();
    }
    queue&lt; int &gt; que;
    for(int i = 0; i &lt;= char_size; i++) {
      if(~this-&gt;nodes[0].nxt[i]) {
        this-&gt;nodes[this-&gt;nodes[0].nxt[i]].nxt[FAIL] = 0;
        que.emplace(this-&gt;nodes[0].nxt[i]);
      } else {
        this-&gt;nodes[0].nxt[i] = 0;
      }
    }
    while(!que.empty()) {
      auto &amp;now = this-&gt;nodes[que.front()];
      int fail = now.nxt[FAIL];
      correct[que.front()] += correct[fail];
      que.pop();
      for(int i = 0; i &lt; char_size; i++) {
        if(~now.nxt[i]) {
          this-&gt;nodes[now.nxt[i]].nxt[FAIL] = this-&gt;nodes[fail].nxt[i];
          if(heavy) {
            auto &amp;u = this-&gt;nodes[now.nxt[i]].accept;
            auto &amp;v = this-&gt;nodes[this-&gt;nodes[fail].nxt[i]].accept;
            vector&lt; int &gt; accept;
            set_union(begin(u), end(u), begin(v), end(v), back_inserter(accept));
            u = accept;
          }
          que.emplace(now.nxt[i]);
        } else {
          now.nxt[i] = this-&gt;nodes[fail].nxt[i];
        }
      }
    }
  }

  map&lt; int, int &gt; match(const string &amp;str, int now = 0) {
    map&lt; int, int &gt; result;
    for(auto &amp;c : str) {
      now = this-&gt;nodes[now].nxt[c - margin];
      for(auto &amp;v : this-&gt;nodes[now].accept) result[v] += 1;
    }
    return result;
  }

  pair&lt; int64_t, int &gt; move(const char &amp;c, int now = 0) {
    now = this-&gt;nodes[now].nxt[c - margin];
    return {correct[now], now};
  }

  pair&lt; int64_t, int &gt; move(const string &amp;str, int now = 0) {
    int64_t sum = 0;
    for(auto &amp;c : str) {
      auto nxt = move(c, now);
      sum += nxt.first;
      now = nxt.second;
    }
    return {sum, now};
  }
};


##################################################
################ suffix-array.cpp ################
##################################################

struct SuffixArray {
  vector&lt; int &gt; SA;
  const string s;

  SuffixArray(const string &amp;str) : s(str) {
    SA.resize(s.size());
    iota(begin(SA), end(SA), 0);
    sort(begin(SA), end(SA), [&amp;](int a, int b) {
      return s[a] == s[b] ? a &gt; b : s[a] &lt; s[b];
    });
    vector&lt; int &gt; classes(s.size()), c(s.begin(), s.end()), cnt(s.size());
    for(int len = 1; len &lt; s.size(); len &lt;&lt;= 1) {
      for(int i = 0; i &lt; s.size(); i++) {
        if(i &gt; 0 &amp;&amp; c[SA[i - 1]] == c[SA[i]] &amp;&amp; SA[i - 1] + len &lt; s.size() &amp;&amp; c[SA[i - 1] + len / 2] == c[SA[i] + len / 2]) {
          classes[SA[i]] = classes[SA[i - 1]];
        } else {
          classes[SA[i]] = i;
        }
      }
      iota(begin(cnt), end(cnt), 0);
      copy(begin(SA), end(SA), begin(c));
      for(int i = 0; i &lt; s.size(); i++) {
        int s1 = c[i] - len;
        if(s1 &gt;= 0) SA[cnt[classes[s1]]++] = s1;
      }
      classes.swap(c);
    }
  }

  int operator[](int k) const {
    return SA[k];
  }

  size_t size() const {
    return s.size();
  }

  bool lt_substr(const string &amp;t, int si = 0, int ti = 0) {
    int sn = (int) s.size(), tn = (int) t.size();
    while(si &lt; sn &amp;&amp; ti &lt; tn) {
      if(s[si] &lt; t[ti]) return true;
      if(s[si] &gt; t[ti]) return false;
      ++si, ++ti;
    }
    return si &gt;= sn &amp;&amp; ti &lt; tn;
  }

  int lower_bound(const string &amp;t) {
    int low = -1, high = (int) SA.size();
    while(high - low &gt; 1) {
      int mid = (low + high) / 2;
      if(lt_substr(t, SA[mid])) low = mid;
      else high = mid;
    }
    return high;
  }

  pair&lt; int, int &gt; lower_upper_bound(string &amp;t) {
    int idx = lower_bound(t);
    int low = idx - 1, high = (int) SA.size();
    t.back()++;
    while(high - low &gt; 1) {
      int mid = (low + high) / 2;
      if(lt_substr(t, SA[mid])) low = mid;
      else high = mid;
    }
    t.back()--;
    return {idx, high};
  }

  void output() {
    for(int i = 0; i &lt; size(); i++) {
      cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; s.substr(SA[i]) &lt;&lt; endl;
    }
  }
};


##################################################
######## longest-common-prefix-array.cpp #########
##################################################

struct LongestCommonPrefixArray {
  const SuffixArray &amp;SA;
  vector&lt; int &gt; LCP, rank;

  LongestCommonPrefixArray(const SuffixArray &amp;SA) : SA(SA), LCP(SA.size()) {
    rank.resize(SA.size());
    for(int i = 0; i &lt; SA.size(); i++) {
      rank[SA[i]] = i;
    }
    for(int i = 0, h = 0; i &lt; SA.size(); i++) {
      if(rank[i] + 1 &lt; SA.size()) {
        for(int j = SA[rank[i] + 1]; max(i, j) + h &lt; SA.size() &amp;&amp; SA.s[i + h] == SA.s[j + h]; ++h);
        LCP[rank[i] + 1] = h;
        if(h &gt; 0) --h;
      }
    }
  }

  int operator[](int k) const {
    return LCP[k];
  }

  size_t size() const {
    return LCP.size();
  }

  void output() {
    for(int i = 0; i &lt; size(); i++) {
      cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; LCP[i] &lt;&lt; &quot; &quot; &lt;&lt; SA.s.substr(SA[i]) &lt;&lt; endl;
    }
  }
};


##################################################
################ z-algorithm.cpp #################
##################################################

vector&lt; int &gt; z_algorithm(const string &amp;s) {
  vector&lt; int &gt; prefix(s.size());
  for(int i = 1, j = 0; i &lt; s.size(); i++) {
    if(i + prefix[i - j] &lt; j + prefix[j]) {
      prefix[i] = prefix[i - j];
    } else {
      int k = max(0, j + prefix[j] - i);
      while(i + k &lt; s.size() &amp;&amp; s[k] == s[i + k]) ++k;
      prefix[i] = k;
      j = i;
    }
  }
  prefix[0] = (int) s.size();
  return prefix;
}


--------------------------------------------------
|                    geometry                    |
--------------------------------------------------

##################################################
################## template.cpp ##################
##################################################

using Real = double;
using Point = complex&lt; Real &gt;;
const Real EPS = 1e-8, PI = acos(-1);

inline bool eq(Real a, Real b) { return fabs(b - a) &lt; EPS; }

Point operator*(const Point &amp;p, const Real &amp;d) {
  return Point(real(p) * d, imag(p) * d);
}

istream &amp;operator&gt;&gt;(istream &amp;is, Point &amp;p) {
  Real a, b;
  is &gt;&gt; a &gt;&gt; b;
  p = Point(a, b);
  return is;
}

ostream &amp;operator&lt;&lt;(ostream &amp;os, Point &amp;p) {
  return os &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; p.real() &lt;&lt; &quot; &quot; &lt;&lt; p.imag();
}

// rotate point p counterclockwise by theta rad
Point rotate(Real theta, const Point &amp;p) {
  return Point(cos(theta) * p.real() - sin(theta) * p.imag(), sin(theta) * p.real() + cos(theta) * p.imag());
}

Real radian_to_degree(Real r) {
  return (r * 180.0 / PI);
}

Real degree_to_radian(Real d) {
  return (d * PI / 180.0);
}

// smaller angle of the a-b-c
Real get_angle(const Point &amp;a, const Point &amp;b, const Point &amp;c) {
  const Point v(b - a), w(c - b);
  Real alpha = atan2(v.imag(), v.real()), beta = atan2(w.imag(), w.real());
  if(alpha &gt; beta) swap(alpha, beta);
  Real theta = (beta - alpha);
  return min(theta, 2 * acos(-1) - theta);
}

namespace std {
  bool operator&lt;(const Point &amp;a, const Point &amp;b) {
    return a.real() != b.real() ? a.real() &lt; b.real() : a.imag() &lt; b.imag();
  }
}


struct Line {
  Point a, b;

  Line() = default;

  Line(Point a, Point b) : a(a), b(b) {}

  Line(Real A, Real B, Real C) // Ax + By = C
  {
    if(eq(A, 0)) a = Point(0, C / B), b = Point(1, C / B);
    else if(eq(B, 0)) b = Point(C / A, 0), b = Point(C / A, 1);
    else a = Point(0, C / B), b = Point(C / A, 0);
  }

  friend ostream &amp;operator&lt;&lt;(ostream &amp;os, Line &amp;p) {
    return os &lt;&lt; p.a &lt;&lt; &quot; to &quot; &lt;&lt; p.b;
  }

  friend istream &amp;operator&gt;&gt;(istream &amp;is, Line &amp;a) {
    return is &gt;&gt; a.a &gt;&gt; a.b;
  }
};

struct Segment : Line {
  Segment() = default;

  Segment(Point a, Point b) : Line(a, b) {}
};

struct Circle {
  Point p;
  Real r;

  Circle() = default;

  Circle(Point p, Real r) : p(p), r(r) {}
};

using Points = vector&lt; Point &gt;;
using Polygon = vector&lt; Point &gt;;
using Segments = vector&lt; Segment &gt;;
using Lines = vector&lt; Line &gt;;
using Circles = vector&lt; Circle &gt;;

Real cross(const Point &amp;a, const Point &amp;b) {
  return real(a) * imag(b) - imag(a) * real(b);
}

Real dot(const Point &amp;a, const Point &amp;b) {
  return real(a) * real(b) + imag(a) * imag(b);
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C
int ccw(const Point &amp;a, Point b, Point c) {
  b = b - a, c = c - a;
  if(cross(b, c) &gt; EPS) return +1;  // &quot;COUNTER_CLOCKWISE&quot;
  if(cross(b, c) &lt; -EPS) return -1; // &quot;CLOCKWISE&quot;
  if(dot(b, c) &lt; 0) return +2;      // &quot;ONLINE_BACK&quot; c-a-b
  if(norm(b) &lt; norm(c)) return -2;  // &quot;ONLINE_FRONT&quot; a-b-c
  return 0;                         // &quot;ON_SEGMENT&quot; a-c-b
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A
bool parallel(const Line &amp;a, const Line &amp;b) {
  return eq(cross(a.b - a.a, b.b - b.a), 0.0);
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_A
bool orthogonal(const Line &amp;a, const Line &amp;b) {
  return eq(dot(a.a - a.b, b.a - b.b), 0.0);
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_A
Point projection(const Line &amp;l, const Point &amp;p) {
  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);
  return l.a + (l.a - l.b) * t;
}

Point projection(const Segment &amp;l, const Point &amp;p) {
  double t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);
  return l.a + (l.a - l.b) * t;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_B
Point reflection(const Line &amp;l, const Point &amp;p) {
  return p + (projection(l, p) - p) * 2.0;
}

bool intersect(const Line &amp;l, const Point &amp;p) {
  return abs(ccw(l.a, l.b, p)) != 1;
}

bool intersect(const Line &amp;l, const Line &amp;m) {
  return abs(cross(l.b - l.a, m.b - m.a)) &gt; EPS || abs(cross(l.b - l.a, m.b - l.a)) &lt; EPS;
}

bool intersect(const Segment &amp;s, const Point &amp;p) {
  return ccw(s.a, s.b, p) == 0;
}

bool intersect(const Line &amp;l, const Segment &amp;s) {
  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) &lt; EPS;
}

Real distance(const Line &amp;l, const Point &amp;p);

bool intersect(const Circle &amp;c, const Line &amp;l) {
  return distance(l, c.p) &lt;= c.r + EPS;
}

bool intersect(const Circle &amp;c, const Point &amp;p) {
  return abs(abs(p - c.p) - c.r) &lt; EPS;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_B
bool intersect(const Segment &amp;s, const Segment &amp;t) {
  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) &lt;= 0 &amp;&amp; ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) &lt;= 0;
}

int intersect(const Circle &amp;c, const Segment &amp;l) {
  if(norm(projection(l, c.p) - c.p) - c.r * c.r &gt; EPS) return 0;
  auto d1 = abs(c.p - l.a), d2 = abs(c.p - l.b);
  if(d1 &lt; c.r + EPS &amp;&amp; d2 &lt; c.r + EPS) return 0;
  if(d1 &lt; c.r - EPS &amp;&amp; d2 &gt; c.r + EPS || d1 &gt; c.r + EPS &amp;&amp; d2 &lt; c.r - EPS) return 1;
  const Point h = projection(l, c.p);
  if(dot(l.a - h, l.b - h) &lt; 0) return 2;
  return 0;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_A&amp;lang=jp
int intersect(Circle c1, Circle c2) {
  if(c1.r &lt; c2.r) swap(c1, c2);
  Real d = abs(c1.p - c2.p);
  if(c1.r + c2.r &lt; d) return 4;
  if(eq(c1.r + c2.r, d)) return 3;
  if(c1.r - c2.r &lt; d) return 2;
  if(eq(c1.r - c2.r, d)) return 1;
  return 0;
}

Real distance(const Point &amp;a, const Point &amp;b) {
  return abs(a - b);
}

Real distance(const Line &amp;l, const Point &amp;p) {
  return abs(p - projection(l, p));
}

Real distance(const Line &amp;l, const Line &amp;m) {
  return intersect(l, m) ? 0 : distance(l, m.a);
}

Real distance(const Segment &amp;s, const Point &amp;p) {
  Point r = projection(s, p);
  if(intersect(s, r)) return abs(r - p);
  return min(abs(s.a - p), abs(s.b - p));
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_D
Real distance(const Segment &amp;a, const Segment &amp;b) {
  if(intersect(a, b)) return 0;
  return min({distance(a, b.a), distance(a, b.b), distance(b, a.a), distance(b, a.b)});
}

Real distance(const Line &amp;l, const Segment &amp;s) {
  if(intersect(l, s)) return 0;
  return min(distance(l, s.a), distance(l, s.b));
}

Point crosspoint(const Line &amp;l, const Line &amp;m) {
  Real A = cross(l.b - l.a, m.b - m.a);
  Real B = cross(l.b - l.a, l.b - m.a);
  if(eq(abs(A), 0.0) &amp;&amp; eq(abs(B), 0.0)) return m.a;
  return m.a + (m.b - m.a) * B / A;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_2_C
Point crosspoint(const Segment &amp;l, const Segment &amp;m) {
  return crosspoint(Line(l), Line(m));
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_D
pair&lt; Point, Point &gt; crosspoint(const Circle &amp;c, const Line l) {
  Point pr = projection(l, c.p);
  Point e = (l.b - l.a) / abs(l.b - l.a);
  if(eq(distance(l, c.p), c.r)) return {pr, pr};
  double base = sqrt(c.r * c.r - norm(pr - c.p));
  return {pr - e * base, pr + e * base};
}

pair&lt; Point, Point &gt; crosspoint(const Circle &amp;c, const Segment &amp;l) {
  Line aa = Line(l.a, l.b);
  if(intersect(c, l) == 2) return crosspoint(c, aa);
  auto ret = crosspoint(c, aa);
  if(dot(l.a - ret.first, l.b - ret.first) &lt; 0) ret.second = ret.first;
  else ret.first = ret.second;
  return ret;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_E
pair&lt; Point, Point &gt; crosspoint(const Circle &amp;c1, const Circle &amp;c2) {
  Real d = abs(c1.p - c2.p);
  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));
  Real t = atan2(c2.p.imag() - c1.p.imag(), c2.p.real() - c1.p.real());
  Point p1 = c1.p + Point(cos(t + a) * c1.r, sin(t + a) * c1.r);
  Point p2 = c1.p + Point(cos(t - a) * c1.r, sin(t - a) * c1.r);
  return {p1, p2};
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_F
// tangent of circle c through point p
pair&lt; Point, Point &gt; tangent(const Circle &amp;c1, const Point &amp;p2) {
  return crosspoint(c1, Circle(p2, sqrt(norm(c1.p - p2) - c1.r * c1.r)));
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_G
// common tangent of circles c1 and c2
Lines tangent(Circle c1, Circle c2) {
  Lines ret;
  if(c1.r &lt; c2.r) swap(c1, c2);
  Real g = norm(c1.p - c2.p);
  if(eq(g, 0)) return ret;
  Point u = (c2.p - c1.p) / sqrt(g);
  Point v = rotate(PI * 0.5, u);
  for(int s : {-1, 1}) {
    Real h = (c1.r + s * c2.r) / sqrt(g);
    if(eq(1 - h * h, 0)) {
      ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);
    } else if(1 - h * h &gt; 0) {
      Point uu = u * h, vv = v * sqrt(1 - h * h);
      ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);
      ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);
    }
  }
  return ret;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_B
bool is_convex(const Polygon &amp;p) {
  int n = (int) p.size();
  for(int i = 0; i &lt; n; i++) {
    if(ccw(p[(i + n - 1) % n], p[i], p[(i + 1) % n]) == -1) return false;
  }
  return true;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_A
Polygon convex_hull(Polygon &amp;p) {
  int n = (int) p.size(), k = 0;
  if(n &lt;= 2) return p;
  sort(p.begin(), p.end());
  vector&lt; Point &gt; ch(2 * n);
  for(int i = 0; i &lt; n; ch[k++] = p[i++]) {
    while(k &gt;= 2 &amp;&amp; cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) &lt; EPS) --k;
  }
  for(int i = n - 2, t = k + 1; i &gt;= 0; ch[k++] = p[i--]) {
    while(k &gt;= t &amp;&amp; cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) &lt; EPS) --k;
  }
  ch.resize(k - 1);
  return ch;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_C
enum {
  OUT, ON, IN
};

int contains(const Polygon &amp;Q, const Point &amp;p) {
  bool in = false;
  for(int i = 0; i &lt; Q.size(); i++) {
    Point a = Q[i] - p, b = Q[(i + 1) % Q.size()] - p;
    if(a.imag() &gt; b.imag()) swap(a, b);
    if(a.imag() &lt;= 0 &amp;&amp; 0 &lt; b.imag() &amp;&amp; cross(a, b) &lt; 0) in = !in;
    if(cross(a, b) == 0 &amp;&amp; dot(a, b) &lt;= 0) return ON;
  }
  return in ? IN : OUT;
}


// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033
// deduplication of line segments
void merge_segments(vector&lt; Segment &gt; &amp;segs) {

  auto merge_if_able = [](Segment &amp;s1, const Segment &amp;s2) {
    if(abs(cross(s1.b - s1.a, s2.b - s2.a)) &gt; EPS) return false;
    if(ccw(s1.a, s2.a, s1.b) == 1 || ccw(s1.a, s2.a, s1.b) == -1) return false;
    if(ccw(s1.a, s1.b, s2.a) == -2 || ccw(s2.a, s2.b, s1.a) == -2) return false;
    s1 = Segment(min(s1.a, s2.a), max(s1.b, s2.b));
    return true;
  };

  for(int i = 0; i &lt; segs.size(); i++) {
    if(segs[i].b &lt; segs[i].a) swap(segs[i].a, segs[i].b);
  }
  for(int i = 0; i &lt; segs.size(); i++) {
    for(int j = i + 1; j &lt; segs.size(); j++) {
      if(merge_if_able(segs[i], segs[j])) {
        segs[j--] = segs.back(), segs.pop_back();
      }
    }
  }
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1033
// construct a graph with the vertex of the intersection of any two line segments
vector&lt; vector&lt; int &gt; &gt; segment_arrangement(vector&lt; Segment &gt; &amp;segs, vector&lt; Point &gt; &amp;ps) {
  vector&lt; vector&lt; int &gt; &gt; g;
  int N = (int) segs.size();
  for(int i = 0; i &lt; N; i++) {
    ps.emplace_back(segs[i].a);
    ps.emplace_back(segs[i].b);
    for(int j = i + 1; j &lt; N; j++) {
      const Point p1 = segs[i].b - segs[i].a;
      const Point p2 = segs[j].b - segs[j].a;
      if(cross(p1, p2) == 0) continue;
      if(intersect(segs[i], segs[j])) {
        ps.emplace_back(crosspoint(segs[i], segs[j]));
      }
    }
  }
  sort(begin(ps), end(ps));
  ps.erase(unique(begin(ps), end(ps)), end(ps));

  int M = (int) ps.size();
  g.resize(M);
  for(int i = 0; i &lt; N; i++) {
    vector&lt; int &gt; vec;
    for(int j = 0; j &lt; M; j++) {
      if(intersect(segs[i], ps[j])) {
        vec.emplace_back(j);
      }
    }
    for(int j = 1; j &lt; vec.size(); j++) {
      g[vec[j - 1]].push_back(vec[j]);
      g[vec[j]].push_back(vec[j - 1]);
    }
  }
  return (g);
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C
// cut with a straight line l and return a convex polygon on the left
Polygon convex_cut(const Polygon &amp;U, Line l) {
  Polygon ret;
  for(int i = 0; i &lt; U.size(); i++) {
    Point now = U[i], nxt = U[(i + 1) % U.size()];
    if(ccw(l.a, l.b, now) != -1) ret.push_back(now);
    if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) &lt; 0) {
      ret.push_back(crosspoint(Line(now, nxt), l));
    }
  }
  return (ret);
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_3_A
Real area(const Polygon &amp;p) {
  Real A = 0;
  for(int i = 0; i &lt; p.size(); ++i) {
    A += cross(p[i], p[(i + 1) % p.size()]);
  }
  return A * 0.5;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_7_H
Real area(const Polygon &amp;p, const Circle &amp;c) {
  if(p.size() &lt; 3) return 0.0;
  function&lt; Real(Circle, Point, Point) &gt; cross_area = [&amp;](const Circle &amp;c, const Point &amp;a, const Point &amp;b) {
    Point va = c.p - a, vb = c.p - b;
    Real f = cross(va, vb), ret = 0.0;
    if(eq(f, 0.0)) return ret;
    if(max(abs(va), abs(vb)) &lt; c.r + EPS) return f;
    if(distance(Segment(a, b), c.p) &gt; c.r - EPS) return c.r * c.r * arg(vb * conj(va));
    auto u = crosspoint(c, Segment(a, b));
    vector&lt; Point &gt; tot{a, u.first, u.second, b};
    for(int i = 0; i + 1 &lt; tot.size(); i++) {
      ret += cross_area(c, tot[i], tot[i + 1]);
    }
    return ret;
  };
  Real A = 0;
  for(int i = 0; i &lt; p.size(); i++) {
    A += cross_area(c, p[i], p[(i + 1) % p.size()]);
  }
  return A;
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_B
Real convex_diameter(const Polygon &amp;p) {
  int N = (int) p.size();
  int is = 0, js = 0;
  for(int i = 1; i &lt; N; i++) {
    if(p[i].imag() &gt; p[is].imag()) is = i;
    if(p[i].imag() &lt; p[js].imag()) js = i;
  }
  Real maxdis = norm(p[is] - p[js]);

  int maxi, maxj, i, j;
  i = maxi = is;
  j = maxj = js;
  do {
    if(cross(p[(i + 1) % N] - p[i], p[(j + 1) % N] - p[j]) &gt;= 0) {
      j = (j + 1) % N;
    } else {
      i = (i + 1) % N;
    }
    if(norm(p[i] - p[j]) &gt; maxdis) {
      maxdis = norm(p[i] - p[j]);
      maxi = i;
      maxj = j;
    }
  } while(i != is || j != js);
  return sqrt(maxdis);
}

// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_5_A
Real closest_pair(Points ps) {
  if(ps.size() &lt;= 1) throw (0);
  sort(begin(ps), end(ps));

  auto compare_y = [&amp;](const Point &amp;a, const Point &amp;b) {
    return imag(a) &lt; imag(b);
  };
  vector&lt; Point &gt; beet(ps.size());
  const Real INF = 1e18;

  function&lt; Real(int, int) &gt; rec = [&amp;](int left, int right) {
    if(right - left &lt;= 1) return INF;
    int mid = (left + right) &gt;&gt; 1;
    auto x = real(ps[mid]);
    auto ret = min(rec(left, mid), rec(mid, right));
    inplace_merge(begin(ps) + left, begin(ps) + mid, begin(ps) + right, compare_y);
    int ptr = 0;
    for(int i = left; i &lt; right; i++) {
      if(abs(real(ps[i]) - x) &gt;= ret) continue;
      for(int j = 0; j &lt; ptr; j++) {
        auto luz = ps[i] - beet[ptr - j - 1];
        if(imag(luz) &gt;= ret) break;
        ret = min(ret, abs(luz));
      }
      beet[ptr++] = ps[i];
    }
    return ret;
  };
  return rec(0, (int) ps.size());
}


--------------------------------------------------
|                   structure                    |
--------------------------------------------------

##################################################
####### convex-hull-trick-add-monotone.cpp #######
##################################################

template&lt; typename T, bool isMin &gt;
struct ConvexHullTrickAddMonotone {
#define F first
#define S second
  using P = pair&lt; T, T &gt;;
  deque&lt; P &gt; H;

  ConvexHullTrickAddMonotone() = default;

  bool empty() const { return H.empty(); }

  void clear() { H.clear(); }

  inline int sgn(T x) { return x == 0 ? 0 : (x &lt; 0 ? -1 : 1); }

  using D = long double;

  inline bool check(const P &amp;a, const P &amp;b, const P &amp;c) {
    if(b.S == a.S || c.S == b.S)
      return sgn(b.F - a.F) * sgn(c.S - b.S) &gt;= sgn(c.F - b.F) * sgn(b.S - a.S);

    //return (b.F-a.F)*(c.S-b.S) &gt;= (b.S-a.S)*(c.F-b.F);
    return
        D(b.F - a.F) * sgn(c.S - b.S) / D(abs(b.S - a.S)) &gt;=
        D(c.F - b.F) * sgn(b.S - a.S) / D(abs(c.S - b.S));
  }

  void add(T a, T b) {
    if(!isMin) a *= -1, b *= -1;
    P line(a, b);
    if(empty()) {
      H.emplace_front(line);
      return;
    }
    if(H.front().F &lt;= a) {
      if(H.front().F == a) {
        if(H.front().S &lt;= b) return;
        H.pop_front();
      }
      while(H.size() &gt;= 2 &amp;&amp; check(line, H.front(), H[1])) H.pop_front();
      H.emplace_front(line);
    } else {
      assert(a &lt;= H.back().F);
      if(H.back().F == a) {
        if(H.back().S &lt;= b) return;
        H.pop_back();
      }
      while(H.size() &gt;= 2 &amp;&amp; check(H[H.size() - 2], H.back(), line)) H.pop_back();
      H.emplace_back(line);
    }
  }

  inline T get_y(const P &amp;a, const T &amp;x) {
    return a.F * x + a.S;
  }

  T query(T x) {
    assert(!empty());
    int l = -1, r = H.size() - 1;
    while(l + 1 &lt; r) {
      int m = (l + r) &gt;&gt; 1;
      if(get_y(H[m], x) &gt;= get_y(H[m + 1], x)) l = m;
      else r = m;
    }
    if(isMin) return get_y(H[r], x);
    return -get_y(H[r], x);
  }

  T query_monotone_inc(T x) {
    assert(!empty());
    while(H.size() &gt;= 2 &amp;&amp; get_y(H.front(), x) &gt;= get_y(H[1], x)) H.pop_front();
    if(isMin) return get_y(H.front(), x);
    return -get_y(H.front(), x);
  }

  T query_monotone_dec(T x) {
    assert(!empty());
    while(H.size() &gt;= 2 &amp;&amp; get_y(H.back(), x) &gt;= get_y(H[H.size() - 2], x)) H.pop_back();
    if(isMin) return get_y(H.back(), x);
    return -get_y(H.back(), x);
  }

#undef F
#undef S
};


##################################################
################# skew-heap.cpp ##################
##################################################

template&lt; typename T, typename E = T &gt;
struct SkewHeap {
  using G = function&lt; T(T, E) &gt;;
  using H = function&lt; E(E, E) &gt;;

  struct Node {
    T key;
    E lazy;
    Node *l, *r;
  };

  const bool rev;
  const G g;
  const H h;

  SkewHeap(bool rev = false) : g([](const T &amp;a, const E &amp;b) { return a + b; }),
                               h([](const E &amp;a, const E &amp;b) { return a + b; }), rev(rev) {}

  SkewHeap(const G &amp;g, const H &amp;h, bool rev = false) : g(g), h(h), rev(rev) {}

  Node *propagate(Node *t) {
    if(t-&gt;lazy != 0) {
      if(t-&gt;l) t-&gt;l-&gt;lazy = h(t-&gt;l-&gt;lazy, t-&gt;lazy);
      if(t-&gt;r) t-&gt;r-&gt;lazy = h(t-&gt;r-&gt;lazy, t-&gt;lazy);
      t-&gt;key = g(t-&gt;key, t-&gt;lazy);
      t-&gt;lazy = 0;
    }
    return t;
  }

  Node *merge(Node *x, Node *y) {
    if(!x || !y) return x ? x : y;
    propagate(x), propagate(y);
    if((x-&gt;key &gt; y-&gt;key) ^ rev) swap(x, y);
    x-&gt;r = merge(y, x-&gt;r);
    swap(x-&gt;l, x-&gt;r);
    return x;
  }

  void push(Node *&amp;root, const T &amp;key) {
    root = merge(root, new Node({key, 0, nullptr, nullptr}));
  }

  T top(Node *root) {
    return propagate(root)-&gt;key;
  }

  T pop(Node *&amp;root) {
    T top = propagate(root)-&gt;key;
    auto *temp = root;
    root = merge(root-&gt;l, root-&gt;r);
    delete temp;
    return top;
  }

  bool empty(Node *root) const {
    return !root;
  }

  void add(Node *root, const E &amp;lazy) {
    if(root) {
      root-&gt;lazy = h(root-&gt;lazy, lazy);
      propagate(root);
    }
  }

  Node *makeheap() {
    return nullptr;
  }
};


##################################################
############# segment-tree-2d-2.cpp ##############
##################################################

template&lt; typename structure_t, typename get_t, typename update_t &gt;
struct SegmentTree2D {
  using merge_f = function&lt; get_t(get_t, get_t) &gt;;
  using get_t = function&lt; get_t(structure_t &amp;, int) &gt;;
  using range_update_f = function&lt; get_t(structure_t &amp;, int, int, update_t) &gt;;

  int sz;
  vector&lt; structure_t &gt; seg;
  const merge_f &amp;f;
  const get_t &amp;g;
  const range_update_f &amp;h;

  SegmentTree2D(int n, const merge_f &amp;f, const get_t &amp;g, const range_update_f &amp;h) : f(f), g(g), h(h) {
    sz = 1;
    while(sz &lt; n) sz &lt;&lt;= 1;
    seg.resize(2 * sz - 1);
  }

  void update(int a, int b, int lower, int upper, update_t x, int k, int l, int r) {
    if(r &lt;= a || b &lt;= l) {
      return;
    } else if(a &lt;= l &amp;&amp; r &lt;= b) {
      g(seg[k], lower, upper, x);
    } else {
      update(a, b, lower, upper, x, 2 * k + 1, l, (l + r) &gt;&gt; 1);
      update(a, b, lower, upper, x, 2 * k + 2, (l + r) &gt;&gt; 1, r);
    }
  }

  void update(int a, int b, int l, int r, update_t x) {
    update(a, b, l, r, x, 0, 0, sz);
  }

  get_t get(int x, int y) {
    x += sz - 1;
    get_t ret = g(seg[x], y);
    while(x &gt; 0) {
      x = (x - 1) &gt;&gt; 1;
      ret = f(ret, g(seg[x], y));
    }
  }
};


##################################################
############# lazy-segment-tree.cpp ##############
##################################################

template&lt; typename Monoid, typename OperatorMonoid = Monoid &gt;
struct LazySegmentTree {
  using F = function&lt; Monoid(Monoid, Monoid) &gt;;
  using G = function&lt; Monoid(Monoid, OperatorMonoid) &gt;;
  using H = function&lt; OperatorMonoid(OperatorMonoid, OperatorMonoid) &gt;;

  int sz, height;
  vector&lt; Monoid &gt; data;
  vector&lt; OperatorMonoid &gt; lazy;
  const F f;
  const G g;
  const H h;
  const Monoid M1;
  const OperatorMonoid OM0;


  LazySegmentTree(int n, const F f, const G g, const H h,
                  const Monoid &amp;M1, const OperatorMonoid OM0)
      : f(f), g(g), h(h), M1(M1), OM0(OM0) {
    sz = 1;
    height = 0;
    while(sz &lt; n) sz &lt;&lt;= 1, height++;
    data.assign(2 * sz, M1);
    lazy.assign(2 * sz, OM0);
  }

  void set(int k, const Monoid &amp;x) {
    data[k + sz] = x;
  }

  void build() {
    for(int k = sz - 1; k &gt; 0; k--) {
      data[k] = f(data[2 * k + 0], data[2 * k + 1]);
    }
  }

  inline void propagate(int k) {
    if(lazy[k] != OM0) {
      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);
      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);
      data[k] = reflect(k);
      lazy[k] = OM0;
    }
  }

  inline Monoid reflect(int k) {
    return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);
  }

  inline void recalc(int k) {
    while(k &gt;&gt;= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));
  }

  inline void thrust(int k) {
    for(int i = height; i &gt; 0; i--) propagate(k &gt;&gt; i);
  }

  void update(int a, int b, const OperatorMonoid &amp;x) {
    thrust(a += sz);
    thrust(b += sz - 1);
    for(int l = a, r = b + 1; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if(l &amp; 1) lazy[l] = h(lazy[l], x), ++l;
      if(r &amp; 1) --r, lazy[r] = h(lazy[r], x);
    }
    recalc(a);
    recalc(b);
  }

  Monoid query(int a, int b) {
    thrust(a += sz);
    thrust(b += sz - 1);
    Monoid L = M1, R = M1;
    for(int l = a, r = b + 1; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if(l &amp; 1) L = f(L, reflect(l++));
      if(r &amp; 1) R = f(reflect(--r), R);
    }
    return f(L, R);
  }

  Monoid operator[](const int &amp;k) {
    return query(k, k + 1);
  }

  template&lt; typename C &gt;
  int find_subtree(int a, const C &amp;check, Monoid &amp;M, bool type) {
    while(a &lt; sz) {
      propagate(a);
      Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));
      if(check(nxt)) a = 2 * a + type;
      else M = nxt, a = 2 * a + 1 - type;
    }
    return a - sz;
  }

  template&lt; typename C &gt;
  int find_first(int a, const C &amp;check) {
    Monoid L = M1;
    if(a &lt;= 0) {
      if(check(f(L, reflect(1)))) return find_subtree(1, check, L, false);
      return -1;
    }
    thrust(a + sz);
    int b = sz;
    for(a += sz, b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
      if(a &amp; 1) {
        Monoid nxt = f(L, reflect(a));
        if(check(nxt)) return find_subtree(a, check, L, false);
        L = nxt;
        ++a;
      }
    }
    return -1;
  }


  template&lt; typename C &gt;
  int find_last(int b, const C &amp;check) {
    Monoid R = M1;
    if(b &gt;= sz) {
      if(check(f(reflect(1), R))) return find_subtree(1, check, R, true);
      return -1;
    }
    thrust(b + sz - 1);
    int a = sz;
    for(b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
      if(b &amp; 1) {
        Monoid nxt = f(reflect(--b), R);
        if(check(nxt)) return find_subtree(b, check, R, true);
        R = nxt;
      }
    }
    return -1;
  }
};


##################################################
###### partially-persistent-union-find.cpp #######
##################################################

struct PartiallyPersistentUnionFind {
  vector&lt; int &gt; data;
  vector&lt; int &gt; last;
  vector&lt; vector&lt; pair&lt; int, int &gt; &gt; &gt; add;

  PartiallyPersistentUnionFind() {}

  PartiallyPersistentUnionFind(int sz) : data(sz, -1), last(sz, 1e9), add(sz) {
    for(auto &amp;vs : add) vs.emplace_back(-1, -1);
  }

  bool unite(int t, int x, int y) {
    x = find(t, x);
    y = find(t, y);
    if(x == y) return false;
    if(data[x] &gt; data[y]) swap(x, y);
    data[x] += data[y];
    add[x].emplace_back(t, data[x]);
    data[y] = x;
    last[y] = t;
    return true;
  }

  int find(int t, int x) {
    if(t &lt; last[x]) return x;
    return find(t, data[x]);
  }

  int size(int t, int x) {
    x = find(t, x);
    return -prev(lower_bound(begin(add[x]), end(add[x]), make_pair(t, 0)))-&gt;second;
  }
};


##################################################
############ binary-indexed-tree.cpp #############
##################################################

template&lt; typename T &gt;
struct BinaryIndexedTree {
  vector&lt; T &gt; data;

  BinaryIndexedTree(int sz) {
    data.assign(++sz, 0);
  }

  T sum(int k) {
    T ret = 0;
    for(++k; k &gt; 0; k -= k &amp; -k) ret += data[k];
    return (ret);
  }

  void add(int k, T x) {
    for(++k; k &lt; data.size(); k += k &amp; -k) data[k] += x;
  }
};


##################################################
################# union-find.cpp #################
##################################################

struct UnionFind {
  vector&lt; int &gt; data;

  UnionFind(int sz) {
    data.assign(sz, -1);
  }

  bool unite(int x, int y) {
    x = find(x), y = find(y);
    if(x == y) return (false);
    if(data[x] &gt; data[y]) swap(x, y);
    data[x] += data[y];
    data[y] = x;
    return (true);
  }

  int find(int k) {
    if(data[k] &lt; 0) return (k);
    return (data[k] = find(data[k]));
  }

  int size(int k) {
    return (-data[find(k)]);
  }
};


##################################################
########### link-cut-tree-subtree.cpp ############
##################################################

template&lt; typename SUM, typename KEY &gt;
struct LinkCutTreeSubtree {

  struct Node {
    Node *l, *r, *p;

    KEY key;
    SUM sum;

    bool rev;
    int sz;

    bool is_root() const {
      return !p || (p-&gt;l != this &amp;&amp; p-&gt;r != this);
    }

    Node(const KEY &amp;key, const SUM &amp;sum) :
        key(key), sum(sum), rev(false), sz(1),
        l(nullptr), r(nullptr), p(nullptr) {}
  };

  const SUM ident;

  LinkCutTreeSubtree(const SUM &amp;ident) : ident(ident) {}

  Node *make_node(const KEY &amp;key) {
    auto ret = new Node(key, ident);
    update(ret);
    return ret;
  }

  Node *set_key(Node *t, const KEY &amp;key) {
    expose(t);
    t-&gt;key = key;
    update(t);
    return t;
  }

  void toggle(Node *t) {
    swap(t-&gt;l, t-&gt;r);
    t-&gt;sum.toggle();
    t-&gt;rev ^= true;
  }

  void push(Node *t) {
    if(t-&gt;rev) {
      if(t-&gt;l) toggle(t-&gt;l);
      if(t-&gt;r) toggle(t-&gt;r);
      t-&gt;rev = false;
    }
  }


  void update(Node *t) {
    t-&gt;sz = 1;
    if(t-&gt;l) t-&gt;sz += t-&gt;l-&gt;sz;
    if(t-&gt;r) t-&gt;sz += t-&gt;r-&gt;sz;
    t-&gt;sum.merge(t-&gt;key, t-&gt;l ? t-&gt;l-&gt;sum : ident, t-&gt;r ? t-&gt;r-&gt;sum : ident);
  }

  void rotr(Node *t) {
    auto *x = t-&gt;p, *y = x-&gt;p;
    if((x-&gt;l = t-&gt;r)) t-&gt;r-&gt;p = x;
    t-&gt;r = x, x-&gt;p = t;
    update(x), update(t);
    if((t-&gt;p = y)) {
      if(y-&gt;l == x) y-&gt;l = t;
      if(y-&gt;r == x) y-&gt;r = t;
      update(y);
    }
  }

  void rotl(Node *t) {
    auto *x = t-&gt;p, *y = x-&gt;p;
    if((x-&gt;r = t-&gt;l)) t-&gt;l-&gt;p = x;
    t-&gt;l = x, x-&gt;p = t;
    update(x), update(t);
    if((t-&gt;p = y)) {
      if(y-&gt;l == x) y-&gt;l = t;
      if(y-&gt;r == x) y-&gt;r = t;
      update(y);
    }
  }


  void splay(Node *t) {
    push(t);
    while(!t-&gt;is_root()) {
      auto *q = t-&gt;p;
      if(q-&gt;is_root()) {
        push(q), push(t);
        if(q-&gt;l == t) rotr(t);
        else rotl(t);
      } else {
        auto *r = q-&gt;p;
        push(r), push(q), push(t);
        if(r-&gt;l == q) {
          if(q-&gt;l == t) rotr(q), rotr(t);
          else rotl(t), rotr(t);
        } else {
          if(q-&gt;r == t) rotl(q), rotl(t);
          else rotr(t), rotl(t);
        }
      }
    }
  }


  Node *expose(Node *t) {
    Node *rp = nullptr;
    for(auto *cur = t; cur; cur = cur-&gt;p) {
      splay(cur);
      if(cur-&gt;r) cur-&gt;sum.add(cur-&gt;r-&gt;sum);
      cur-&gt;r = rp;
      if(cur-&gt;r) cur-&gt;sum.erase(cur-&gt;r-&gt;sum);
      update(cur);
      rp = cur;
    }
    splay(t);
    return rp;
  }

  void link(Node *child, Node *parent) {
    expose(child);
    expose(parent);
    child-&gt;p = parent;
    parent-&gt;r = child;
    update(parent);
  }

  void cut(Node *child) {
    expose(child);
    auto *parent = child-&gt;l;
    child-&gt;l = nullptr;
    parent-&gt;p = nullptr;
    update(child);
  }

  void evert(Node *t) {
    expose(t);
    toggle(t);
    push(t);
  }

  Node *lca(Node *u, Node *v) {
    if(get_root(u) != get_root(v)) return nullptr;
    expose(u);
    return expose(v);
  }


  Node *get_kth(Node *x, int k) {
    expose(x);
    while(x) {
      push(x);
      if(x-&gt;r &amp;&amp; x-&gt;r-&gt;sz &gt; k) {
        x = x-&gt;r;
      } else {
        if(x-&gt;r) k -= x-&gt;r-&gt;sz;
        if(k == 0) return x;
        k -= 1;
        x = x-&gt;l;
      }
    }
    return nullptr;
  }

  Node *get_root(Node *x) {
    expose(x);
    while(x-&gt;l) {
      push(x);
      x = x-&gt;l;
    }
    return x;
  }

  SUM &amp;query(Node *t) {
    expose(t);
    return t-&gt;sum;
  }
};


##################################################
##### segment-tree-fractional-cascading.cpp ######
##################################################

struct SegmentTreeFractionalCascading {
  vector&lt; vector&lt; int &gt; &gt; seg;
  vector&lt; vector&lt; int &gt; &gt; LL, RR;
  int sz;

  SegmentTreeFractionalCascading(vector&lt; int &gt; &amp;array) {
    sz = 1;
    while(sz &lt; array.size()) sz &lt;&lt;= 1;
    seg.resize(2 * sz - 1);
    LL.resize(2 * sz - 1);
    RR.resize(2 * sz - 1);
    for(int k = 0; k &lt; array.size(); k++) {
      seg[k + sz - 1].emplace_back(array[k]);
    }
    for(int k = sz - 2; k &gt;= 0; k--) {
      seg[k].resize(seg[2 * k + 1].size() + seg[2 * k + 2].size());
      LL[k].resize(seg[k].size() + 1);
      RR[k].resize(seg[k].size() + 1);
      merge(begin(seg[2 * k + 1]), end(seg[2 * k + 1]), begin(seg[2 * k + 2]), end(seg[2 * k + 2]), begin(seg[k]));
      int tail1 = 0, tail2 = 0;
      for(int i = 0; i &lt; seg[k].size(); i++) {
        while(tail1 &lt; seg[2 * k + 1].size() &amp;&amp; seg[2 * k + 1][tail1] &lt; seg[k][i]) ++tail1;
        while(tail2 &lt; seg[2 * k + 2].size() &amp;&amp; seg[2 * k + 2][tail2] &lt; seg[k][i]) ++tail2;
        LL[k][i] = tail1, RR[k][i] = tail2;
      }
      LL[k][seg[k].size()] = (int) seg[2 * k + 1].size();
      RR[k][seg[k].size()] = (int) seg[2 * k + 2].size();
    }
  }

  int query(int a, int b, int lower, int upper, int k, int l, int r) {
    if(a &gt;= r || b &lt;= l) {
      return (0);
    } else if(a &lt;= l &amp;&amp; r &lt;= b) {
      return (upper - lower);
    } else {
      return (query(a, b, LL[k][lower], LL[k][upper], 2 * k + 1, l, (l + r) &gt;&gt; 1) + query(a, b, RR[k][lower], RR[k][upper], 2 * k + 2, (l + r) &gt;&gt; 1, r));
    }
  }

  int query(int a, int b, int l, int r) {
    l = lower_bound(begin(seg[0]), end(seg[0]), l) - begin(seg[0]);
    r = lower_bound(begin(seg[0]), end(seg[0]), r) - begin(seg[0]);
    return (query(a, b, l, r, 0, 0, sz));
  }
};


##################################################
############# dual-segment-tree.cpp ##############
##################################################

template&lt; typename OperatorMonoid &gt;
struct DualSegmentTree {
  using H = function&lt; OperatorMonoid(OperatorMonoid, OperatorMonoid) &gt;;

  int sz, height;
  vector&lt; OperatorMonoid &gt; lazy;
  const H h;
  const OperatorMonoid OM0;


  DualSegmentTree(int n, const H h, const OperatorMonoid OM0)
      : h(h), OM0(OM0) {
    sz = 1;
    height = 0;
    while(sz &lt; n) sz &lt;&lt;= 1, height++;
    lazy.assign(2 * sz, OM0);
  }

  inline void propagate(int k) {
    if(lazy[k] != OM0) {
      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);
      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);
      lazy[k] = OM0;
    }
  }

  inline void thrust(int k) {
    for(int i = height; i &gt; 0; i--) propagate(k &gt;&gt; i);
  }

  void update(int a, int b, const OperatorMonoid &amp;x) {
    thrust(a += sz);
    thrust(b += sz - 1);
    for(int l = a, r = b + 1; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if(l &amp; 1) lazy[l] = h(lazy[l], x), ++l;
      if(r &amp; 1) --r, lazy[r] = h(lazy[r], x);
    }
  }

  OperatorMonoid operator[](int k) {
    thrust(k += sz);
    return lazy[k];
  }
};


##################################################
############ weighted-union-find.cpp #############
##################################################

template&lt; typename T &gt;
struct WeightedUnionFind {
  vector&lt; int &gt; data;
  vector&lt; T &gt; ws;

  WeightedUnionFind() {}

  WeightedUnionFind(int sz) : data(sz, -1), ws(sz) {}

  int find(int k) {
    if(data[k] &lt; 0) return k;
    auto par = find(data[k]);
    ws[k] += ws[data[k]];
    return data[k] = par;
  }

  T weight(int t) {
    find(t);
    return ws[t];
  }

  bool unite(int x, int y, T w) {
    w += weight(x);
    w -= weight(y);
    x = find(x), y = find(y);
    if(x == y) return false;
    if(data[x] &gt; data[y]) {
      swap(x, y);
      w *= -1;
    }
    data[x] += data[y];
    data[y] = x;
    ws[y] = w;
    return true;
  }

  T diff(int x, int y) {
    return weight(y) - weight(x);
  }
};


##################################################
################ sparse-table.cpp ################
##################################################

template&lt; typename T &gt;
struct SparseTable {
  vector&lt; vector&lt; T &gt; &gt; st;
  vector&lt; int &gt; lookup;

  SparseTable(const vector&lt; T &gt; &amp;v) {
    int b = 0;
    while((1 &lt;&lt; b) &lt;= v.size()) ++b;
    st.assign(b, vector&lt; T &gt;(1 &lt;&lt; b));
    for(int i = 0; i &lt; v.size(); i++) {
      st[0][i] = v[i];
    }
    for(int i = 1; i &lt; b; i++) {
      for(int j = 0; j + (1 &lt;&lt; i) &lt;= (1 &lt;&lt; b); j++) {
        st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 &lt;&lt; (i - 1))]);
      }
    }
    lookup.resize(v.size() + 1);
    for(int i = 2; i &lt; lookup.size(); i++) {
      lookup[i] = lookup[i &gt;&gt; 1] + 1;
    }
  }

  inline T rmq(int l, int r) {
    int b = lookup[r - l];
    return min(st[b][l], st[b][r - (1 &lt;&lt; b)]);
  }
};


##################################################
######### persistent-red-black-tree.cpp ##########
##################################################

template&lt; class D, class L, D (*f)(D, D), D (*g)(D, L), L (*h)(L, L), L (*p)(L, int) &gt;
struct PersistentRedBlackTree : RedBlackTree&lt; D, L, f, g, h, p &gt; {
  using RBT = RedBlackTree&lt; D, L, f, g, h, p &gt;;
  using Node = typename RBT::Node;

  PersistentRedBlackTree(int sz, const D &amp;M1, const L &amp;OM0) :
      RBT(sz, M1, OM0) {}

  Node *clone(Node *t) override { return &amp;(*RBT::pool.alloc() = *t); }

  Node *rebuild(Node *r) {
    auto ret = RBT::dump(r);
    RBT::pool.clear();
    return RBT::build(ret);
  }
};


##################################################
############## persistent-array.cpp ##############
##################################################

template&lt; typename T, int LOG &gt;
struct PersistentArray {
  struct Node {
    T data;
    Node *child[1 &lt;&lt; LOG] = {};

    Node() {}

    Node(const T &amp;data) : data(data) {}
  };

  Node *root;

  PersistentArray() : root(nullptr) {}

  T get(Node *t, int k) {
    if(k == 0) return t-&gt;data;
    return get(t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)], k &gt;&gt; LOG);
  }

  T get(const int &amp;k) {
    return get(root, k);
  }

  pair&lt; Node *, T * &gt; mutable_get(Node *t, int k) {
    t = t ? new Node(*t) : new Node();
    if(k == 0) return {t, &amp;t-&gt;data};
    auto p = mutable_get(t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)], k &gt;&gt; LOG);
    t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)] = p.first;
    return {t, p.second};
  }

  T *mutable_get(const int &amp;k) {
    auto ret = mutable_get(root, k);
    root = ret.first;
    return ret.second;
  }

  Node *build(Node *t, const T &amp;data, int k) {
    if(!t) t = new Node();
    if(k == 0) {
      t-&gt;data = data;
      return t;
    }
    auto p = build(t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)], data, k &gt;&gt; LOG);
    t-&gt;child[k &amp; ((1 &lt;&lt; LOG) - 1)] = p;
    return t;
  }

  void build(const vector&lt; T &gt; &amp;v) {
    root = nullptr;
    for(int i = 0; i &lt; v.size(); i++) {
      root = build(root, v[i], i);
    }
  }
};



##################################################
##### randomized-binary-search-tree-set.cpp ######
##################################################

template&lt; class T &gt;
struct OrderedMultiSet : RandomizedBinarySearchTree&lt; T &gt;
{
  using RBST = RandomizedBinarySearchTree&lt; T &gt;;
  using Node = typename RBST::Node;

  OrderedMultiSet(int sz) : RBST(sz, [&amp;](T x, T y) { return x; }, T()) {}

  T kth_element(Node *t, int k)
  {
    if(k &lt; RBST::count(t-&gt;l)) return kth_element(t-&gt;l, k);
    if(k == RBST::count(t-&gt;l)) return t-&gt;key;
    return kth_element(t-&gt;r, k - RBST::count(t-&gt;l) - 1);
  }

  virtual void insert_key(Node *&amp;t, const T &amp;x)
  {
    RBST::insert(t, lower_bound(t, x), x);
  }

  void erase_key(Node *&amp;t, const T &amp;x)
  {
    if(!count(t, x)) return;
    RBST::erase(t, lower_bound(t, x));
  }

  int count(Node *t, const T &amp;x)
  {
    return upper_bound(t, x) - lower_bound(t, x);
  }

  int lower_bound(Node *t, const T &amp;x)
  {
    if(!t) return 0;
    if(x &lt;= t-&gt;key) return lower_bound(t-&gt;l, x);
    return lower_bound(t-&gt;r, x) + RBST::count(t-&gt;l) + 1;
  }

  int upper_bound(Node *t, const T &amp;x)
  {
    if(!t) return 0;
    if(x &lt; t-&gt;key) return upper_bound(t-&gt;l, x);
    return upper_bound(t-&gt;r, x) + RBST::count(t-&gt;l) + 1;
  }
};
template&lt; class T &gt;
struct OrderedSet : OrderedMultiSet&lt; T &gt;
{
  using SET = OrderedMultiSet&lt; T &gt;;
  using RBST = typename SET::RBST;
  using Node = typename RBST::Node;

  OrderedSet(int sz) : OrderedMultiSet&lt; T &gt;(sz) {}

  void insert_key(Node *&amp;t, const T &amp;x) override
  {
    if(SET::count(t, x)) return;
    RBST::insert(t, SET::lower_bound(t, x), x);
  }
};


##################################################
############# segment-tree-beats.cpp #############
##################################################

template&lt; typename Monoid, typename OperatorMonoid = Monoid &gt;
struct SegmentTreeBeats {
  using F = function&lt; Monoid(Monoid, Monoid) &gt;;
  using G = function&lt; Monoid(Monoid, OperatorMonoid) &gt;;
  using H = function&lt; OperatorMonoid(OperatorMonoid, OperatorMonoid) &gt;;

  int sz, height;
  vector&lt; Monoid &gt; data;
  vector&lt; OperatorMonoid &gt; lazy;
  const F f;
  const G g;
  const H h;
  const Monoid M1;
  const OperatorMonoid OM0;


  SegmentTreeBeats(int n, const F f, const G g, const H h,
                   const Monoid &amp;M1, const OperatorMonoid OM0)
      : f(f), g(g), h(h), M1(M1), OM0(OM0) {
    sz = 1;
    height = 0;
    while(sz &lt; n) sz &lt;&lt;= 1, height++;
    data.assign(2 * sz, M1);
    lazy.assign(2 * sz, OM0);
  }

  void set(int k, const Monoid &amp;x) {
    data[k + sz] = x;
  }

  void build() {
    for(int k = sz - 1; k &gt; 0; k--) {
      data[k] = f(data[2 * k + 0], data[2 * k + 1]);
    }
  }

  inline void propagate(int k) {
    if(lazy[k] != OM0) {
      lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);
      lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);
      data[k] = reflect(k);
      lazy[k] = OM0;
    }
  }

  inline Monoid reflect(int k) {
    return lazy[k] == OM0 ? data[k] : g(data[k], lazy[k]);
  }

  inline void recalc(int k) {
    while(k &gt;&gt;= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));
  }

  inline void thrust(int k) {
    for(int i = height; i &gt; 0; i--) propagate(k &gt;&gt; i);
  }

  void update(int a, int b, const OperatorMonoid &amp;x) {
    thrust(a += sz);
    thrust(b += sz - 1);
    for(int l = a, r = b + 1; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if(l &amp; 1) lazy[l] = h(lazy[l], x), ++l;
      if(r &amp; 1) --r, lazy[r] = h(lazy[r], x);
    }
    recalc(a);
    recalc(b);
  }

  Monoid query(int a, int b) {
    thrust(a += sz);
    thrust(b += sz - 1);
    Monoid L = M1, R = M1;
    for(int l = a, r = b + 1; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if(l &amp; 1) L = f(L, reflect(l++));
      if(r &amp; 1) R = f(reflect(--r), R);
    }
    return f(L, R);
  }

  Monoid operator[](const int &amp;k) {
    return query(k, k + 1);
  }

  template&lt; typename Uku, typename Check, typename Func, typename X &gt;
  void update_beats_subtree(int k, const X &amp;x, const Uku &amp;uku, const Check &amp;check, const Func &amp;func) {
    if(k &gt;= sz) {
      auto v = reflect(k);
      if(uku(v, x)) return;
      if(check(v)) lazy[k] = func(v, x);
      return;
    }
    propagate(k);
    if(uku(data[k], x)) return;
    if(check(data[k])) {
      lazy[k] = func(data[k], x);
      return;
    }
    update_beats_subtree(k * 2 + 0, x, uku, check, func);
    update_beats_subtree(k * 2 + 1, x, uku, check, func);
    data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));
  }

  template&lt; typename Uku, typename Check, typename Func, typename X &gt;
  void update_beats(int a, int b, const X &amp;x, const Uku &amp;uku, const Check &amp;check, const Func &amp;func) {
    thrust(a += sz);
    thrust(b += sz - 1);
    for(int l = a, r = b + 1; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
      if(l &amp; 1) update_beats_subtree(l++, x, uku, check, func);
      if(r &amp; 1) update_beats_subtree(--r, x, uku, check, func);
    }
    recalc(a);
    recalc(b);
  }
};


##################################################
#################### trie.cpp ####################
##################################################

template&lt; int char_size &gt;
struct TrieNode {
  int nxt[char_size];

  int exist;
  vector&lt; int &gt; accept;

  TrieNode() : exist(0) {
    memset(nxt, -1, sizeof(nxt));
  }
};

template&lt; int char_size, int margin &gt;
struct Trie {
  using Node = TrieNode&lt; char_size &gt;;

  vector&lt; Node &gt; nodes;
  int root;

  Trie() : root(0) {
    nodes.push_back(Node());
  }

  void update_direct(int node, int id) {
    nodes[node].accept.push_back(id);
  }

  void update_child(int node, int child, int id) {
    ++nodes[node].exist;
  }

  void add(const string &amp;str, int str_index, int node_index, int id) {
    if(str_index == str.size()) {
      update_direct(node_index, id);
    } else {
      const int c = str[str_index] - margin;
      if(nodes[node_index].nxt[c] == -1) {
        nodes[node_index].nxt[c] = (int) nodes.size();
        nodes.push_back(Node());
      }
      add(str, str_index + 1, nodes[node_index].nxt[c], id);
      update_child(node_index, nodes[node_index].nxt[c], id);
    }
  }

  void add(const string &amp;str, int id) {
    add(str, 0, 0, id);
  }

  void add(const string &amp;str) {
    add(str, nodes[0].exist);
  }

  void query(const string &amp;str, const function&lt; void(int) &gt; &amp;f, int str_index, int node_index) {
    for(auto &amp;idx : nodes[node_index].accept) f(idx);
    if(str_index == str.size()) {
      return;
    } else {
      const int c = str[str_index] - margin;
      if(nodes[node_index].nxt[c] == -1) return;
      query(str, f, str_index + 1, nodes[node_index].nxt[c]);
    }
  }

  void query(const string &amp;str, const function&lt; void(int) &gt; &amp;f) {
    query(str, f, 0, 0);
  }

  int count() const {
    return (nodes[0].exist);
  }

  int size() const {
    return ((int) nodes.size());
  }
};


##################################################
############## union-find-undo.cpp ###############
##################################################

struct UnionFindUndo {
  vector&lt; int &gt; data;
  stack&lt; pair&lt; int, int &gt; &gt; history;

  UnionFindUndo(int sz) {
    data.assign(sz, -1);
  }

  bool unite(int x, int y) {
    x = find(x), y = find(y);
    history.emplace(x, data[x]);
    history.emplace(y, data[y]);
    if(x == y) return (false);
    if(data[x] &gt; data[y]) swap(x, y);
    data[x] += data[y];
    data[y] = x;
    return (true);
  }

  int find(int k) {
    if(data[k] &lt; 0) return (k);
    return (find(data[k]));
  }

  int size(int k) {
    return (-data[find(k)]);
  }

  void undo() {
    data[history.top().first] = history.top().second;
    history.pop();
    data[history.top().first] = history.top().second;
    history.pop();
  }

  void snapshot() {
    while(history.size()) history.pop();
  }

  void rollback() {
    while(history.size()) undo();
  }
};


##################################################
############## segment-tree-2d.cpp ###############
##################################################

template&lt; typename structure_t, typename get_t, typename update_t &gt;
struct SegmentTree2DCompressed {

  using merge_f = function&lt; get_t(get_t, get_t) &gt;;
  using range_get_f = function&lt; get_t(structure_t &amp;, int, int) &gt;;
  using update_f = function&lt; void(structure_t &amp;, int, update_t) &gt;;

  int sz;
  vector&lt; structure_t &gt; seg;
  const merge_f f;
  const range_get_f g;
  const update_f h;
  const get_t identity;
  vector&lt; vector&lt; int &gt; &gt; LL, RR;
  vector&lt; vector&lt; int &gt; &gt; beet;

  SegmentTree2DCompressed(int n, const merge_f &amp;f, const range_get_f &amp;g, const update_f &amp;h, const get_t &amp;identity)
      : f(f), g(g), h(h), identity(identity) {
    sz = 1;
    while(sz &lt; n) sz &lt;&lt;= 1;
    beet.resize(2 * sz);
    LL.resize(2 * sz);
    RR.resize(2 * sz);
  }

  void update(int a, int x, update_t z, int k, int l, int r) {
    if(r &lt;= a || a + 1 &lt;= l) return;
    if(a &lt;= l &amp;&amp; r &lt;= a + 1) return h(seg[k], x, z);
    update(a, LL[k][x], z, 2 * k + 0, l, (l + r) &gt;&gt; 1);
    update(a, RR[k][x], z, 2 * k + 1, (l + r) &gt;&gt; 1, r);
    return h(seg[k], x, z);
  }

  void update(int x, int y, update_t z) {
    y = lower_bound(begin(beet[1]), end(beet[1]), y) - begin(beet[1]);
    return update(x, y, z, 1, 0, sz);
  }

  get_t query(int a, int b, int x, int y, int k, int l, int r) {
    if(a &gt;= r || b &lt;= l) return identity;
    if(a &lt;= l &amp;&amp; r &lt;= b) return g(seg[k], x, y);
    return f(query(a, b, LL[k][x], LL[k][y], 2 * k + 0, l, (l + r) &gt;&gt; 1),
             query(a, b, RR[k][x], RR[k][y], 2 * k + 1, (l + r) &gt;&gt; 1, r));
  }

  get_t query(int a, int b, int x, int y) {
    x = lower_bound(begin(beet[1]), end(beet[1]), x) - begin(beet[1]);
    y = lower_bound(begin(beet[1]), end(beet[1]), y) - begin(beet[1]);
    return query(a, b, x, y, 1, 0, sz);
  }

  void build() {
    for(int k = (int) beet.size() - 1; k &gt;= sz; k--) {
      sort(begin(beet[k]), end(beet[k]));
      beet[k].erase(unique(begin(beet[k]), end(beet[k])), end(beet[k]));
    }
    for(int k = sz - 1; k &gt; 0; k--) {
      beet[k].resize(beet[2 * k + 0].size() + beet[2 * k + 1].size());
      merge(begin(beet[2 * k + 0]), end(beet[2 * k + 0]), begin(beet[2 * k + 1]), end(beet[2 * k + 1]), begin(beet[k]));
      beet[k].erase(unique(begin(beet[k]), end(beet[k])), end(beet[k]));
      LL[k].resize(beet[k].size() + 1);
      RR[k].resize(beet[k].size() + 1);
      int tail1 = 0, tail2 = 0;
      for(int i = 0; i &lt; beet[k].size(); i++) {
        while(tail1 &lt; beet[2 * k + 0].size() &amp;&amp; beet[2 * k + 0][tail1] &lt; beet[k][i]) ++tail1;
        while(tail2 &lt; beet[2 * k + 1].size() &amp;&amp; beet[2 * k + 1][tail2] &lt; beet[k][i]) ++tail2;
        LL[k][i] = tail1, RR[k][i] = tail2;
      }
      LL[k][beet[k].size()] = (int) beet[2 * k + 0].size();
      RR[k][beet[k].size()] = (int) beet[2 * k + 1].size();
    }
    for(int k = 0; k &lt; beet.size(); k++) {
      seg.emplace_back(structure_t(beet[k].size()));
    }
  }

  void preupdate(int x, int y) {
    beet[x + sz].push_back(y);
  }
};


##################################################
############## union-rectangle.cpp ###############
##################################################

template&lt; typename T &gt;
struct UnionRectangle {
  map&lt; T, T &gt; data;
  int64 sum;

  UnionRectangle() : sum(0) {
    const T INF = numeric_limits&lt; T &gt;::max();
    data[0] = INF;
    data[INF] = 0;
  }
  void add_point(T x, T y) {
    auto p = data.lower_bound(x);
    if(p-&gt;second &gt;= y) return;
    const T nxtY = p-&gt;second;
    --p;
    while(p-&gt;second &lt;= y) {
      auto it = *p;
      p = --data.erase(p);
      sum -= (it.first - p-&gt;first) * (it.second - nxtY);
    }
    sum += (x - p-&gt;first) * (y - nxtY);
    data[x] = y;
  }

  int64 get() {
    return sum;
  }
};


##################################################
########## persistent-segment-tree.cpp ###########
##################################################

template&lt; typename Monoid &gt;
struct PersistentSegmentTree {
  using F = function&lt; Monoid(Monoid, Monoid) &gt;;

  struct Node {
    Monoid data;
    Node *l, *r;

    Node(const Monoid &amp;data) : data(data), l(nullptr), r(nullptr) {}
  };


  int sz;
  const F f;
  const Monoid M1;

  PersistentSegmentTree(const F f, const Monoid &amp;M1) : f(f), M1(M1) {}

  Node *build(vector&lt; Monoid &gt; &amp;v) {
    sz = (int) v.size();
    return build(0, (int) v.size(), v);
  }

  Node *merge(Node *l, Node *r) {
    auto t = new Node(f(l-&gt;data, r-&gt;data));
    t-&gt;l = l;
    t-&gt;r = r;
    return t;
  }

  Node *build(int l, int r, vector&lt; Monoid &gt; &amp;v) {
    if(l + 1 &gt;= r) return new Node(v[l]);
    return merge(build(l, (l + r) &gt;&gt; 1, v), build((l + r) &gt;&gt; 1, r, v));
  }

  Node *update(int a, const Monoid &amp;x, Node *k, int l, int r) {
    if(r &lt;= a || a + 1 &lt;= l) {
      return k;
    } else if(a &lt;= l &amp;&amp; r &lt;= a + 1) {
      return new Node(x);
    } else {
      return merge(update(a, x, k-&gt;l, l, (l + r) &gt;&gt; 1), update(a, x, k-&gt;r, (l + r) &gt;&gt; 1, r));
    }
  }

  Node *update(Node *t, int k, const Monoid &amp;x) {
    return update(k, x, t, 0, sz);
  }

  Monoid query(int a, int b, Node *k, int l, int r) {
    if(r &lt;= a || b &lt;= l) {
      return M1;
    } else if(a &lt;= l &amp;&amp; r &lt;= b) {
      return k-&gt;data;
    } else {
      return f(query(a, b, k-&gt;l, l, (l + r) &gt;&gt; 1),
               query(a, b, k-&gt;r, (l + r) &gt;&gt; 1, r));
    }
  }

  Monoid query(Node *t, int a, int b) {
    return query(a, b, t, 0, sz);
  }
};


##################################################
############### red-black-tree.cpp ###############
##################################################

template&lt; class T &gt;
struct ArrayPool {
  vector&lt; T &gt; pool;
  vector&lt; T * &gt; stock;
  int ptr;

  ArrayPool(int sz) : pool(sz), stock(sz) {}

  inline T *alloc() { return stock[--ptr]; }

  inline void free(T *t) { stock[ptr++] = t; }

  void clear() {
    ptr = (int) pool.size();
    for(int i = 0; i &lt; pool.size(); i++) stock[i] = &amp;pool[i];
  }
};

template&lt; class D, class L, D (*f)(D, D), D (*g)(D, L), L (*h)(L, L), L (*p)(L, int) &gt;
struct RedBlackTree {
  enum COLOR {
    BLACK, RED
  };

  struct Node {
    Node *l, *r;
    COLOR color;
    int level, cnt;
    D key, sum;
    L lazy;

    Node() {}

    Node(const D &amp;k, const L &amp;laz) :
        key(k), sum(k), l(nullptr), r(nullptr), color(BLACK), level(0), cnt(1), lazy(laz) {}

    Node(Node *l, Node *r, const D &amp;k, const L &amp;laz) :
        key(k), color(RED), l(l), r(r), lazy(laz) {}
  };

  ArrayPool&lt; Node &gt; pool;


  const D M1;
  const L OM0;

  RedBlackTree(int sz, const D &amp;M1, const L &amp;OM0) :
      pool(sz), M1(M1), OM0(OM0) { pool.clear(); }


  inline Node *alloc(const D &amp;key) {
    return &amp;(*pool.alloc() = Node(key, OM0));
  }

  inline Node *alloc(Node *l, Node *r) {
    auto t = &amp;(*pool.alloc() = Node(l, r, M1, OM0));
    return update(t);
  }

  virtual Node *clone(Node *t) { return t; }

  inline int count(const Node *t) { return t ? t-&gt;cnt : 0; }

  inline D sum(const Node *t) { return t ? t-&gt;sum : M1; }

  Node *update(Node *t) {
    t-&gt;cnt = count(t-&gt;l) + count(t-&gt;r) + (!t-&gt;l || !t-&gt;r);
    t-&gt;level = t-&gt;l ? t-&gt;l-&gt;level + (t-&gt;l-&gt;color == BLACK) : 0;
    t-&gt;sum = f(f(sum(t-&gt;l), t-&gt;key), sum(t-&gt;r));
    return t;
  }

  Node *propagate(Node *t) {
    t = clone(t);
    if(t-&gt;lazy != OM0) {
      if(!t-&gt;l) {
        t-&gt;key = g(t-&gt;key, p(t-&gt;lazy, 1));
      } else {
        if(t-&gt;l) {
          t-&gt;l = clone(t-&gt;l);
          t-&gt;l-&gt;lazy = h(t-&gt;l-&gt;lazy, t-&gt;lazy);
          t-&gt;l-&gt;sum = g(t-&gt;l-&gt;sum, p(t-&gt;lazy, count(t-&gt;l)));
        }
        if(t-&gt;r) {
          t-&gt;r = clone(t-&gt;r);
          t-&gt;r-&gt;lazy = h(t-&gt;r-&gt;lazy, t-&gt;lazy);
          t-&gt;r-&gt;sum = g(t-&gt;r-&gt;sum, p(t-&gt;lazy, count(t-&gt;r)));
        }
      }
      t-&gt;lazy = OM0;
    }
    return update(t);
  }

  Node *rotate(Node *t, bool b) {
    t = propagate(t);
    Node *s;
    if(b) {
      s = propagate(t-&gt;l);
      t-&gt;l = s-&gt;r;
      s-&gt;r = t;
    } else {
      s = propagate(t-&gt;r);
      t-&gt;r = s-&gt;l;
      s-&gt;l = t;
    }
    update(t);
    return update(s);
  }

  Node *submerge(Node *l, Node *r) {
    if(l-&gt;level &lt; r-&gt;level) {
      r = propagate(r);
      Node *c = (r-&gt;l = submerge(l, r-&gt;l));
      if(r-&gt;color == BLACK &amp;&amp; c-&gt;color == RED &amp;&amp; c-&gt;l &amp;&amp; c-&gt;l-&gt;color == RED) {
        r-&gt;color = RED;
        c-&gt;color = BLACK;
        if(r-&gt;r-&gt;color == BLACK) return rotate(r, true);
        r-&gt;r-&gt;color = BLACK;
      }
      return update(r);
    }
    if(l-&gt;level &gt; r-&gt;level) {
      l = propagate(l);
      Node *c = (l-&gt;r = submerge(l-&gt;r, r));
      if(l-&gt;color == BLACK &amp;&amp; c-&gt;color == RED &amp;&amp; c-&gt;r &amp;&amp; c-&gt;r-&gt;color == RED) {
        l-&gt;color = RED;
        c-&gt;color = BLACK;
        if(l-&gt;l-&gt;color == BLACK) return rotate(l, false);
        l-&gt;l-&gt;color = BLACK;
      }
      return update(l);
    }
    return alloc(l, r);
  }

  Node *merge(Node *l, Node *r) {
    if(!l || !r) return l ? l : r;
    Node *c = submerge(l, r);
    c-&gt;color = BLACK;
    return c;
  }

  pair&lt; Node *, Node * &gt; split(Node *t, int k) {
    if(!t) return {nullptr, nullptr};
    t = propagate(t);
    if(k == 0) return {nullptr, t};
    if(k &gt;= count(t)) return {t, nullptr};
    Node *l = t-&gt;l, *r = t-&gt;r;
    pool.free(t);
    if(k &lt; count(l)) {
      auto pp = split(l, k);
      return {pp.first, merge(pp.second, r)};
    }
    if(k &gt; count(l)) {
      auto pp = split(r, k - count(l));
      return {merge(l, pp.first), pp.second};
    }
    return {l, r};
  }

  Node *build(int l, int r, const vector&lt; D &gt; &amp;v) {
    if(l + 1 &gt;= r) return alloc(v[l]);
    return merge(build(l, (l + r) &gt;&gt; 1, v), build((l + r) &gt;&gt; 1, r, v));
  }

  Node *build(const vector&lt; D &gt; &amp;v) {
    //pool.clear();
    return build(0, (int) v.size(), v);
  }

  void dump(Node *r, typename vector&lt; D &gt;::iterator &amp;it, L lazy) {
    if(r-&gt;lazy != OM0) lazy = h(lazy, r-&gt;lazy);
    if(!r-&gt;l || !r-&gt;r) {
      *it++ = g(r-&gt;key, lazy);
      return;
    }
    dump(r-&gt;l, it, lazy);
    dump(r-&gt;r, it, lazy);
  }

  vector&lt; D &gt; dump(Node *r) {
    vector&lt; D &gt; v((size_t) count(r));
    auto it = begin(v);
    dump(r, it, OM0);
    return v;
  }

  string to_string(Node *r) {
    auto s = dump(r);
    string ret;
    for(int i = 0; i &lt; s.size(); i++) {
      ret += std::to_string(s[i]);
      ret += &quot;, &quot;;
    }
    return (ret);
  }

  void insert(Node *&amp;t, int k, const D &amp;v) {
    auto x = split(t, k);
    t = merge(merge(x.first, alloc(v)), x.second);
  }

  D erase(Node *&amp;t, int k) {
    auto x = split(t, k);
    auto y = split(x.second, 1);
    auto v = y.first-&gt;key;
    pool.free(y.first);
    t = merge(x.first, y.second);
    return v;
  }

  D query(Node *&amp;t, int a, int b) {
    auto x = split(t, a);
    auto y = split(x.second, b - a);
    auto ret = sum(y.first);
    t = merge(x.first, merge(y.first, y.second));
    return ret;
  }

  void set_propagate(Node *&amp;t, int a, int b, const L &amp;pp) {
    auto x = split(t, a);
    auto y = split(x.second, b - a);
    y.first-&gt;lazy = h(y.first-&gt;lazy, pp);
    t = merge(x.first, merge(propagate(y.first), y.second));
  }

  void set_element(Node *&amp;t, int k, const D &amp;x) {
    if(!t-&gt;l) {
      t-&gt;key = t-&gt;sum = x;
      return;
    }
    t = propagate(t);
    if(k &lt; count(t-&gt;l)) set_element(t-&gt;l, k, x);
    else set_element(t-&gt;r, k - count(t-&gt;l), x);
    t = update(t);
  }

  int size(Node *t) {
    return count(t);
  }

  bool empty(Node *t) {
    return !t;
  }

  Node *makeset() {
    return (nullptr);
  }
};


##################################################
####### randomized-binary-search-tree.cpp ########
##################################################

template&lt; class Monoid, class OperatorMonoid = Monoid &gt;
struct RandomizedBinarySearchTree {
  using F = function&lt; Monoid(Monoid, Monoid) &gt;;
  using G = function&lt; Monoid(Monoid, OperatorMonoid) &gt;;
  using H = function&lt; OperatorMonoid(OperatorMonoid, OperatorMonoid) &gt;;
  using P = function&lt; OperatorMonoid(OperatorMonoid, int) &gt;;

  inline int xor128() {
    static int x = 123456789;
    static int y = 362436069;
    static int z = 521288629;
    static int w = 88675123;
    int t;

    t = x ^ (x &lt;&lt; 11);
    x = y;
    y = z;
    z = w;
    return w = (w ^ (w &gt;&gt; 19)) ^ (t ^ (t &gt;&gt; 8));
  }

  struct Node {
    Node *l, *r;
    int cnt;
    Monoid key, sum;
    OperatorMonoid lazy;

    Node() = default;

    Node(const Monoid &amp;k, const OperatorMonoid &amp;p) : cnt(1), key(k), sum(k), lazy(p), l(nullptr), r(nullptr) {}
  };

  vector&lt; Node &gt; pool;
  int ptr;

  const Monoid M1;
  const OperatorMonoid OM0;
  const F f;
  const G g;
  const H h;
  const P p;

  RandomizedBinarySearchTree(int sz, const F &amp;f, const Monoid &amp;M1) :
      pool(sz), ptr(0), f(f), g(G()), h(H()), p(P()), M1(M1), OM0(OperatorMonoid()) {}

  RandomizedBinarySearchTree(int sz, const F &amp;f, const G &amp;g, const H &amp;h, const P &amp;p,
                             const Monoid &amp;M1, const OperatorMonoid &amp;OM0) :
      pool(sz), ptr(0), f(f), g(g), h(h), p(p), M1(M1), OM0(OM0) {}

  inline Node *alloc(const Monoid &amp;key) { return &amp;(pool[ptr++] = Node(key, OM0)); }

  virtual Node *clone(Node *t) { return t; }

  inline int count(const Node *t) { return t ? t-&gt;cnt : 0; }

  inline Monoid sum(const Node *t) { return t ? t-&gt;sum : M1; }

  inline Node *update(Node *t) {
    t-&gt;cnt = count(t-&gt;l) + count(t-&gt;r) + 1;
    t-&gt;sum = f(f(sum(t-&gt;l), t-&gt;key), sum(t-&gt;r));
    return t;
  }

  Node *propagate(Node *t) {
    t = clone(t);
    if(t-&gt;lazy != OM0) {
      t-&gt;key = g(t-&gt;key, p(t-&gt;lazy, 1));
      if(t-&gt;l) {
        t-&gt;l = clone(t-&gt;l);
        t-&gt;l-&gt;lazy = h(t-&gt;l-&gt;lazy, t-&gt;lazy);
        t-&gt;l-&gt;sum = g(t-&gt;l-&gt;sum, p(t-&gt;lazy, count(t-&gt;l)));
      }
      if(t-&gt;r) {
        t-&gt;r = clone(t-&gt;r);
        t-&gt;r-&gt;lazy = h(t-&gt;r-&gt;lazy, t-&gt;lazy);
        t-&gt;r-&gt;sum = g(t-&gt;r-&gt;sum, p(t-&gt;lazy, count(t-&gt;r)));
      }
      t-&gt;lazy = OM0;
    }
    return update(t);
  }

  Node *merge(Node *l, Node *r) {
    if(!l || !r) return l ? l : r;
    if(xor128() % (l-&gt;cnt + r-&gt;cnt) &lt; l-&gt;cnt) {
      l = propagate(l);
      l-&gt;r = merge(l-&gt;r, r);
      return update(l);
    } else {
      r = propagate(r);
      r-&gt;l = merge(l, r-&gt;l);
      return update(r);
    }
  }

  pair&lt; Node *, Node * &gt; split(Node *t, int k) {
    if(!t) return {t, t};
    t = propagate(t);
    if(k &lt;= count(t-&gt;l)) {
      auto s = split(t-&gt;l, k);
      t-&gt;l = s.second;
      return {s.first, update(t)};
    } else {
      auto s = split(t-&gt;r, k - count(t-&gt;l) - 1);
      t-&gt;r = s.first;
      return {update(t), s.second};
    }
  }

  Node *build(int l, int r, const vector&lt; Monoid &gt; &amp;v) {
    if(l + 1 &gt;= r) return alloc(v[l]);
    return merge(build(l, (l + r) &gt;&gt; 1, v), build((l + r) &gt;&gt; 1, r, v));
  }

  Node *build(const vector&lt; Monoid &gt; &amp;v) {
    ptr = 0;
    return build(0, (int) v.size(), v);
  }

  void dump(Node *r, typename vector&lt; Monoid &gt;::iterator &amp;it) {
    if(!r) return;
    r = propagate(r);
    dump(r-&gt;l, it);
    *it = r-&gt;key;
    dump(r-&gt;r, ++it);
  }

  vector&lt; Monoid &gt; dump(Node *r) {
    vector&lt; Monoid &gt; v((size_t) count(r));
    auto it = begin(v);
    dump(r, it);
    return v;
  }

  string to_string(Node *r) {
    auto s = dump(r);
    string ret;
    for(int i = 0; i &lt; s.size(); i++) ret += &quot;, &quot;;
    return (ret);
  }

  void insert(Node *&amp;t, int k, const Monoid &amp;v) {
    auto x = split(t, k);
    t = merge(merge(x.first, alloc(v)), x.second);
  }

  void erase(Node *&amp;t, int k) {
    auto x = split(t, k);
    t = merge(x.first, split(x.second, 1).second);
  }

  Monoid query(Node *&amp;t, int a, int b) {
    auto x = split(t, a);
    auto y = split(x.second, b - a);
    auto ret = sum(y.first);
    t = merge(x.first, merge(y.first, y.second));
    return ret;
  }

  void set_propagate(Node *&amp;t, int a, int b, const OperatorMonoid &amp;p) {
    auto x = split(t, a);
    auto y = split(x.second, b - a);
    y.first-&gt;lazy = h(y.first-&gt;lazy, p);
    t = merge(x.first, merge(propagate(y.first), y.second));
  }

  void set_element(Node *&amp;t, int k, const Monoid &amp;x) {
    t = propagate(t);
    if(k &lt; count(t-&gt;l)) set_element(t-&gt;l, k, x);
    else if(k == count(t-&gt;l)) t-&gt;key = t-&gt;sum = x;
    else set_element(t-&gt;r, k - count(t-&gt;l) - 1, x);
    t = update(t);
  }


  int size(Node *t) {
    return count(t);
  }

  bool empty(Node *t) {
    return !t;
  }

  Node *makeset() {
    return nullptr;
  }
};


##################################################
############## bipartite-graph.cpp ###############
##################################################

struct BipartiteGraph : UnionFind
{
  vector&lt; int &gt; color;

  BipartiteGraph(int v) : color(v + v, -1), UnionFind(v + v) {}

  bool bipartite_graph_coloring()
  {
    for(int i = 0; i &lt; color.size() / 2; i++) {
      int a = find(i);
      int b = find(i + (int) color.size() / 2);
      if(a == b) return (false);
      if(color[a] &lt; 0) color[a] = 0, color[b] = 1;
    }
    return (true);
  }

  bool operator[](int k)
  {
    return (bool(color[find(k)]));
  }
};


##################################################
################ li-chao-tree.cpp ################
##################################################

template&lt; typename T &gt;
struct LiChaoTree {
  struct Line {
    T a, b;

    Line(T a, T b) : a(a), b(b) {}

    inline T get(T x) const { return a * x + b; }

    inline bool over(const Line &amp;b, const T &amp;x) const {
      return get(x) &lt; b.get(x);
    }
  };

  vector&lt; T &gt; xs;
  vector&lt; Line &gt; seg;
  int sz;

  LiChaoTree(const vector&lt; T &gt; &amp;x, T INF) : xs(x) {
    sz = 1;
    while(sz &lt; xs.size()) sz &lt;&lt;= 1;
    while(xs.size() &lt; sz) xs.push_back(xs.back() + 1);
    seg.assign(2 * sz - 1, Line(0, INF));
  }

  void update(Line &amp;x, int k, int l, int r) {
    int mid = (l + r) &gt;&gt; 1;
    auto latte = x.over(seg[k], xs[l]), malta = x.over(seg[k], xs[mid]);
    if(malta) swap(seg[k], x);
    if(l + 1 &gt;= r) return;
    else if(latte != malta) update(x, 2 * k + 1, l, mid);
    else update(x, 2 * k + 2, mid, r);
  }

  void update(T a, T b) { // ax+b
    Line l(a, b);
    update(l, 0, 0, sz);
  }

  T query(int k) { // xs[k]
    const T x = xs[k];
    k += sz - 1;
    T ret = seg[k].get(x);
    while(k &gt; 0) {
      k = (k - 1) &gt;&gt; 1;
      ret = min(ret, seg[k].get(x));
    }
    return ret;
  }
};


##################################################
########### persistent-binary-trie.cpp ###########
##################################################

template&lt; typename T &gt;
struct BinaryTrieNode {
  using Node = BinaryTrieNode&lt; T &gt;;

  BinaryTrieNode&lt; T &gt; *nxt[2];
  int max_index;

  BinaryTrieNode() : max_index(-1) {
    nxt[0] = nxt[1] = nullptr;
  }

  void update_direct(int id) {
    max_index = max(max_index, id);
  }

  void update_child(Node *child, int id) {
    max_index = max(max_index, id);
  }

  Node *add(const T &amp;bit, int bit_index, int id, bool need = true) {
    Node *node = need ? new Node(*this) : this;
    if(bit_index == -1) {
      node-&gt;update_direct(id);
    } else {
      const int c = (bit &gt;&gt; bit_index) &amp; 1;
      if(node-&gt;nxt[c] == nullptr) node-&gt;nxt[c] = new Node(), need = false;
      node-&gt;nxt[c] = node-&gt;nxt[c]-&gt;add(bit, bit_index - 1, id, need);
      node-&gt;update_child(node-&gt;nxt[c], id);
    }
    return node;
  }

  inline T min_query(T bit, int bit_index, int bit2, int l) {
    if(bit_index == -1) return bit;
    int c = (bit2 &gt;&gt; bit_index) &amp; 1;
    if(nxt[c] != nullptr &amp;&amp; l &lt;= nxt[c]-&gt;max_index) {
      return nxt[c]-&gt;min_query(bit, bit_index - 1, bit2, l);
    } else {
      return nxt[1 ^ c]-&gt;min_query(bit | (1LL &lt;&lt; bit_index), bit_index - 1, bit2, l);
    }
  }
};

template&lt; typename T, int MAX_LOG &gt;
struct PersistentBinaryTrie {
  using Node = BinaryTrieNode&lt; T &gt;;
  Node *root;

  PersistentBinaryTrie(Node *root) : root(root) {}

  PersistentBinaryTrie() : root(new Node()) {}

  PersistentBinaryTrie add(const T &amp;bit, int id) {
    return PersistentBinaryTrie(root-&gt;add(bit, MAX_LOG, id));
  }

  T min_query(int bit, int l) {
    return root-&gt;min_query(0, MAX_LOG, bit, l);
  }
};


##################################################
################ segment-tree.cpp ################
##################################################

template&lt; typename Monoid &gt;
struct SegmentTree {
  using F = function&lt; Monoid(Monoid, Monoid) &gt;;

  int sz;
  vector&lt; Monoid &gt; seg;

  const F f;
  const Monoid M1;

  SegmentTree(int n, const F f, const Monoid &amp;M1) : f(f), M1(M1) {
    sz = 1;
    while(sz &lt; n) sz &lt;&lt;= 1;
    seg.assign(2 * sz, M1);
  }

  void set(int k, const Monoid &amp;x) {
    seg[k + sz] = x;
  }

  void build() {
    for(int k = sz - 1; k &gt; 0; k--) {
      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);
    }
  }

  void update(int k, const Monoid &amp;x) {
    k += sz;
    seg[k] = x;
    while(k &gt;&gt;= 1) {
      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);
    }
  }

  Monoid query(int a, int b) {
    Monoid L = M1, R = M1;
    for(a += sz, b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
      if(a &amp; 1) L = f(L, seg[a++]);
      if(b &amp; 1) R = f(seg[--b], R);
    }
    return f(L, R);
  }

  Monoid operator[](const int &amp;k) const {
    return seg[k + sz];
  }

  template&lt; typename C &gt;
  int find_subtree(int a, const C &amp;check, Monoid &amp;M, bool type) {
    while(a &lt; sz) {
      Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);
      if(check(nxt)) a = 2 * a + type;
      else M = nxt, a = 2 * a + 1 - type;
    }
    return a - sz;
  }


  template&lt; typename C &gt;
  int find_first(int a, const C &amp;check) {
    Monoid L = M1;
    if(a &lt;= 0) {
      if(check(f(L, seg[1]))) return find_subtree(1, check, L, false);
      return -1;
    }
    int b = sz;
    for(a += sz, b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
      if(a &amp; 1) {
        Monoid nxt = f(L, seg[a]);
        if(check(nxt)) return find_subtree(a, check, L, false);
        L = nxt;
        ++a;
      }
    }
    return -1;
  }

  template&lt; typename C &gt;
  int find_last(int b, const C &amp;check) {
    Monoid R = M1;
    if(b &gt;= sz) {
      if(check(f(seg[1], R))) return find_subtree(1, check, R, true);
      return -1;
    }
    int a = sz;
    for(b += sz; a &lt; b; a &gt;&gt;= 1, b &gt;&gt;= 1) {
      if(b &amp; 1) {
        Monoid nxt = f(seg[--b], R);
        if(check(nxt)) return find_subtree(b, check, R, true);
        R = nxt;
      }
    }
    return -1;
  }
};



##################################################
################ binary-trie.cpp #################
##################################################

template&lt; typename T, int MAX_LOG &gt;
struct BinaryTrie {
  BinaryTrie *nxt[2];
  T lazy;
  int exist;
  bool fill;
  vector&lt; int &gt; accept;

  BinaryTrie() : exist(0), lazy(0), nxt{nullptr, nullptr} {}

  void add(const T &amp;bit, int bit_index, int id) {
    propagate(bit_index);
    if(bit_index == -1) {
      ++exist;
      accept.push_back(id);
    } else {
      auto &amp;to = nxt[(bit &gt;&gt; bit_index) &amp; 1];
      if(!to) to = new BinaryTrie();
      to-&gt;add(bit, bit_index - 1, id);
      ++exist;
    }
  }

  void add(const T &amp;bit, int id) {
    add(bit, MAX_LOG, id);
  }

  void add(const T &amp;bit) {
    add(bit, exist);
  }

  void del(const T &amp;bit, int bit_index) {
    propagate(bit_index);
    if(bit_index == -1) {
      exist--;
    } else {
      nxt[(bit &gt;&gt; bit_index) &amp; 1]-&gt;del(bit, bit_index - 1);
      exist--;
    }
  }

  void del(const T &amp;bit) {
    del(bit, MAX_LOG);
  }


  pair&lt; T, BinaryTrie * &gt; max_element(int bit_index) {
    propagate(bit_index);
    if(bit_index == -1) return {0, this};
    if(nxt[1] &amp;&amp; nxt[1]-&gt;size()) {
      auto ret = nxt[1]-&gt;max_element(bit_index - 1);
      ret.first |= T(1) &lt;&lt; bit_index;
      return ret;
    } else {
      return nxt[0]-&gt;max_element(bit_index - 1);
    }
  }

  pair&lt; T, BinaryTrie * &gt; min_element(int bit_index) {
    propagate(bit_index);
    if(bit_index == -1) return {0, this};
    if(nxt[0] &amp;&amp; nxt[0]-&gt;size()) {
      return nxt[0]-&gt;min_element(bit_index - 1);
    } else {
      auto ret = nxt[1]-&gt;min_element(bit_index - 1);
      ret.first |= T(1) &lt;&lt; bit_index;
      return ret;
    }
  }

  T mex_query(int bit_index) { // distinct-values
    propagate(bit_index);
    if(bit_index == -1 || !nxt[0]) return 0;
    if(nxt[0]-&gt;size() == (T(1) &lt;&lt; bit_index)) {
      T ret = T(1) &lt;&lt; bit_index;
      if(nxt[1]) ret |= nxt[1]-&gt;mex_query(bit_index - 1);
      return ret;
    } else {
      return nxt[0]-&gt;mex_query(bit_index - 1);
    }
  }

  int64_t count_less(const T &amp;bit, int bit_index) {
    propagate(bit_index);
    if(bit_index == -1) return 0;
    int64_t ret = 0;
    if((bit &gt;&gt; bit_index) &amp; 1) {
      if(nxt[0]) ret += nxt[0]-&gt;size();
      if(nxt[1]) ret += nxt[1]-&gt;count_less(bit, bit_index - 1);
    } else {
      if(nxt[0]) ret += nxt[0]-&gt;count_less(bit, bit_index - 1);
    }
    return ret;
  }

  pair&lt; T, BinaryTrie * &gt; get_kth(int64_t k, int bit_index) { // 1-indexed
    propagate(bit_index);
    if(bit_index == -1) return {0, this};
    if((nxt[0] ? nxt[0]-&gt;size() : 0) &lt; k) {
      auto ret = nxt[1]-&gt;get_kth(k - (nxt[0] ? nxt[0]-&gt;size() : 0), bit_index - 1);
      ret.first |= T(1) &lt;&lt; bit_index;
      return ret;
    } else {
      return nxt[0]-&gt;get_kth(k, bit_index - 1);
    }
  }

  pair&lt; T, BinaryTrie * &gt; max_element() {
    assert(exist);
    return max_element(MAX_LOG);
  }

  pair&lt; T, BinaryTrie * &gt; min_element() {
    assert(exist);
    return min_element(MAX_LOG);
  }

  T mex_query() {
    return mex_query(MAX_LOG);
  }

  int size() const {
    return exist;
  }

  void xorpush(const T &amp;bit) {
    lazy ^= bit;
  }

  int64_t count_less(const T &amp;bit) {
    return count_less(bit, MAX_LOG);
  }

  pair&lt; T, BinaryTrie * &gt; get_kth(int64_t k) {
    assert(0 &lt; k &amp;&amp; k &lt;= size());
    return get_kth(k, MAX_LOG);
  }

  void propagate(int bit_index) {
    if((lazy &gt;&gt; bit_index) &amp; 1) swap(nxt[0], nxt[1]);
    if(nxt[0]) nxt[0]-&gt;lazy ^= lazy;
    if(nxt[1]) nxt[1]-&gt;lazy ^= lazy;
    lazy = 0;
  }
};


##################################################
########### disjoint-sparse-table.cpp ############
##################################################

template&lt; typename Semigroup &gt;
struct DisjointSparseTable {
  using F = function&lt; Semigroup(Semigroup, Semigroup) &gt;;
  const F f;
  vector&lt; vector&lt; Semigroup &gt; &gt; st;

  DisjointSparseTable(const vector&lt; Semigroup &gt; &amp;v, const F &amp;f) : f(f) {
    int b = 0;
    while((1 &lt;&lt; b) &lt;= v.size()) ++b;
    st.resize(b, vector&lt; Semigroup &gt;(v.size(), Semigroup()));
    for(int i = 0; i &lt; v.size(); i++) st[0][i] = v[i];
    for(int i = 1; i &lt; b; i++) {
      int shift = 1 &lt;&lt; i;
      for(int j = 0; j &lt; v.size(); j += shift &lt;&lt; 1) {
        int t = min(j + shift, (int) v.size());
        st[i][t - 1] = v[t - 1];
        for(int k = t - 2; k &gt;= j; k--) st[i][k] = f(v[k], st[i][k + 1]);
        if(v.size() &lt;= t) break;
        st[i][t] = v[t];
        int r = min(t + shift, (int) v.size());
        for(int k = t + 1; k &lt; r; k++) st[i][k] = f(st[i][k - 1], v[k]);
      }
    }
  }

  Semigroup query(int l, int r) {
    if(l &gt;= --r) return st[0][l];
    int p = 31 - __builtin_clz(l ^ r);
    return f(st[p][l], st[p][r]);
  }
};


##################################################
############### wavelet-matrix.cpp ###############
##################################################

struct SuccinctIndexableDictionary {
  size_t length;
  size_t blocks;
  vector&lt; unsigned &gt; bit, sum;

  SuccinctIndexableDictionary() {
  }

  SuccinctIndexableDictionary(size_t _length) {
    length = _length;
    blocks = (length + 31) &gt;&gt; 5;
    bit.assign(blocks, 0U);
    sum.assign(blocks, 0U);
  }

  void set(int k) {
    bit[k &gt;&gt; 5] |= 1U &lt;&lt; (k &amp; 31);
  }

  void build() {
    sum[0] = 0U;
    for(int i = 1; i &lt; blocks; i++) {
      sum[i] = sum[i - 1] + __builtin_popcount(bit[i - 1]);
    }
  }

  bool operator[](int k) const {
    return (bool((bit[k &gt;&gt; 5] &gt;&gt; (k &amp; 31)) &amp; 1));
  }

  int rank(int k) {
    return (sum[k &gt;&gt; 5] + __builtin_popcount(bit[k &gt;&gt; 5] &amp; ((1U &lt;&lt; (k &amp; 31)) - 1)));
  }

  int rank(bool val, int k) {
    return (val ? rank(k) : k - rank(k));
  }

  int select(bool val, int k) {
    if(k &lt; 0 || rank(val, length) &lt;= k) return (-1);
    int low = 0, high = length;
    while(high - low &gt; 1) {
      int mid = (low + high) &gt;&gt; 1;
      if(rank(val, mid) &gt;= k + 1) high = mid;
      else low = mid;
    }
    return (high - 1);
  }

  int select(bool val, int i, int l) {
    return select(val, i + rank(val, l));
  }
};

template&lt; class T, int MAXLOG &gt;
struct WaveletMatrix {
  size_t length;
  SuccinctIndexableDictionary matrix[MAXLOG];
  int zs[MAXLOG];
  int buff1[MAXLOG], buff2[MAXLOG];

  int freq_dfs(int d, int l, int r, T val, T a, T b) {
    if(l == r) return 0;
    if(d == MAXLOG) return (a &lt;= val &amp;&amp; val &lt; b) ? r - l : 0;
    T nv = 1ULL &lt;&lt; (MAXLOG - d - 1) | val, nnv = ((1ULL &lt;&lt; (MAXLOG - d - 1)) - 1) | nv;
    if(nnv &lt; a || b &lt;= val) return 0;
    if(a &lt;= val &amp;&amp; nnv &lt; b) return r - l;
    int lc = matrix[d].rank(1, l), rc = matrix[d].rank(1, r);
    return freq_dfs(d + 1, l - lc, r - rc, val, a, b) +
           freq_dfs(d + 1, lc + zs[d], rc + zs[d], nv, a, b);
  }

  WaveletMatrix(vector&lt; T &gt; data) {
    length = data.size();
    vector&lt; T &gt; l(length), r(length);
    for(int depth = 0; depth &lt; MAXLOG; depth++) {
      matrix[depth] = SuccinctIndexableDictionary(length + 1);
      int left = 0, right = 0;
      for(int i = 0; i &lt; length; i++) {
        bool k = (data[i] &gt;&gt; (MAXLOG - depth - 1)) &amp; 1;
        if(k) r[right++] = data[i], matrix[depth].set(i);
        else l[left++] = data[i];
      }
      zs[depth] = left;
      matrix[depth].build();
      swap(l, data);
      for(int i = 0; i &lt; right; i++) data[left + i] = r[i];
    }
  }

  T access(int k) {
    int ret = 0;
    bool bit;
    for(int depth = 0; depth &lt; MAXLOG; depth++) {
      bit = matrix[depth][k];
      ret = (ret &lt;&lt; 1) | bit;
      k = matrix[depth].rank(bit, k) + zs[depth] * bit;
    }
    return (ret);
  }

  int rank(T val, int k) {
    int l = 0, r = k;
    for(int depth = 0; depth &lt; MAXLOG; depth++) {
      buff1[depth] = l, buff2[depth] = r;
      bool bit = (val &gt;&gt; (MAXLOG - depth - 1)) &amp; 1;
      l = matrix[depth].rank(bit, l) + zs[depth] * bit;
      r = matrix[depth].rank(bit, r) + zs[depth] * bit;
    }
    return (r - l);
  }

  int select(T val, int kth) {
    rank(val, length);
    for(int depth = MAXLOG - 1; depth &gt;= 0; depth--) {
      bool bit = (val &gt;&gt; (MAXLOG - depth - 1)) &amp; 1;
      kth = matrix[depth].select(bit, kth, buff1[depth]);
      if(kth &gt;= buff2[depth] || kth &lt; 0) return (-1);
      kth -= buff1[depth];
    }
    return (kth);
  }

  int select(T val, int k, int l) {
    return select(val, k + rank(val, l));
  }

  int quantile(int left, int right, int kth) {
    if(right - left &lt;= kth || kth &lt; 0) return (-1);
    T ret = 0;
    for(int depth = 0; depth &lt; MAXLOG; depth++) {
      int l = matrix[depth].rank(1, left);
      int r = matrix[depth].rank(1, right);
      if(r - l &gt; kth) {
        left = l + zs[depth];
        right = r + zs[depth];
        ret |= 1ULL &lt;&lt; (MAXLOG - depth - 1);
      } else {
        kth -= r - l;
        left -= l;
        right -= r;
      }
    }
    return ret;
  }

  int rangefreq(int left, int right, T lower, T upper) {
    return freq_dfs(0, left, right, 0, lower, upper);
  }
};



##################################################
############# sqrt-decomposition.cpp #############
##################################################

template&lt; typename T, typename E = int &gt;
struct SqrtDecomposition {

  vector&lt; E &gt; block_add, elem_add;
  vector&lt; int &gt; block_pos;
  vector&lt; T &gt; data, lsum;
  vector&lt; vector&lt; T &gt; &gt; sum;
  int N, B, K;
  E L;

  SqrtDecomposition(int N, E L = 0) : N(N), L(L) { // find the sum of L or more in the interval
    B = (int) sqrt(N);
    K = (N + B - 1) / B;

    block_add.assign(K, 0);
    block_pos.resize(N);
    for(int k = 0; k &lt; K; k++) {
      for(int i = k * B; i &lt; min((k + 1) * B, N); i++) block_pos[i] = k;
    }
    elem_add.assign(N, 0);
    data.assign(N, 0);
    sum.assign(K, vector&lt; T &gt;(B, 0));
    lsum.assign(K, 0);
  }


  void build(const vector&lt; E &gt; &amp;add, const vector&lt; T &gt; &amp;dat) {
    assert(add.size() == elem_add.size());
    assert(dat.size() == data.size());
    elem_add = add;
    data = dat;
    for(int k = 0; k &lt; K; k++) {
      E tap = elem_add[k * B];
      for(int i = k * B; i &lt; min((k + 1) * B, N); i++) tap = min(tap, elem_add[i]);
      block_add[k] = tap;
      for(int i = k * B; i &lt; min((k + 1) * B, N); i++) {
        elem_add[i] -= block_add[k];
        set(i, dat[i]);
      }
    }
  }

  inline void del(int k) {
    sum[block_pos[k]][elem_add[k]] -= data[k];
    if(block_add[block_pos[k]] + elem_add[k] &gt;= L) lsum[block_pos[k]] -= data[k];
  }

  inline void set(int k) {
    while(sum[block_pos[k]].size() &lt;= elem_add[k]) sum[block_pos[k]].push_back(0);
    sum[block_pos[k]][elem_add[k]] += data[k];
    if(block_add[block_pos[k]] + elem_add[k] &gt;= L) lsum[block_pos[k]] += data[k];
  }

  void set(int k, T x) {
    data[k] = x;
    set(k);
  }

  void add(int a, int b) {
    for(int k = 0; k &lt; K; k++) {
      int l = k * B;
      int r = min(l + B, N);

      if(r &lt;= a || b &lt;= l) {

      } else if(a &lt;= l &amp;&amp; r &lt;= b) {
        block_add[k]++;
        if(0 &lt;= L - block_add[k] &amp;&amp; L - block_add[k] &lt; sum[k].size()) {
          lsum[k] += sum[k][L - block_add[k]];
        }
      } else {
        for(int i = max(a, l); i &lt; min(b, r); i++) {
          del(i);
          elem_add[i]++;
          set(i);
        }
      }
    }
  }


  void sub(int a, int b) {
    for(int k = 0; k &lt; K; k++) {
      int l = k * B;
      int r = min(l + B, N);

      if(r &lt;= a || b &lt;= l) {

      } else if(a &lt;= l &amp;&amp; r &lt;= b) {
        if(0 &lt;= L - block_add[k] &amp;&amp; L - block_add[k] &lt; sum[k].size()) {
          lsum[k] -= sum[k][L - block_add[k]];
        }
        block_add[k]--;
      } else {
        if(0 &lt;= L - block_add[k] &amp;&amp; L - block_add[k] &lt; sum[k].size()) {
          lsum[k] -= sum[k][L - block_add[k]];
        }
        block_add[k]--;
        for(int i = l; i &lt; max(a, l); i++) {
          del(i);
          elem_add[i]++;
          set(i);
        }
        for(int i = min(b, r); i &lt; r; i++) {
          del(i);
          elem_add[i]++;
          set(i);
        }
      }
    }
  }


  T query(int a, int b, E x) {
    T ret = 0;
    for(int k = 0; k &lt; K; k++) {
      int l = k * B;
      int r = min(l + B, N);

      if(r &lt;= a || b &lt;= l) {

      } else if(a &lt;= l &amp;&amp; r &lt;= b) {
        if(0 &lt;= x - block_add[k] &amp;&amp; x - block_add[k] &lt; sum[k].size()) {
          ret += sum[k][x - block_add[k]];
        }
      } else {
        for(int i = max(a, l); i &lt; min(b, r); i++) {
          if(block_add[k] + elem_add[i] == x) ret += data[i];
        }
      }
    }
    return ret;
  }


  T query_low(int a, int b) {
    T ret = 0;
    for(int k = 0; k &lt; K; k++) {
      int l = k * B;
      int r = min(l + B, N);

      if(r &lt;= a || b &lt;= l) {

      } else if(a &lt;= l &amp;&amp; r &lt;= b) {
        ret += lsum[k];
      } else {
        for(int i = max(a, l); i &lt; min(b, r); i++) {
          if(block_add[k] + elem_add[i] &gt;= L) ret += data[i];
        }
      }
    }
    return ret;
  }
};


##################################################
########### priority-sum-structure.cpp ###########
##################################################

template&lt; typename T, typename Compare = less&lt; T &gt;, typename RCompare = greater&lt; T &gt; &gt;
struct PrioritySumStructure {

  size_t k;
  T sum;

  priority_queue&lt; T, vector&lt; T &gt;, Compare &gt; in, d_in;
  priority_queue&lt; T, vector&lt; T &gt;, RCompare &gt; out, d_out;

  PrioritySumStructure(int k) : k(k), sum(0) {}

  void modify() {
    while(in.size() - d_in.size() &lt; k &amp;&amp; !out.empty()) {
      auto p = out.top();
      out.pop();
      if(!d_out.empty() &amp;&amp; p == d_out.top()) {
        d_out.pop();
      } else {
        sum += p;
        in.emplace(p);
      }
    }
    while(in.size() - d_in.size() &gt; k) {
      auto p = in.top();
      in.pop();
      if(!d_in.empty() &amp;&amp; p == d_in.top()) {
        d_in.pop();
      } else {
        sum -= p;
        out.emplace(p);
      }
    }
    while(!d_in.empty() &amp;&amp; in.top() == d_in.top()) {
      in.pop();
      d_in.pop();
    }
  }

  T query() const {
    return sum;
  }

  void insert(T x) {
    in.emplace(x);
    sum += x;
    modify();
  }

  void erase(T x) {
    assert(size());
    if(!in.empty() &amp;&amp; in.top() == x) {
      sum -= x;
      in.pop();
    } else if(!in.empty() &amp;&amp; RCompare()(in.top(), x)) {
      sum -= x;
      d_in.emplace(x);
    } else {
      d_out.emplace(x);
    }
    modify();
  }

  void set_k(size_t kk) {
    k = kk;
    modify();
  }

  size_t get_k() const {
    return k;
  }

  size_t size() const {
    return in.size() + out.size() - d_in.size() - d_out.size();
  }
};

template&lt; typename T &gt;
using MaximumSum = PrioritySumStructure&lt; T, greater&lt; T &gt;, less&lt; T &gt; &gt;;

template&lt; typename T &gt;
using MinimumSum = PrioritySumStructure&lt; T, less&lt; T &gt;, greater&lt; T &gt; &gt;;



##################################################
############### link-cut-tree.cpp ################
##################################################

template&lt; typename Monoid = int, typename OperatorMonoid = Monoid &gt;
struct LinkCutTree {
  using F = function&lt; Monoid(Monoid, Monoid) &gt;;
  using G = function&lt; Monoid(Monoid, OperatorMonoid, int) &gt;;
  using H = function&lt; OperatorMonoid(OperatorMonoid, OperatorMonoid) &gt;;
  using S = function&lt; Monoid(Monoid) &gt;;

  struct Node {
    Node *l, *r, *p;
    int idx;
    Monoid key, sum;
    OperatorMonoid lazy;

    bool rev;
    int sz;

    bool is_root() {
      return !p || (p-&gt;l != this &amp;&amp; p-&gt;r != this);
    }

    Node(int idx, const Monoid &amp;key, const OperatorMonoid &amp;om) :
        idx(idx), key(key), sum(key), lazy(om), sz(1),
        l(nullptr), r(nullptr), p(nullptr), rev(false) {}
  };

  const Monoid M1;
  const OperatorMonoid OM0;
  const F f;
  const G g;
  const H h;
  const S s;

  LinkCutTree() : LinkCutTree([](Monoid a, Monoid b) { return a + b; }, [](Monoid a) { return a; }, Monoid()) {}

  LinkCutTree(const F &amp;f, const S &amp;s, const Monoid &amp;M1) :
      LinkCutTree(f, G(), H(), s, M1, OperatorMonoid()) {}

  LinkCutTree(const F &amp;f, const G &amp;g, const H &amp;h, const S &amp;s,
              const Monoid &amp;M1, const OperatorMonoid &amp;OM0) :
      f(f), g(g), h(h), s(s), M1(M1), OM0(OM0) {}

  Node *make_node(int idx, const Monoid &amp;v = Monoid()) {
    return new Node(idx, v, OM0);
  }

  void propagate(Node *t, const OperatorMonoid &amp;x) {
    t-&gt;lazy = h(t-&gt;lazy, x);
    t-&gt;key = g(t-&gt;key, x, 1);
    t-&gt;sum = g(t-&gt;sum, x, t-&gt;sz);
  }

  void toggle(Node *t) {
    assert(t);
    swap(t-&gt;l, t-&gt;r);
    t-&gt;sum = s(t-&gt;sum);
    t-&gt;rev ^= true;
  }

  void push(Node *t) {
    if(t-&gt;lazy != OM0) {
      if(t-&gt;l) propagate(t-&gt;l, t-&gt;lazy);
      if(t-&gt;r) propagate(t-&gt;r, t-&gt;lazy);
      t-&gt;lazy = OM0;
    }
    if(t-&gt;rev) {
      if(t-&gt;l) toggle(t-&gt;l);
      if(t-&gt;r) toggle(t-&gt;r);
      t-&gt;rev = false;
    }
  }

  void update(Node *t) {
    t-&gt;sz = 1;
    t-&gt;sum = t-&gt;key;
    if(t-&gt;l) t-&gt;sz += t-&gt;l-&gt;sz, t-&gt;sum = f(t-&gt;l-&gt;sum, t-&gt;sum);
    if(t-&gt;r) t-&gt;sz += t-&gt;r-&gt;sz, t-&gt;sum = f(t-&gt;sum, t-&gt;r-&gt;sum);
  }

  void rotr(Node *t) {
    auto *x = t-&gt;p, *y = x-&gt;p;
    if((x-&gt;l = t-&gt;r)) t-&gt;r-&gt;p = x;
    t-&gt;r = x, x-&gt;p = t;
    update(x), update(t);
    if((t-&gt;p = y)) {
      if(y-&gt;l == x) y-&gt;l = t;
      if(y-&gt;r == x) y-&gt;r = t;
      update(y);
    }
  }

  void rotl(Node *t) {
    auto *x = t-&gt;p, *y = x-&gt;p;
    if((x-&gt;r = t-&gt;l)) t-&gt;l-&gt;p = x;
    t-&gt;l = x, x-&gt;p = t;
    update(x), update(t);
    if((t-&gt;p = y)) {
      if(y-&gt;l == x) y-&gt;l = t;
      if(y-&gt;r == x) y-&gt;r = t;
      update(y);
    }
  }

  void splay(Node *t) {
    push(t);
    while(!t-&gt;is_root()) {
      auto *q = t-&gt;p;
      if(q-&gt;is_root()) {
        push(q), push(t);
        if(q-&gt;l == t) rotr(t);
        else rotl(t);
      } else {
        auto *r = q-&gt;p;
        push(r), push(q), push(t);
        if(r-&gt;l == q) {
          if(q-&gt;l == t) rotr(q), rotr(t);
          else rotl(t), rotr(t);
        } else {
          if(q-&gt;r == t) rotl(q), rotl(t);
          else rotr(t), rotl(t);
        }
      }
    }
  }

  Node *expose(Node *t) {
    Node *rp = nullptr;
    for(Node *cur = t; cur; cur = cur-&gt;p) {
      splay(cur);
      cur-&gt;r = rp;
      update(cur);
      rp = cur;
    }
    splay(t);
    return rp;
  }

  void link(Node *child, Node *parent) {
    expose(child);
    expose(parent);
    child-&gt;p = parent;
    parent-&gt;r = child;
    update(parent);
  }

  void cut(Node *child) {
    expose(child);
    auto *parent = child-&gt;l;
    child-&gt;l = nullptr;
    parent-&gt;p = nullptr;
    update(child);
  }

  void evert(Node *t) {
    expose(t);
    toggle(t);
    push(t);
  }

  Node *lca(Node *u, Node *v) {
    if(get_root(u) != get_root(v)) return nullptr;
    expose(u);
    return expose(v);
  }

  vector&lt; int &gt; get_path(Node *x) {
    vector&lt; int &gt; vs;
    function&lt; void(Node *) &gt; dfs = [&amp;](Node *cur) {
      if(!cur) return;
      push(cur);
      dfs(cur-&gt;r);
      vs.push_back(cur-&gt;idx);
      dfs(cur-&gt;l);
    };
    expose(x);
    dfs(x);
    return vs;
  }

  void set_propagate(Node *t, const OperatorMonoid &amp;x) {
    expose(t);
    propagate(t, x);
    push(t);
  }

  Node *get_kth(Node *x, int k) {
    expose(x);
    while(x) {
      push(x);
      if(x-&gt;r &amp;&amp; x-&gt;r-&gt;sz &gt; k) {
        x = x-&gt;r;
      } else {
        if(x-&gt;r) k -= x-&gt;r-&gt;sz;
        if(k == 0) return x;
        k -= 1;
        x = x-&gt;l;
      }
    }
    return nullptr;
  }

  Node *get_root(Node *x) {
    expose(x);
    while(x-&gt;l) {
      push(x);
      x = x-&gt;l;
    }
    return x;
  }
};



##################################################
########### persistent-union-find.cpp ############
##################################################

struct PersistentUnionFind
{
  PersistentArray&lt; int, 3 &gt; data;

  PersistentUnionFind() {}

  PersistentUnionFind(int sz)
  {
    data.build(vector&lt; int &gt;(sz, -1));
  }

  int find(int k)
  {
    int p = data.get(k);
    return p &gt;= 0 ? find(p) : k;
  }

  int size(int k)
  {
    return (-data.get(find(k)));
  }

  PersistentUnionFind unite(int x, int y)
  {
    x = find(x);
    y = find(y);
    if(x == y) return *this;
    auto u = data.get(x);
    auto v = data.get(y);

    if(u &lt; v) {
      auto a = data.mutable_get(x);
      *a += v;
      auto b = data.mutable_get(y);
      *b = x;
    } else {
      auto a = data.mutable_get(y);
      *a += u;
      auto b = data.mutable_get(x);
      *b = y;
    }
    return *this;
  }
};



</code></pre>

<p><a href="../../index.html">Back to top page</a></p>